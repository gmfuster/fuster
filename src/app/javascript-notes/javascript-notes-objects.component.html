<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">JavaScript notes - Async</h2>       
    <h4 class="CenterMe">You can type the JavaScript code  
      <a class="CenterMe" href="https://replit.com/languages/nodejs" target="_new">on replit.com</a> 
      to see how it works (it is nodejs but you can also choose JavaScript): <br/>   
    </h4>
  
    <br/>
  
    <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
      <p>
        <a  href="/javascript-notes-objects/#create">Create Objs.</a>
    </p>
      <p>
         <a  href="/javascript-notes-objects/#object">Object</a>
      </p>
      <p>        
        <a  href="/javascript-notes-objects/#reference">Reference Types</a>      
      </p>       
      <p>        
        <a  href="/javascript-notes-objects/#functions">Functions</a>      
      </p>  
      <p>
        <a  href="/javascript-notes-objects/#classes">Classes</a>
      </p>
      <p>
        <a  href="/javascript-notes-objects/#styles">Styles</a>
      </p>
    </div>
    
    <div class="PaddedContents">

        In JavaScript, everything is an object except primitive types. Even with primitive types, there is a way to create them as objects instead of just primitive types.
        <br/>
        In OOP we center the code around objects. OOP will provide encapsulation, abstraction, inheritance, and polymorphism.<br/>
        <b>Encapsulation:</b> Have methods with the data that they act upon, and hide the details from the outside.<br/>
        <b>Abstraction:</b> Hiding details from the object reduces complexity. Functions can use objects and their methods without having to know about how they work.<br/>
        <b>Inheritance:</b> You can take advantage of objects (or classes) that already perform what you need so you don’t have to reinvent the wheel.<br/>
        <b>Polymorphism:</b> Different classes (objects) can use the same interface. An example would be method overloading. The method name is the same, 
        but depending on the parameters passed to it will perform things a little different.<br/>


  
      <!-------------------------------------------------------------->
      <!--Create Objects-->
      <!-------------------------------------------------------------->
      <div id="create"></div><br/>
      <hr class="hrHeaderClass" />
          <h2 class="CenterMe">Create Objects</h2>
      <hr class="hrHeaderClass"/>
        
      We can create an object from a primitive type using New and the type.<br/>

      <div class="codeBlock">
        const num = 19;<br/>
        console.log(typeof(num));//number<br/>
        console.log (num === 19); //true<br/>
        <br/>
        const num2 = new Number(20);<br/>
        console.log(typeof(num2)); //object<br/>
        console.log (num === 20); //false<br/>
      </div>

      You can also create it directly, like this:<br/>
      <div class="codeBlock">
        //Create object this way<br/>
        let someObject = &lbrace;<br/>
           &nbsp;  property1:"prop1",<br/>
           &nbsp;  property2: "prop2"<br/>
        &rbrace;<br/>
        console.log(typeof(someObject));//object<br/>
        console.table(someObject);<br/>
      </div>
      This will not throw an error but undefined:  <div class="codeBlock">console.log(someObject.prop);//prop was not defined, shows undefined.</div> 
      You can have functions in there:<br/>

      <div class="codeBlock">
        const someObject = &lbrace;<br/>
            &nbsp;  prop1:function () &lbrace;console.log("I am 1");&rbrace;,<br/>
       }<br/>
       someObject.prop1;//will not do anything (not calling the function)<br/>
       <b>someObject.prop1();//prints "I am 1"</b><br/>
       let aux = someObject.prop1; // assign the function<br/>
       aux(); // prints "I am 1"<br/>
      </div>
      the name of the properties doesn't have to be hardcoded.  Here, the property name will be Jane:<br/>
      <div class="codeBlock">
        const propertyName = "Jane";<br/>
        //use [] to use the variable name<br/>
        const someObject = &lbrace;<br/>
            &nbsp;  [propertyName]:"hello"<br/>
        &rbrace;<br/>
        console.table(someObject);<br/>
      </div>
      And you can also do this:<br/>

    <div class="codeBlock">
        const someObject = &lbrace;<br/>
            &nbsp;  [2+2]:"hello"<br/>
       &rbrace;<br/>
       //access with [] notation.<br/>
       console.log(someObject[4]); //prints "hello"<br/>
       console.log(someObject[1+3]); // prints "hello"<br/>
    </div>  
    To add an additional property we just need to use it and it will be added.<br/>
    <div class="codeBlock">
        const someObject = &lbrace;<br/>
            &nbsp;   p1:"hello"<br/>
       &rbrace;<br/>
       someObject.p2 = "hello 2"<br/>
       console.table(someObject); <br/><br/>
       
       const someObject2 = &lbrace;<br/>
        &nbsp;     p1:"hello 1",<br/>
        &nbsp;    p2:"hello 2"<br/>
       &rbrace;<br/>
       delete someObject2.p2;<br/>
       console.table(someObject2); <br/>
    </div>
    We could also have created the above objects with:<br/>
    <div class="codeBlock">
        const anotherObject = new Object();<br/>
        anotherObject.p1 = "from new 1";<br/>
        anotherObject.p2 = "from new 2";<br/>
        console.table(anotherObject)<br/>
    </div>

    <!-------------------------------------------------------------->
    <!--Object-->
    <!-------------------------------------------------------------->
    <div id="object"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Object</h2>
    <hr class="hrHeaderClass"/>

    With the Object type we get the “values”, “entries”, and “keys” methods as shown below.<br/>
    <div class="codeBlock">
        const someObject = &lbrace;<br/>
            &nbsp;    p1:"hello 1",<br/>
            &nbsp;    p2:"hello 2"<br/>
       &rbrace;<br/>
       console.log(Object.values(someObject));//[ 'hello 1', 'hello 2' ]<br/>
       console.log(Object.keys(someObject));//[ 'p1', 'p2' ]<br/>
       console.log(Object.entries(someObject));//[ [ 'p1', 'hello 1' ], [ 'p2', 'hello 2' ] ]<br/>
    </div>
    When you create an object as a constant, the object variable itself will be a constant but the properties will not be.<br/>
    <div class="codeBlock">
        const someObject = &lbrace;<br/>
            &nbsp;  p1:"hello 1",<br/>
            &nbsp;  p2:"hello 2"<br/>
       &rbrace;<br/>
       const someObject2 = &lrarr;<br/>
        &nbsp;  p1:"hello 1",<br/>
        &nbsp;  p2:"hello 2"<br/>
       &rbrace;<br/>
       someObject2.p1 = "modifed"//will change it<br/>
       console.table(someObject2);<br/><br/>
       
       someObject = &lbrace;p1:"hey"&rbrace;;//error: assignment to constant<br/>
    </div>

    If you want the whole object to be a constant, you can do the following, which will not throw an error but will not change the property:<br/>
    <div class="codeBlock">
        const obj1 = Object.freeze(&lbrace;prop1: 'hey const 1', prop2: "hey const 2"&rbrace;);<br/>
        obj1.prop1 = "CHANGED IT";<br/>
        console.log(obj1.prop1);//prints "hey const 1"<br/>
    </div>
    We can also check whether an object has a property:<br/>
    <div class="codeBlock">
        const obj1 = &lbrace;<br/>
            &nbsp;    p1 : "I am 1",<br/>
            &nbsp;    p2 : "I am 2"<br/>
       &rbrace;<br/>
       console.log(obj1.hasOwnProperty("p3"));//false<br/>
       console.log(obj1.hasOwnProperty("p1"));//true<br/>
    </div>


    <!--<img width="100%" src="assets\images\js\promise1.png" alt="promise 1" /><br/><br/>-->

    
 <!-------------------------------------------------------------->
    <!--Reference-->
    <!-------------------------------------------------------------->
    <div id="reference"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Reference Types</h2>
    <hr class="hrHeaderClass"/>

    When we are assigning an object variable to another object variables, what the object is “saying” is “here, 
    this is the the box where my data is, I’ll share it with you, if you change it you will change it for me too.”  That is not the case 
    with primitives<br/>

    <div class="codeBlock">
        //create object and primitive<br/>
        const obj1 = &lbrace; p:1&rbrace;;<br/>
        const x = 1;<br/>
        //assign them to new variables<br/>
        const obj2 = obj1;<br/>
        let y = x;<br/>
        //change the recently created variables<br/>
        obj2.p = 2;<br/>
        y = 2;<br/>
        //check the values of all<br/>
        console.table(obj1);//p-2<br/>
        console.table(obj2);//p-2<br/><br/>

        console.log(x);//1<br/>
        console.log(y);//2<br/>
    </div>
    <br/>
    So if what we want is a copy that behaves like a copy for a primitive type, 
    we need to do what we call a <b>deep cloning</b>. With deep cloning all the properties will get a new copy.<br/>
    <div class="codeBlock">
        const obj1 = &lbrace; p:1&rbrace;;<br/>
        <b>const obj2 = JSON.parse(JSON.stringify(obj1));</b><br/>
        obj2.p = 2;<br/>
        console.table(obj1); //1<br/>
        console.table(obj2); //2<br/>
    </div>
    <br/>
    In <b>shallow cloning</b>, the primitive elements of the object will be copied, but the reference types will still share the memory location.
    <div class="codeBlock">
        let obj1 = &lbrace; p:1&rbrace;;<br/>
        <b>let obj2 = Object.assign(&lbrace;&rbrace;,obj1);</b> // or &lbrace;...obj1&rbrace;;<br/>
        obj2.p = 2;<br/>
        console.log(obj1);//&lbrace; p: 1 &rbrace;<br/>
        console.log(obj2);//&lbrace; p: 2&rbrace;<br/>
    </div>
    <br/>
    Array (reference). Notice the difference between reassigning the property to a new array and changing the array itself.<br/>
    Changing the array itself will affect both objects because we are changing the contents of the box where the array is located.<br/>
    Assigning a new array to one of the objects is not sharing the same box anymore<br/>
    <div class="codeBlock">
        let obj1 = &lbrace; p:[1,2,3,4]&rbrace;;<br/>
        let obj2 = Object.assign(&lbrace;&rbrace;,obj1);<br/>
        let obj3 = Object.assign(&lbrace;&rbrace;,obj1);<br/>
        obj2.p = [5,6];<br/>
        obj3.p.push(1000);<br/>
        console.log(obj1);<br/>
        console.log(obj2);<br/>
        console.log(obj3);<br/>
        //the above will print:<br/>
        // p: [ 1, 2, 3, 4, 1000 ] <br/>
        // p: [ 5, 6 ] <br/>
        // p: [ 1, 2, 3, 4, 1000 ] <br/>
    </div>  
    Object (reference):<br/>
    <div class="codeBlock">
        let obj1 = &lbrace; p:&lbrace;a:1, b:2, c:["a"]&rbrace; &rbrace;;<br/>
        let obj2 = Object.assign(&lbrace;&rbrace;,obj1);<br/>
        let obj3 = Object.assign(&lbrace;&rbrace;,obj1);<br/>
        obj2.p = &lbrace;a:2, b:3, c: ["b"]&rbrace;;<br/><br/>

        obj3.p.a = 3;//Notice this one will change for both<br/>
        obj3.p.c.push("AAAAAAA");<br/><br/>

        console.log(obj1);<br/>
        console.log(obj2);<br/>
        console.log(obj3);<br/>
        //Will print<br/>
        //&lbrace; p: &lbrace; a: 3, b: 2, c: [ 'a', 'AAAAAAA' ] &rbrace; &rbrace;<br/>
        //&lbrace; p: &lbrace; a: 2, b: 3, c: [ 'b' ] &rbrace; &rbrace;<br/>
        //&lbrace; p: &lbrace; a: 3, b: 2, c: [ 'a', 'AAAAAAA' ] &rbrace; &rbrace;<br/>
    </div>



    <!-------------------------------------------------------------->
    <!--functions-->
    <!-------------------------------------------------------------->
    <div id="functions"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Functions</h2>
    <hr class="hrHeaderClass"/>
        
    We ca use functions that we will use to create new objects. The standard is to name this functions starting with uppercase.  
    The standard is to name this functions starting with uppercase.<br/>

    <div class="codeBlock">
        function Vehicle(typearg, yeararg)&lbrace;<br/>
         &nbsp;   this.type = typearg;<br/>
         &nbsp;    this.year = yeararg;<br/>
       &rbrace;<br/>
       let cartype = new Vehicle("car", 2003);<br/><br/>
       
       console.log(Object.getPrototypeOf(cartype)); //Vehicle &lbrace;&rbrace;<br/>
       console.log(cartype.type); //car<br/>
       console.log(cartype instanceof Vehicle); //true<br/>
       console.log(Vehicle.prototype); //Vehicle &lbrace;&rbrace;<br/>
    </div>
    <br/>
    If we want the prototype to have a variable that will be shared among all instances of Vehicle (instead of each one having its own copy as in the 
    ones used above) we can do this:
    <div class="codeBlock">
        function Vehicle(typearg, yeararg)&lbrace;<br/>
            this.type = typearg;<br/>
            this.year = yeararg;<br/>
       &rbrace;<br/>
       Vehicle.prototype.maxwheels = 6;<br/>
       let cartype = new Vehicle("car", 2003);<br/>
       console.table(Vehicle.prototype);//maxwheels = 6<br/>
       console.table(cartype.maxwheels);//6<br/>
    </div><br/>
    The new cartype object has the property maxwheels as 6, but that property belongs to the prototype and it will be passed to all objects.<br/>
    <div class="codeBlock">
        console.log(cartype.hasOwnProperty("type")); //true<br/>
        console.log(cartype.hasOwnProperty("maxwheels"));//false
    </div>
    Once the cartype has been created, changing the maxwheels to some other value will not change it for other objects that were or will be created.<br/><br/>

    Note: You can also set the prototype to a whole new prototype with an assignment, but if you do that you need to include the constructor in it 
    (constructor:Vehicle) because it will be removed by the assignment.<br/>

    Just like you can add a property to the prototype you can also add a method.<br/>

    <div class="codeBlock">
     ... as before ...<br/><br/>

    <b>Vehicle.prototype.printMyInfo = function () </b>&lbrace;<br/>
         console.log(this.type);<br/>
        console.log(this.year);<br/>
        console.log(this.maxwheels);<br/>
    &rbrace;<br/>
    let cartype = new Vehicle("car", 2003);<br/>
    cartype.printMyInfo();<br/>
    </div>   

    Don’t use arrow functions for this since arrow function will not get their own “this” and “this” will refer to the global scope. 
    Even with regular functions, we can be surprised with what we get with “this”. See the example below.<br/>

    <div class="codeBlock">
        function Vehicle(typearg, yeararg)&lbrace; <br/>
          &nbsp;  this.type = typearg;<br/>
          &nbsp;   this.year = yeararg;<br/>
       }<br/>
       Vehicle.prototype.maxwheels = 6;<br/>
       Vehicle.prototype.functionWithFunction = function () &lbrace;<br/>
        &nbsp; console.log("111111111111111") ;<br/>
        &nbsp;  console.log(this);<br/>
        &nbsp; &nbsp;  function innerFunction() &lbrace;<br/>
            &nbsp; &nbsp; &nbsp;    console.log("22222222222222222") ;<br/>
            &nbsp; &nbsp; &nbsp;     console.log(this);<br/>
          &rbrace;<br/>
          &nbsp; &nbsp;  innerFunction();<br/>
       &rbrace;<br/>
       let cartype = new Vehicle("car", 2003);<br/>
       cartype.functionWithFunction();<br/>
       <b>//this for Vehicle refers to that object, this in the inner refers to the global this</b>
    </div>  
    If we need the inner function to access the same this as the Vehicle one:<br/>
    <div class="codeBlock">
        Vehicle.prototype.functionWithFunction = function () &lbrace;<br/>
        &nbsp;    console.log("111111111111111") ;<br/>
        &nbsp;    console.log(this);<br/>
        &nbsp;    <b> const self = this;<br/></b>
        &nbsp;     function innerFunction() &lbrace;<br/>
        &nbsp;  &nbsp;        console.log("22222222222222222") ;<br/>
        &nbsp;  &nbsp;          <b>console.log(self);</b><br/>
             &rbrace;<br/>
             &nbsp;      innerFunction();<br/>
          &rbrace;
    </div>
    <br/>
    So what if we want to have another object of type small vehicle that inherits from Vehicle? <br/>
    <div class="codeBlock">
        function Vehicle(typearg, yeararg)&lbrace;<br/>
            &nbsp;  this.type = typearg;<br/>
            &nbsp;  this.year = yeararg;<br/>
       &rbrace;<br/>
       Vehicle.prototype.printType = function () &lbrace;<br/>
        &nbsp;   console.log(this.type);<br/>
        &nbsp;   console.log(this.year);<br/>
       &rbrace;<br/><br/>

       //new constructor function inheriting from Vehicle<br/>
       function SmallVehicle(wheels, type, year) &lbrace;<br/>
        &nbsp;     Vehicle.call(this, type, year);<br/>
        &nbsp;    this.wheels = wheels;<br/>
       &rbrace;<br/><br/>

       //need this part for the printType function<br/>
       SmallVehicle.prototype = Object.create(Vehicle.prototype);<br/>
       Object.defineProperty(SmallVehicle.prototype, 'constructor', &lbrace;<br/>
        &nbsp;      value: SmallVehicle,<br/>
        &nbsp;     enumerable: false,<br/>
        &nbsp;      writable: true &rbrace;);<br/><br/>
       
       let small = new SmallVehicle(2, "small", 2006);<br/>
       small.printType();<br/>
    </div><br/>
    We can add function specific to the prototype of SmallVehicle if needed<br/>

    <img width="100%" src="assets\images\js\objects1.png" alt="objects 1" /><br/><br/>


    <!-------------------------------------------------------------->
    <!--classes-->
    <!-------------------------------------------------------------->
    <div id="classes"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Classes</h2>
    <hr class="hrHeaderClass"/>
   
    We don’t really have classes in JavaScript because under the hood they will be turned in to the constructor functions we have seen, 
    but as far as coding goes, they look a lot like classes.  From the Vehicle examples above<br/>
    Vehicle will look like this:<br/>
    <div class="codeBlock">
        class Vehicle&lbrace;<br/>
            &nbsp; constructor(typearg, yeararg)&lbrace;<br/>
                &nbsp;   &nbsp;   this.type = typearg;<br/>
                &nbsp;   &nbsp;   this.year = yeararg;<br/>
                &nbsp;  &rbrace;     <br/>
                &nbsp; get theType()&lbrace; //getter<br/>
                    &nbsp;   &nbsp;      return this.type;<br/>
                    &nbsp; &rbrace;     <br/>
                    &nbsp;  set theYear(year)&lbrace;  //setter<br/>
                        &nbsp;   &nbsp;       this.year = year;<br/>
                        &nbsp; &rbrace;     <br/>
                        &nbsp;  printTypeYear ()&lbrace;  //Just a method<br/>
                            &nbsp;   &nbsp;      console.log(this.type);<br/>
                            &nbsp;   &nbsp;      console.log(this.year);<br/>
                            &nbsp;  &rbrace;<br/>
                            &nbsp;  static printSomething()&lbrace;<br/>
                                &nbsp;   &nbsp;       console.log("printing something");<br/>
                                &nbsp;  &rbrace;<br/>
       &rbrace;<br/>
    </div>
    <br/>
    And smallVehicle<br/>
    <div class="codeBlock">
        class SmallVehicle extends Vehicle&lbrace;<br/>
            &nbsp;  constructor (wheels, type, year)&lbrace;<br/>
                &nbsp; &nbsp;    super(type, year); //call super before using "this"<br/>
                &nbsp; &nbsp;   this.wheels = wheels;<br/>
                &nbsp;  &rbrace;<br/>
       &rbrace;<br/>
    </div>  
    <br/>
    To use:<br/>
    <div class="codeBlock">
        let small = new SmallVehicle(2, "small", 2006);<br/>
        small.printTypeYear();<br/>
        console.log(small.wheels);<br/>
        small.theYear = 2011; //use the getter<br/>
        small.printTypeYear();<br/>
        SmallVehicle.printSomething(); //static method<br/>
    </div>
    Note: don’t put more code than you need in the constructor. The constructor will run every time you create a new object with new.<br/>
    Note: You don’t have to use get and set in the names of the getter and setter methods, but it is is a good idea<br/>

    <!-------------------------------------------------------------->
    <!--styless-->
    <!-------------------------------------------------------------->
    <div id="styles"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Styles</h2>
    <hr class="hrHeaderClass"/>
    Because styles are also objects we can do this:<br/>
    <div class="codeBlock">
        var wordStyles = &lbrace;<br/>
            width:"12vw",<br/>
            heigth:"10vh",<br/>
            fontSize:"8vh",<br/>
            border:"3px solid navy"<br/>
        &rbrace;<br/>
        var wordStylesClick = Object.assign(&lbrace;&rbrace;, wordStyles, &lbrace;cursor:"pointer"&rbrace;); <br/><br/>

        &lt;span style=&lbrace;wordStyles&rbrace;&gt;,,,,&lt;/span&gt;<br/>
        &lt;span style=&lbrace;wordStylesClick&rbrace; onClick=&lbrace;this.next&rbrace;&gt;...&lt;/span&gt;<br/>
    </div>
    <br/>
    <br/>









    </div>    
</div>
    