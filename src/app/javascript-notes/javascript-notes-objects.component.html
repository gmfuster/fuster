<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">JavaScript notes - Async</h2>       
    <h4 class="CenterMe">You can type the JavaScript code  
      <a class="CenterMe" href="https://replit.com/languages/nodejs" target="_new">on replit.com</a> 
      to see how it works (it is nodejs but you can also choose JavaScript): <br/>   
    </h4>
  
    <br/>
  
    <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
      <p>
        <a  href="/javascript-notes-objects/#create">Create Objs.</a>
    </p>
      <p>
         <a  href="/javascript-notes-objects/#object">Object</a>
      </p>
      <p>        
        <a  href="/javascript-notes-objects/#reference">Reference Types</a>      
      </p>       
      <p>        
        <a  href="/javascript-notes-objects/#functions">Functions</a>      
      </p>  
      <p>
        <a  href="/javascript-notes-objects/#classes">Classes</a>
      </p>
      <p>
        <a  href="/javascript-notes-objects/#styles">Styles</a>
      </p>
    </div>
    
    <div class="PaddedContents">

        In JavaScript, everything is an object except primitive types. Even with primitive types, there is a way to create them as objects instead of just primitive types.
        <br/>
        In OOP we center the code around objects. OOP will provide encapsulation, abstraction, inheritance, and polymorphism.<br/>
        <b>Encapsulation:</b> Have methods with the data that they act upon, and hide the details from the outside.<br/>
        <b>Abstraction:</b> Hiding details from the object reduces complexity. Functions can use objects and their methods without having to know about how they work.<br/>
        <b>Inheritance:</b> You can take advantage of objects (or classes) that already perform what you need so you don’t have to reinvent the wheel.<br/>
        <b>Polymorphism:</b> Different classes (objects) can use the same interface. An example would be method overloading. The method name is the same, 
        but depending on the parameters passed to it will perform things a little different.<br/>


  
      <!-------------------------------------------------------------->
      <!--Create Objects-->
      <!-------------------------------------------------------------->
      <div id="create"></div><br/>
      <hr class="hrHeaderClass" />
          <h2 class="CenterMe">Create Objects</h2>
      <hr class="hrHeaderClass"/>
        
      We can create an object from a primitive type using New and the type.<br/>
    
      <pre>
        <code>
            const num = 19;
            console.log(typeof(num));//number
            console.log (num === 19); //true
            <br/>
            const num2 = new Number(20);
            console.log(typeof(num2)); //object
            console.log (num === 20); //false
        </code>
      </pre>
     

      You can also create it directly, like this:<br/>
      <pre>
          <code>
            //Create object this way
            let someObject = &lbrace;
               &nbsp;  property1:"prop1",
               &nbsp;  property2: "prop2"
            &rbrace;
            console.log(typeof(someObject));//object
            console.table(someObject);
          </code>
      </pre>
     
      This will not throw an error but undefined:  
      <pre>
          <code>
            console.log(someObject.prop);//prop was not defined, shows undefined.
          </code>
      </pre>
    
      You can have functions in there:<br/>

      <pre>
          <code>
            const someObject = &lbrace;
            &nbsp;  prop1:function () &lbrace;console.log("I am 1");&rbrace;,
            &rbrace;
            someObject.prop1;//will not do anything (not calling the function)
            <b>someObject.prop1();//prints "I am 1"</b>
            let aux = someObject.prop1; // assign the function
            aux(); // prints "I am 1"
          </code>
      </pre>
      
      the name of the properties doesn't have to be hardcoded.  Here, the property name will be Jane:<br/>
      <pre>
          <code>
            const propertyName = "Jane";
            //use [] to use the variable name
            const someObject = &lbrace;
                &nbsp;  [propertyName]:"hello"
            &rbrace;
            console.table(someObject);
          </code>
      </pre>
      
      And you can also do this:<br/>

      <pre>
          <code>
            const someObject = &lbrace;
            &nbsp;  [2+2]:"hello"
            &rbrace;
            //access with [] notation.
            console.log(someObject[4]); //prints "hello"
            console.log(someObject[1+3]); // prints "hello"
          </code>
      </pre>
    
    To add an additional property we just need to use it and it will be added.<br/>

    <pre>
        <code>
            const someObject = &lbrace;
            &nbsp;   p1:"hello"
            &rbrace;
            someObject.p2 = "hello 2"
            console.table(someObject); <br/>
       
            const someObject2 = &lbrace;
             &nbsp;     p1:"hello 1",
             &nbsp;    p2:"hello 2"
             &rbrace;
             delete someObject2.p2;
             console.table(someObject2); 
        </code>
    </pre>
    
    We could also have created the above objects with:<br/>
    <pre>
        <code>
            const anotherObject = new Object();
            anotherObject.p1 = "from new 1";
            anotherObject.p2 = "from new 2";
            console.table(anotherObject)
        </code>
    </pre>    

    <!-------------------------------------------------------------->
    <!--Object-->
    <!-------------------------------------------------------------->
    <div id="object"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Object</h2>
    <hr class="hrHeaderClass"/>

    With the Object type we get the “values”, “entries”, and “keys” methods as shown below.<br/>
    <pre>
        <code>
            const someObject = &lbrace;
            &nbsp;    p1:"hello 1",>
            &nbsp;    p2:"hello 2"
            &rbrace;
            console.log(Object.values(someObject));//[ 'hello 1', 'hello 2' ]
            console.log(Object.keys(someObject));//[ 'p1', 'p2' ]
            console.log(Object.entries(someObject));//[ [ 'p1', 'hello 1' ], [ 'p2', 'hello 2' ] ]
        </code>
    </pre>
   
    When you create an object as a constant, the object variable itself will be a constant but the properties will not be.<br/>
    <pre>
        <code>
            const someObject = &lbrace;
            &nbsp;  p1:"hello 1",
            &nbsp;  p2:"hello 2"
            &rbrace;
            const someObject2 = &lrarr;
             &nbsp;  p1:"hello 1",
             &nbsp;  p2:"hello 2"
            &rbrace;
            someObject2.p1 = "modifed"//will change it
            console.table(someObject2);<br/>
       
            someObject = &lbrace;p1:"hey"&rbrace;;//error: assignment to constant
        </code>
    </pre>
    

    If you want the whole object to be a constant, you can do the following, which will not throw an error but will not change the property:<br/>
    <pre>
        <code>
            const obj1 = Object.freeze(&lbrace;prop1: 'hey const 1', prop2: "hey const 2"&rbrace;);
            obj1.prop1 = "CHANGED IT";
            console.log(obj1.prop1);//prints "hey const 1"
        </code>
    </pre>
    
    We can also check whether an object has a property:<br/>
    <pre>
        <code>
            const obj1 = &lbrace;
            &nbsp;    p1 : "I am 1",
            &nbsp;    p2 : "I am 2"
       &rbrace;
       console.log(obj1.hasOwnProperty("p3"));//false
       console.log(obj1.hasOwnProperty("p1"));//true
        </code>
    </pre>    
    
 <!-------------------------------------------------------------->
    <!--Reference-->
    <!-------------------------------------------------------------->
    <div id="reference"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Reference Types</h2>
    <hr class="hrHeaderClass"/>

    When we are assigning an object variable to another object variables, what the object is “saying” is “here, 
    this is the the box where my data is, I’ll share it with you, if you change it you will change it for me too.”  That is not the case 
    with primitives<br/>

    <pre>
        <code>
            //create object and primitive
            const obj1 = &lbrace; p:1&rbrace;;
            const x = 1;
            //assign them to new variables
            const obj2 = obj1;
            let y = x;
            //change the recently created variables
            obj2.p = 2;
            y = 2;
            //check the values of all
            console.table(obj1);//p-2
            console.table(obj2);//p-2<br/>
    
            console.log(x);//1
            console.log(y);//2
        </code>
    </pre>
  
    <br/>
    So if what we want is a copy that behaves like a copy for a primitive type, 
    we need to do what we call a <b>deep cloning</b>. With deep cloning all the properties will get a new copy.<br/>
    <pre>
        <code>
            const obj1 = &lbrace; p:1&rbrace;;
            <b>const obj2 = JSON.parse(JSON.stringify(obj1));</b>
            obj2.p = 2;
            console.table(obj1); //1
            console.table(obj2); //2
        </code>
    </pre>
    
    <br/>
    In <b>shallow cloning</b>, the primitive elements of the object will be copied, but the reference types will still share the memory location.
    <pre>
        <code>
            let obj1 = &lbrace; p:1&rbrace;;
            <b>let obj2 = Object.assign(&lbrace;&rbrace;,obj1);</b> // or &lbrace;...obj1&rbrace;;
            obj2.p = 2;
            console.log(obj1);//&lbrace; p: 1 &rbrace;
            console.log(obj2);//&lbrace; p: 2&rbrace;
        </code>
    </pre>
    
    <br/>
    Array (reference). Notice the difference between reassigning the property to a new array and changing the array itself.<br/>
    Changing the array itself will affect both objects because we are changing the contents of the box where the array is located.<br/>
    Assigning a new array to one of the objects is not sharing the same box anymore<br/>
    <pre>
        <code>
            let obj1 = &lbrace; p:[1,2,3,4]&rbrace;;
            let obj2 = Object.assign(&lbrace;&rbrace;,obj1);
            let obj3 = Object.assign(&lbrace;&rbrace;,obj1);
            obj2.p = [5,6];
            obj3.p.push(1000);
            console.log(obj1);
            console.log(obj2);
            console.log(obj3);
            //the above will print:
            // p: [ 1, 2, 3, 4, 1000 ] 
            // p: [ 5, 6 ] 
            // p: [ 1, 2, 3, 4, 1000 ] 
        </code>
    </pre>
    
    Object (reference):<br/>
    <pre>
        <code>
            let obj1 = &lbrace; p:&lbrace;a:1, b:2, c:["a"]&rbrace; &rbrace;;
            let obj2 = Object.assign(&lbrace;&rbrace;,obj1);
            let obj3 = Object.assign(&lbrace;&rbrace;,obj1);
            obj2.p = &lbrace;a:2, b:3, c: ["b"]&rbrace;;<br/>
    
            obj3.p.a = 3;//Notice this one will change for both
            obj3.p.c.push("AAAAAAA");<br/>
    
            console.log(obj1);
            console.log(obj2);
            console.log(obj3);
            //Will print
            //&lbrace; p: &lbrace; a: 3, b: 2, c: [ 'a', 'AAAAAAA' ] &rbrace; &rbrace;
            //&lbrace; p: &lbrace; a: 2, b: 3, c: [ 'b' ] &rbrace; &rbrace;
            //&lbrace; p: &lbrace; a: 3, b: 2, c: [ 'a', 'AAAAAAA' ] &rbrace; &rbrace;
        </code>
    </pre>
   



    <!-------------------------------------------------------------->
    <!--functions-->
    <!-------------------------------------------------------------->
    <div id="functions"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Functions</h2>
    <hr class="hrHeaderClass"/>
        
    We ca use functions that we will use to create new objects. The standard is to name this functions starting with uppercase.  
    The standard is to name this functions starting with uppercase.<br/>
    <pre>
        <code>
            function Vehicle(typearg, yeararg)&lbrace;
            &nbsp;   this.type = typearg;
            &nbsp;    this.year = yeararg;
          &rbrace;
          let cartype = new Vehicle("car", 2003);<br/>
          
          console.log(Object.getPrototypeOf(cartype)); //Vehicle &lbrace;&rbrace;
          console.log(cartype.type); //car
          console.log(cartype instanceof Vehicle); //true
          console.log(Vehicle.prototype); //Vehicle &lbrace;&rbrace;
        </code>
    </pre>
    
    <br/>
    If we want the prototype to have a variable that will be shared among all instances of Vehicle (instead of each one having its own copy as in the 
    ones used above) we can do this:
    <pre>
        <code>
            function Vehicle(typearg, yeararg)&lbrace;
            this.type = typearg;
            this.year = yeararg;
             &rbrace;
            Vehicle.prototype.maxwheels = 6;
            let cartype = new Vehicle("car", 2003);
            console.table(Vehicle.prototype);//maxwheels = 6
            console.table(cartype.maxwheels);//6
        </code>
    </pre>
    <br/>
    The new cartype object has the property maxwheels as 6, but that property belongs to the prototype and it will be passed to all objects.<br/>
    <pre>
        <code>
            console.log(cartype.hasOwnProperty("type")); //true
            console.log(cartype.hasOwnProperty("maxwheels"));//false
        </code>
    </pre>
    
    Once the cartype has been created, changing the maxwheels to some other value will not change it for other objects that were or will be created.<br/><br/>

    Note: You can also set the prototype to a whole new prototype with an assignment, but if you do that you need to include the constructor in it 
    (constructor:Vehicle) because it will be removed by the assignment.<br/>

    Just like you can add a property to the prototype you can also add a method.<br/>

    <pre>
        <code>
            ... as before ...<br/>

            <b>Vehicle.prototype.printMyInfo = function () </b>&lbrace;
                 console.log(this.type);
                console.log(this.year);
                console.log(this.maxwheels);
            &rbrace;
            let cartype = new Vehicle("car", 2003);
            cartype.printMyInfo();
        </code>
    </pre>
      

    Don’t use arrow functions for this since arrow function will not get their own “this” and “this” will refer to the global scope. 
    Even with regular functions, we can be surprised with what we get with “this”. See the example below.<br/>

    <pre>
        <code>
            function Vehicle(typearg, yeararg)&lbrace; 
            &nbsp;  this.type = typearg;
            &nbsp;   this.year = yeararg;
         }
         Vehicle.prototype.maxwheels = 6;
         Vehicle.prototype.functionWithFunction = function () &lbrace;
          &nbsp; console.log("111111111111111") ;
          &nbsp;  console.log(this);
          &nbsp; &nbsp;  function innerFunction() &lbrace;
              &nbsp; &nbsp; &nbsp;    console.log("22222222222222222") ;
              &nbsp; &nbsp; &nbsp;     console.log(this);
            &rbrace;
            &nbsp; &nbsp;  innerFunction();
         &rbrace;
         let cartype = new Vehicle("car", 2003);
         cartype.functionWithFunction();
         <b>//this for Vehicle refers to that object, this in the inner refers to the global this</b>
        </code>
    </pre>
   
    If we need the inner function to access the same this as the Vehicle one:<br/>
    <pre>
        <code>
            Vehicle.prototype.functionWithFunction = function () &lbrace;
            &nbsp;    console.log("111111111111111") ;
            &nbsp;    console.log(this);
            &nbsp;    <b> const self = this;</b>
            &nbsp;     function innerFunction() &lbrace;
            &nbsp;  &nbsp;        console.log("22222222222222222") ;
            &nbsp;  &nbsp;          <b>console.log(self);</b>
                 &rbrace;
                 &nbsp;      innerFunction();
              &rbrace;
        </code>
    </pre>
    
    <br/>
    So what if we want to have another object of type small vehicle that inherits from Vehicle? <br/>
    <pre>
        <code>
            function Vehicle(typearg, yeararg)&lbrace;
            &nbsp;  this.type = typearg;
            &nbsp;  this.year = yeararg;
       &rbrace;
       Vehicle.prototype.printType = function () &lbrace;
        &nbsp;   console.log(this.type);
        &nbsp;   console.log(this.year);
       &rbrace;<br/>

       //new constructor function inheriting from Vehicle
       function SmallVehicle(wheels, type, year) &lbrace;
        &nbsp;     Vehicle.call(this, type, year);
        &nbsp;    this.wheels = wheels;
       &rbrace;<br/>

       //need this part for the printType function
       SmallVehicle.prototype = Object.create(Vehicle.prototype);
       Object.defineProperty(SmallVehicle.prototype, 'constructor', &lbrace;
        &nbsp;      value: SmallVehicle,
        &nbsp;     enumerable: false,
        &nbsp;      writable: true &rbrace;);<br/>
       
       let small = new SmallVehicle(2, "small", 2006);
       small.printType();
        </code>
    </pre>

    <br/>
    We can add function specific to the prototype of SmallVehicle if needed<br/>

    <img width="100%" src="assets\images\js\objects1.png" alt="objects 1" /><br/><br/>


    <!-------------------------------------------------------------->
    <!--classes-->
    <!-------------------------------------------------------------->
    <div id="classes"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Classes</h2>
    <hr class="hrHeaderClass"/>
   
    We don’t really have classes in JavaScript because under the hood they will be turned in to the constructor functions we have seen, 
    but as far as coding goes, they look a lot like classes.  From the Vehicle examples above<br/>
    Vehicle will look like this:<br/>
    <pre>
        <code>
            class Vehicle&lbrace;<br/>
            &nbsp; constructor(typearg, yeararg)&lbrace;
                &nbsp;   &nbsp;   this.type = typearg;
                &nbsp;   &nbsp;   this.year = yeararg;
                &nbsp;  &rbrace;     
                &nbsp; get theType()&lbrace; //getter
                    &nbsp;   &nbsp;      return this.type;
                    &nbsp; &rbrace;     
                    &nbsp;  set theYear(year)&lbrace;  //setter
                        &nbsp;   &nbsp;       this.year = year;
                        &nbsp; &rbrace;     
                        &nbsp;  printTypeYear ()&lbrace;  //Just a method
                            &nbsp;   &nbsp;      console.log(this.type);
                            &nbsp;   &nbsp;      console.log(this.year);
                            &nbsp;  &rbrace;
                            &nbsp;  static printSomething()&lbrace;
                                &nbsp;   &nbsp;       console.log("printing something");
                                &nbsp;  &rbrace;
                        &rbrace;
        </code>
    </pre>
   
    <br/>
    And smallVehicle<br/>
    <pre>
        <code>
            class SmallVehicle extends Vehicle&lbrace;
            &nbsp;  constructor (wheels, type, year)&lbrace;
                &nbsp; &nbsp;    super(type, year); //call super before using "this"
                &nbsp; &nbsp;   this.wheels = wheels;
                &nbsp;  &rbrace;
       &rbrace;
        </code>
    </pre>
   
    <br/>
    To use:<br/>
    <pre>
        <code>
            let small = new SmallVehicle(2, "small", 2006);
            small.printTypeYear();
            console.log(small.wheels);
            small.theYear = 2011; //use the getter
            small.printTypeYear();
            SmallVehicle.printSomething(); //static method
        </code>
    </pre>
    
    Note: don’t put more code than you need in the constructor. The constructor will run every time you create a new object with new.<br/>
    Note: You don’t have to use get and set in the names of the getter and setter methods, but it is is a good idea<br/>

    <!-------------------------------------------------------------->
    <!--styless-->
    <!-------------------------------------------------------------->
    <div id="styles"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Styles</h2>
    <hr class="hrHeaderClass"/>
    Because styles are also objects we can do this:<br/>
    <pre>
        <code>
            var wordStyles = &lbrace;
            width:"12vw",
            heigth:"10vh",
            fontSize:"8vh",
            border:"3px solid navy"
        &rbrace;
        var wordStylesClick = Object.assign(&lbrace;&rbrace;, wordStyles, &lbrace;cursor:"pointer"&rbrace;); <br/>

        &lt;span style=&lbrace;wordStyles&rbrace;&gt;,,,,&lt;/span&gt;
        &lt;span style=&lbrace;wordStylesClick&rbrace; onClick=&lbrace;this.next&rbrace;&gt;...&lt;/span&gt;
        </code>
    </pre>
   
    <br/>
    <br/>









    </div>    
</div>
    