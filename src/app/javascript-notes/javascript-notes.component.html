
<div class="PaddedContents">

  <br/>
  <h2 class="CenterMe">JavaScript notes - Basics</h2>  
  <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
  <h4 class="CenterMe">You can type the JavaScript code  
    <a class="CenterMe" href="https://replit.com/languages/nodejs" target="_new">on replit.com</a> 
    to see how it works (it is nodejs but you can also choose JavaScript): <br/>
 
  </h4>

  <br/>

  <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
    <p>
      <a  href="/javascript-notes/#scope">Scope</a>
    <p>
    <p>
      <a  href="/javascript-notes/#functions">functions</a>
    </p>
    <p>
      <a  href="/javascript-notes/#arrays">Arrays</a>
    </p>
    <p>
      <a  href="/javascript-notes/#this">This</a>
    </p>
    <p>
      <a  href="/javascript-notes/#misc">Misc.</a>
    </p>
  </div>
  
  <div class="PaddedContents">

    <!-------------------------------------------------------------->
    <!--SCOPE-->
    <!-------------------------------------------------------------->
    <div id="scope"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe" >Scope</h2>
    <hr class="hrHeaderClass"/>

    
    <p class="HeadingSubTopic">Scope - variables</p>
    There are two types of scope in JavaScript: Global and Local.  You get global scope when you declare a variable outside of a block, or outside of 
    a function.  Global scope on the browsert is the "window".<br/>
    We can declare variables with var, let, const.  LET and CONST are the same as far as scope is concerned.  Using "var"<br/><br/>

    <img width="100%" src="assets\images\js\varscope1.png" alt="var scope" /><br/><br/>

    Similar code, but now we use LET which has block scope<br/><br/>

    <img width="100%" src="assets\images\js\letscope1.png" alt="let scope" /><br/><br/>

    How about if you use var, outside a function and inside a function (we already know there is no block scope)<br/><br/>

    <img width="100%" src="assets\images\js\varscope2.png" alt="var scope outide func" /><br/><br/>

    When working with JavaScript, 
    make sure you declare the variables before you use them because if you forget to declare a variable and just assign it, you will be creating global variables. 
    HOWEVER, you can stop that by declaring the code with "use strict"<br/>
    <img width="100%" src="assets\images\js\globalbymistake.png" alt="global by  mistake" /><br/><br/>

    Parameters passed to functions act as local variables to the function.

    
    <hr class="hrClass" />

    
    <p class="HeadingSubTopic">Scope - Hoisting</p>

    Hoisting means JavaScript moving variables or function declarations to the top of their context. 
    This means that in JavaScript, functions and variables can be accessed before they have been declared.<br/>
    Variables declared with var, are accessible before they are declared, variables declared with let (or const) are not. See the differences here:<br/><br/>

    <img width="100%" src="assets\images\js\assignthendeclare.png" alt="assign then declare" /><br/><br/>
   
    JavaScript hoists the declarations but not the initializations.  That means, printing a variable to the console before it has been assigned will print undefined.

    <br/>

    <hr class="hrClass" />

    
    <p class="HeadingSubTopic">Scope - Closures</p>

    JavaScript allows for functions inside functions (nested functions). 
    When a function is defined within another function, the inner function has access to the variable scope of the outer function. 
    This is what function closures are.

    <img width="100%" src="assets\images\js\closures1.png" alt="closures 1" /><br/><br/>

    The inner function has access to the parent function at the time of creation, not only while the parent function is running.  This will also work:<br/><br/>

    <img width="100%" src="assets\images\js\closures2.png" alt="closures 2" /><br/><br/>


    <!-------------------------------------------------------------->
    <!--FUNCTIONS-->
    <!--------------------------------------------------------------> 
    <div id="functions"></div>   <br/>
    <hr class="hrHeaderClass" />
      <h2 class="CenterMe" >Functions</h2>
    <hr class="hrHeaderClass"/>
    <br/>

    JavaScript functions are objects.  <br/><br/>

    
    <p class="HeadingSubTopic">Regular Functions</p>

    Because regular functions are objects, you can add a property to the function but just doing myFunc.myProp = "hey"<br/>

    <img width="100%" src="assets\images\js\functions1.png" alt="functions 1" /><br/><br/>

    A function that doesn't return something will return undefined.<br/>

    <img width="100%" src="assets\images\js\functions2.png" alt="functions 2" /><br/><br/>

    You can assign anonymous functions to a variable, then call them through that variable.<br/>

    <img width="100%" src="assets\images\js\functions3.png" alt="functions 3" /><br/><br/>

    The "this" keyword from inside the function.<br/>

    <img width="100%" src="assets\images\js\functions4.png" alt="functions 4" /><br/><br/>

    functions can be called before they are declared, because they are hoisted.<br/>

    <img width="100%" src="assets\images\js\functions5.png" alt="functions 5" /><br/><br/>

    A function can return a function.  (see example on scope section)<br/><br/>

    
    <p class="HeadingSubTopic">Arrow Functions</p>

    <img width="100%" src="assets\images\js\arrow1.png" alt="arrow 1" /><br/><br/>

    Arrow functions don't have their own "this" but the one from the parent. <br/>

    <img width="100%" src="assets\images\js\arrow2.png" alt="arrow 2" /><br/><br/>

    Arrow functions don't have the "arguments" keyword.<br/>

    <img width="100%" src="assets\images\js\arrow3.png" alt="arrow 3" /><br/><br/>

    Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.<br/>

    Regular functions created using function declarations or expressions are ‘constructible’ and ‘callable’.  
    Being constructible means they can be used with the keyword “new”.  Arrow functions are not. <br/>

    <img width="100%" src="assets\images\js\arrow4.png" alt="arrow 4" /><br/><br/>


    
    <p class="HeadingSubTopic">Default Parameters</p>

    You should put the default paramenters at the end of the parameters of the function.<br/>

    <img width="100%" src="assets\images\js\defaultparams.png" alt="default params" /><br/><br/>

    
    <p class="HeadingSubTopic">Currying</p>

    We can use this to take advantage of closures.  <br/>

    <img width="100%" src="assets\images\js\currying1.png" alt="currying" /><br/><br/>


    
    <p class="HeadingSubTopic">Function Composition</p>

    Function composition is the process of combining two or more functions to produce a new function.  
    A composable function should have 1 input argument and 1 output value.
    When composing functions, you have to indicate how the composition is going to be.  In math, we are talking about f(g(x)).<br/>

    <pre>
      <code>
        const sum = (n) => n+1;
        const compose = (f,g) => (a) => f(g(a));
        console.log(compose(sum, sum) (5)); --> using the same function twice in the composition.
      </code>
    </pre>
    

    <img width="100%" src="assets\images\js\composition1.png" alt="composition for same function twice" /><br/><br/>

    <pre>
      <code>
        const sum = (n) => n+1;
        const  mult = (n) => n*2;
        const sub = (n) => n -1;
      
        //have one with 2 parameters
        const sub2 = (n, i) => n -1 + i;
        
        const compose = (f,g,x) => (a) => f(g(x(a)));
        
        //sum(mult(sub(2))) = sum(mult(2-1)) = sum(mult(1))=sum(1*2) = sum(2) = 2+1 = 3
        console.log(compose(sum, mult, sub) (2));
        //mult(sum(sub(2))) = mult(sum(2-1))= mult(sum(1))=mult(1+1) = mult(2)= 2*2 = 4
        console.log(compose(mult, sum, sub) (2));<br/>
      
        //compose for 2 parameters
        const compose2 = (f,g,x) => (a, b) => f(g(x(a)), b);
        
        //make sure the second arguments is used with the right
        //func, by composing it on the right location
        //sub2(sum(mult(2)),7) = sub2(sum(2*2),7) = sub2(sum(4),7) =sub2((4+1),7) = sub2(5,7) = 5-1+7 = 11
        console.log(compose2(sub2, sum, mult ) (2, 7));
      </code>
    </pre>
   

    <img width="100%" src="assets\images\js\composition2.png" alt="composition for 3 functions, one with 2 arguments" /><br/><br/>
    
    <p class="HeadingSubTopic">IIFE (IMMIEDIATELY INVOKE FUNCTION EXPRESSION)</p>

    Notice the function being inside () for this:<br/>

    <pre>
      <code>
        (function hey (a)&lbrace;
        console.log(a);
    &rbrace;)("hi");
      </code>
    </pre>
    
    <br/><br/>

    
    <p class="HeadingSubTopic">call, apply, bind</p>

    call will call a function. You can call the function in an object, so it will use the data on another object, not the one with the function.<br/>

    <img width="100%" src="assets\images\js\call.png" alt="call" /><br/><br/>

    If the function takes parameters:<br/>

    <img width="100%" src="assets\images\js\call2.png" alt="call with args" /><br/><br/>

    Apply is similar to call, but for the arguments, we pass an array instead of comma delimmited.<br/>

    <img width="100%" src="assets\images\js\apply.png" alt="apply with args" /><br/><br/>

    Bind is similar to call/ apply but returns a new function without running it.  You cannot give an argument on calling it if you already gave it on binding.<br/>

    <img width="100%" src="assets\images\js\bind.png" alt="bind with args" /><br/><br/>

    You can provide the argument later if you don't provide it on binding:<br/>

    <img width="100%" src="assets\images\js\bind2.png" alt="bind with args 2" /><br/><br/>

    
    <p class="HeadingSubTopic">Higher Order Functions</p>

    In JavaScript functions can take other functions as arguments and they can return a function.  Those functions are called Higher Order Functions.
    Examples of HOF are JS map, filter, reduce etc.<br/><br/>

    
    <p class="HeadingSubTopic">New</p>

    Using the new with regular functions:<br/>
    <img width="100%" src="assets\images\js\functionsnew.png" alt="functins with new" /><br/><br/>



    <!-------------------------------------------------------------->
    <!--Arrays-->
    <!-------------------------------------------------------------->
    <div id="arrays"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe" >Arrays</h2>
    <hr class="hrHeaderClass"/>

    Since functions are objects in JS, an array could contain functions.  Arrays are zero-based.  Ex: var cars = [“Saab”, “Volvo”]’;<br/>

    
    <p class="HeadingSubTopic">forEach</p>

    forEach will go through every element in the array and perform a specific action to each item.
   
    The code inside the foreach will be performed, but look at this:<br/>
    If we have:<br/>
    <pre>
      <code>
        var arr1 = [1,2,3,4,5];
      </code>
    </pre>      
   
    This code will perform the *2 but it won't go anywhere, arr2 will not be arr1*2:<br/>
    <pre>
      <code>
        var arr2 = arr1.forEach( (item) => &lbrace; item *2;&rbrace; )
      </code>
    </pre>
  
    This code returns but the arr3 is not changed either.<br/>
    <pre>
      <code>
        var arr3 = arr1.forEach ( (item) => &lbrace;    
        return item*2;
        &rbrace;)       
      </code>
    </pre>
  
    To get the new arrays to be *2 the arr1:<br/>
    <pre>
      <code>
        var arr4 = [];
        arr1.forEach ((item) => &lbrace; 
          <b>arr4.push(item * 2)    ;</b>
          &rbrace;)
      </code>
    </pre>    
    <br/>
    
    <p class="HeadingSubTopic">Array.prototype</p>

    Sometimes we can have variables that are like arrays but are not arrays. These almost arrays will not have all methods that are available to arrays.  
    One example in older browser is forEach. But, if the structure is like arrays without being an array, we can also use forEach with Array.Prototype.<br/>

    <img width="100%" src="assets\images\js\arrforeach.png" alt="array foreach" /><br/><br/>

    
    <p class="HeadingSubTopic">map</p>
    This code will <mark>NOT</mark> populate the second array with what is expected, but it will create 5 undefined elements:<br/>
    <pre>
      <code>
        var arr1 = [1,2,3,4,5];
        var arr2 = [];

         &nbsp; arr2 = arr1.map ((item) => &lbrace;
         &nbsp;item * 2 ;
        &rbrace;)    
      </code>
    </pre>
   
    Changing the above code to this (adding the return) will populate it:<br/>
    <pre>
      <code>
        arr2 = arr1.map ((item) => &lbrace;
        &nbsp; return item * 2 ;
       &rbrace;)
      </code>
    </pre>  
    Since the code really only has one line, we could do this and it implied the return:<br/>

    <pre>
      <code>
        arr2 = arr1.map ( item => item * 2);
      </code>
    </pre>   

    <br/>
    
    <p class="HeadingSubTopic">filter</p>

    It will return only the items from the array that satisfy a given condition.<br/>
    <pre>
      <code>
        var arr1 = [1,2,3,4,5];
        var arr2 = [];  
  
        arr2 = arr1.filter(item => item>= 3); //will be 3,4,5
      </code>
    </pre>
    

    <br/>
    
    <p class="HeadingSubTopic">reduce</p>


    It reduces the array to a single value.  It uses a reducer function that we create and it applies it to every element on the array.<br/>

    The reducer is super confusing, so here are a few examples because this is easier.  All the example use this array: <br/>
    <pre>
      <code>
        var arr1 = [1,2,3,4];
      </code>
    </pre>
    
    See the image at the end if arrows help you.<br/>
    The below example gives 5 as the original value (used when there is no previous value).<br/>
    <pre>
      <code>
        const reducer = (previousValue, currentValue) => previousValue + currentValue;<br/>
        //5+1 = 6
        //6+2 = 8
        //8+3 = 11
        //11+4=15
        console.log(arr1.reduce(reducer, 5)); --> will print 15
      </code>
    </pre>   

    The next example has no initial value passed to it so the previousValue for the first element will be 0 but still using the same reducer.<br/>
    <pre>
      <code>
        //1+0 = 1
        //2+1=3
        //3+2=6
        //6+4=10
        console.log(arr1.reduce(reducer)); --> will print 10
        console.log("----------------------")
      </code>
    </pre>
    

    The next one uses a different reducer.<br/>
    <pre>
      <code>
        const reducer2 = (previousValue, currentValue) => previousValue * currentValue;
        //2*1=2
        //2*2=4
        //4*3=12
        //12*4=48
        console.log(arr11.reduce(reducer2, 2)); --> will print 48
        console.log("----------------------")
      </code>
    </pre>
    

    The next one has yet a different reducer, with a +1 added to each element.<br/>

    <pre>
      <code>
        const arr12 = [1, 2, 3, 4];
        const reducer3 = (previousValue, currentValue) => (previousValue * currentValue) + 1;
  
        //2*1 + 1 = 3
        //3*2 + 1 = 7
        //7*3 + 1 = 22
        //22 * 4 + 1 = 89 --? will print 89
        console.log(arr11.reduce(reducer3, 2));
      </code>
    </pre>
   
    <br/>

    <img width="100%" src="assets\images\js\reduce1.png" alt="reduce 1" /><br/><br/>

    <img width="100%" src="assets\images\js\reduce2.png" alt="reduce 2" /><br/><br/>

    We can also use reduceRight which is the same thing but it starts from the end.<br/>


    <br/>
    
    <p class="HeadingSubTopic">string to array</p>
    <pre>
      <code>
        let str = "I am a very cool string";<br/>
        var arr = <b>str.split(" ")</b>;<br/>
        console.log(arr); --> [ 'I', 'am', 'a', 'very', 'cool', 'string' ] <br/><br/>
  
        let backtos = <b>arr.toString();</b><br/>
        console.log(backtos); --> I,am,a,very,cool,string<br/><br/>
  
        let str2 = "I am a very cool string";<br/>
        var arr2 = str2.split("a");<br/>
        console.log(arr2); --> [ 'I ', 'm ', ' very cool string' ]<br/>
      </code>
    </pre>
   

    <br/>
    
    <p class="HeadingSubTopic">pop</p>
    <pre>
      <code>
        const arr1 = [1, 2, 3, 4];<br/>
        arr1.pop();<br/>
        console.log(arr1.toString()); //--> 1,2,3<br/>
      </code>
    </pre>   

    <br/>
    
    <p class="HeadingSubTopic">push</p>
    
    <pre>
      <code>
        const arr1 = [1, 2, 3, 4];<br/>
        arr1.push(5);      <br/>
        console.log(arr1.toString());//-->1,2,3,4,5<br/>
      </code>
    </pre>
   

    <br/>
    
    <p class="HeadingSubTopic">unshift</p>
    <pre>
      <code>
        const arr1 = [1, 2, 3, 4];<br/>
        arr1.unshift(0);<br/>
        console.log(arr1.toString());//--> 0,1,2,3,4<br/>
      </code>
    </pre>
  

    <br/>
    
    <p class="HeadingSubTopic">shift</p>
    <pre>
      <code>
        const arr1 = [1, 2, 3, 4];<br/>
        arr1.shift();      <br/>
        console.log(arr1.toString());//-->2,3,4<br/>
      </code>
    </pre>
   


    <br/>
    
    <p class="HeadingSubTopic">delete</p>
    <pre>
      <code>
        const arr1 = [1, 2, 3, 4];<br/>
        delete arr1[0];<br/>
        console.log(arr1);<br/>
        //-->[ <1 empty item>, 2, 3, 4 ] <br/>
      </code>
    </pre>
   

    <br/>
    
    <p class="HeadingSubTopic">slice</p>

    The slice() method returns a shallow copy of a portion of an array into a new array object selected from start to end <b>(end not included) </b>
    where start and end represent the index of items in that array. The original array will not be modified.<br/>
    Like with other methods, you can use it in an array-like variable with Array.prototype.slice.call(arrayLikeVble)<br/>

    <pre>
      <code>
        const arr1 = [1, 2, 3, 4];<br/><br/>

        var arr2 = [];<br/>
        arr2 = arr1.toString();<br/>
        console.log(arr2);//1,2,3,4<br/><br/>
  
        var arr2b = [];<br/>
        arr2b = arr1.slice(2);<br/>
        console.log(arr2b);//[3,4] (to the end)<br/><br/>
  
        var arr2c = [];<br/>
        arr2c = arr1.slice(1,2);<br/>
        console.log(arr2c);//[2]<br/><br/>
  
        const arr1d = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br/>
        var arr2d = [];<br/>
        arr2d = arr1.slice(1,3);<br/>
        console.log(arr2d);//[2,3]<br/>
      </code>
    </pre>
   

    <br/>
    
    <p class="HeadingSubTopic">splice</p>
    It removes a number of elements. <b>It modifies the array and returns a new array too. </b>
	  The first argument is the index where we start removing.<br/>    

    <img width="100%" src="assets\images\js\splice.png" alt="splice" /><br/><br/>

    <img width="100%" src="assets\images\js\splice2.png" alt="splice 2" /><br/><br/>


    <br/>
    
    <p class="HeadingSubTopic">concat</p>
    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,7,8,9];<br/>
        var arr2 = [10];<br/>
        arr1 = arr1.concat(arr2);<br/>
      </code>
    </pre>
   

    <br/>
    
    <p class="HeadingSubTopic">sort</p>
    before the comparison the elements are converted to string, so strings is what's being compared (1,10, 11, 2, is sorted).<br/>
    <pre>
      <code>
        var arr1 = [1, 2, 3, 9,8,7,6,5,4];<br/>
        arr1 = arr1.sort();<br/>
        console.log(arr1);<br/>
      </code>
    </pre>
  
    You can create your own compare function and use it in the sort to get the sort order you want.  The compare function will take a and b arguments and return:<br/>
    &lt; 0 to mean a &lt; b. <br/>
    &gt; 0 to mean a &gt; b. <br/>
    <pre>
      <code>
        var arr1 = [1, 2, 3, 9,8,7,6,5,4, 10, 11, 15, 14, 13];<br/><br/>
        //return &lt; 0 if a &lt; b and &gt; 0 if a &gt; b <br/>
        //will sort 1,2,3,4...<br/>
        function <b>compare</b>(a,b)&lbrace;<br/>
            &nbsp; return a-b;<br/>
        &rbrace;<br/><br/>
        arr1 = arr1.sort(<b>compare</b>);<br/>
        console.log(arr1);<br/>
      </code>
    </pre>      

    <br/>
    
    <p class="HeadingSubTopic">reverse</p>
    reverse the array.
    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,7,8,9];<br/>
        arr1 = arr1.reverse();<br/>
      </code>
    </pre>  

    <br/>
    
    <p class="HeadingSubTopic">filter</p>
    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,7,8,9];<br/>
        var arr2 = [];<br/><br/>
        
        arr2 = arr1.filter( element => element > 4);<br/><br/>
        
        console.log(arr1);//unchanged<br/>
        console.log(arr2);//5,6,7,8,9<br/>
      </code>
    </pre>
   

    <br/>
    
    <p class="HeadingSubTopic">every</p>

    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,7,8,9];<br/>
        var is = arr1.every( element => element > 4);<br/>
        console.log(is);//false<br/>
      </code>
    </pre>
  


    <br/>
    
    <p class="HeadingSubTopic">some</p>

    tests whether some the elements pass a certain condition<br/>
    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,7,8,9];<br/>
        var is = arr1.some( element => element > 4);<br/>
        console.log(is);//true<br/>
      </code>
    </pre>    

    <br/>
    
    <p class="HeadingSubTopic">indexof</p>
    <pre>
      <code>
        var arr1 = ["A", "B", "C", "D","E","F","G","H","I"];<br/>
        var i = arr1.indexOf("C");<br/>
        console.log(i);//2<br/><br/>
  
        //If there are duplicates you can indicate the starting //point where indexOf should be looking.<br/>
        var arr1 = ["A", "B", "C", "D","E","F","G","H","I", "A", "B","C", "D"];<br/><br/>
  
        var i = arr1.indexOf("C", 4);<br/><br/>
  
        console.log(i);//11<br/>
      </code>
    </pre>   

    <br/>
    
    <p class="HeadingSubTopic">lastindexof</p>
    <pre>
      <code>
        var arr1 = ["A", "B", "C", "D","E","F","G","H","I", "A", "B","C", "D"];<br/><br/>

        var i = arr1.lastIndexOf("C");<br/><br/>
  
        console.log(i);//11<br/>
      </code>
    </pre>
  

    <br/>
    
    <p class="HeadingSubTopic">findindex</p>
    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,2,5,4, 7, 8,1, 2];<br/><br/>
        var i = arr1.findIndex(element => element > 3);<br/><br/>
        console.log(i);//3<br/>
      </code>
    </pre>   
    You can pass it a function like here:<br/>

    <br/>
    
    <p class="HeadingSubTopic">find</p>
    Finds the FIRST element that matches:<br/>
    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,2,5,4, 7, 8,1, 2];<br/><br/>

        var i = arr1.find(element => element > 3);<br/><br/>
  
        console.log(i);//4<br/>
      </code>
    </pre>
   
    <img width="100%" src="assets\images\js\findindex.png" alt="findindex" /><br/><br/>


    <br/>
    
    <p class="HeadingSubTopic">includes</p>

    <pre>
      <code>
        var arr1 = [1, 2, 3, 4,5,6,2,5,4, 7, 8,1, 2];<br/><br/>

        var i = arr1.includes(13);<br/><br/>
  
        console.log(i);//false<br/><br/>
  
        var arr1 = [1, 2, 3, 4, 5, 6, 7, 8,1, 2];<br/><br/>
  
        var i = arr1.includes(8,7 );//start at index 7<br/><br/>
        console.log(i);//true<br/>
      </code>
    </pre>
 

    <br/>
    
    <p class="HeadingSubTopic">flat</p>
    <pre>
      <code>
        let ar = [1, [2,3], [4,5,6]]; <br/>
        console.log(ar.flat());//[ 1, 2, 3, 4, 5, 6 ]<br/>
      </code>
    </pre>
   

    <br/>
    
    <p class="HeadingSubTopic">isArray</p>
    <pre>
      <code>
        var b = Array.isArray([1,2,3]);<br/>
        console.log(b);//true
      </code>
    </pre>
  

    <br/>
    
    <p class="HeadingSubTopic">entries</p>
    <pre>
      <code>
        var fruits = ["Banana", "Orange", "Apple", "Mango"];<br/>
        var f = fruits.entries(); <br/>
        for (x of f) &lbrace;<br/>
          &nbsp; console.log(x);<br/>
        &rbrace;<br/>
        //[0, "Banana"]<br/>
        //[1, "Orange"]<br/>
        //[2, "Apple"]<br/>
        //[3, "Mango"]<br/>
      </code>
    </pre>
   

      There is a similar <code><strong><u>keys</u></strong> </code> one.<br/>

      <br/>
      <code><strong><u></u></strong></code><br /><br/>
      <p class="HeadingSubTopic">join</p>
      <pre>
        <code>
          var fruits = ["Banana", "Orange", "Apple", "Mango"];<br/>
          console.log(fruits.join())//Banana,Orange,Apple,Mango<br/><br/>
          
          var fruits = ["Banana", "Orange", "Apple", "Mango"];<br/>
          console.log(fruits.join('-'))//Banana-Orange-Apple-Mango<br/>
        </code>
      </pre>    
     
      There are other array methods not included here.  This includes the most common ones.


    <!-------------------------------------------------------------->
    <!--this-->
    <!-------------------------------------------------------------->
    <div id="this"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe" >This</h2>
    <hr class="hrHeaderClass"/>

    In most cases, the value of this is determined by how a function is called (runtime).  That means it may be different each 
    time the function is called.<br/>

    We can use bind() to set the value of this, regardless of how the function is called.<br/>

    Arrow function do not provide their own this value.  They have the one of the closest non arrow function parent. <br/>

    Outside of functions, this refers to the global object (window, global).  To get this, you can always use globalThis, both in JS and node.<br/>

    <b>Inside a function, the value of this depends on how the function is called.</b><br/><br/>
    Again.  <b>Inside a function, the value of this depends on how the function is called.</b><br/> <br/>

    In a function that doesn't set this to anything else, this will be the global object.<br/>
    <pre>
      <code>
        function f1() &lbrace;<br/>
        &nbsp; console.log(this);<br/>
       &rbrace;<br/><br/>
       
       f1()<br/>
      </code>
    </pre>
   
    <br/>

    In strict mode, the value will be undefined.<br/>
    <pre>
      <code>
        "use strict"<br/>
        function f1() &lbrke;<br/>
          &nbsp; console.log(this);<br/>
        &rbrace;<br/><br/>
  
        f1()<br/>
      </code>
    </pre>
   
    To set the value of this to a particular value when calling a function, use call(), or apply() (you can check them out under functions)<br/>

    In a class, this will refer to the class itself (regular function or arrow functions).<br/>

    <img width="100%" src="assets\images\js\this1.png" alt="this 1" /><br/><br/>

    Derived constructors have no initial this binding, so super should be called before accessing this.<br/>

    <img width="100%" src="assets\images\js\this2.png" alt="this 2" /><br/><br/>

    Not calling super will give an error:

    <img width="100%" src="assets\images\js\this3.png" alt="this 3" /><br/><br/>

    You can change the this in a call by using call (or apply) to call it:<br/>

    <img width="100%" src="assets\images\js\this4.png" alt="this 4" /><br/><br/>

    Bind is similar to call/ apply but returns a new function without running it. See it under JavaScript-Basics-Functions<br/>
    In arrow functions, this retains the value of the enclosing lexical context's this (see arrow functions).<br/>

    When there are object inside object, the this will refer to the closest one to how the function is called.<br/>

    <img width="100%" src="assets\images\js\this5.png" alt="this 5" /><br/><br/>

    For even more examples please check the documentation (MDN docs). <br/>


    <!-------------------------------------------------------------->
    <!--misc-->
    <!-------------------------------------------------------------->
    <div id="misc"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe" >Misc.</h2>
    <hr class="hrHeaderClass"/>

    
    <p class="HeadingSubTopic">Loop through properties</p>
    <pre>
      <code>
        for (var prop in obj) &lbrace;<br/>
        &nbsp; if (Object.prototype.hasOwnProperty.call(obj, prop)) &lbrace;<br/>
        &nbsp;&nbsp;// do stuff<br/>
         &rbrace;<br/>
       &rbrace;<br/>   
      </code>
    </pre>
   
  <br/>
    
    <p class="HeadingSubTopic">Compare</p>

    === will not do type coertion while == does.  So, 1 == "1" is true, but 1 === "1" is false.<br/>

    
    <p class="HeadingSubTopic">Strings</p>

    console.log(&grave;King of Pop? That is $&lbrace;name&rbrace; $&lbrace;lastn&rbrace;.&grave; );<br/>

    
    <p class="HeadingSubTopic">Symbol</p>

    JS has a new symbol type.  The particular thing about them is that they are always unique even if they are created with the same values.   <br/>


    
    <p class="HeadingSubTopic">arguments</p>
    <pre>
      <code>
        function hey (a,b,c)&lbrace;<br/>
        &nbsp;  console.log(arguments);<br/>
      &rbrace;<br/>
      hey(1,2,3);//[Arguments] &lbrace; '0': 1, '1': 2, '2': 3 &rbrace;<br/>
      </code>
    </pre>
  


    <br/>
    <pre>
      <code>
        function hey (...args)&lbrace;<br/>
        &nbsp;  console.log(arguments);  <br/>
    &rbrace;    <br/>
    hey(1,2,3, 4);//[Arguments] &lbrace; '0': 1, '1': 2, '2': 3, '3': 4 &rbrace;<br/>
      </code>
    </pre>
   
    <br/>

    
    <p class="HeadingSubTopic">undefined - null</p>

    they are not the same thing.  Null is a value, null.  Undefined is something else.

    <br/>
    
    <p class="HeadingSubTopic">==, ===, Object.is</p>

    console.log("1" == 1);//true<br/>
    console.log("1" === 1);//false<br/>
    console.log(+0 === -0);//true<br/>
    console.log(Object.is(+0, -0));//false<br/>
    <br/>

    
    <p class="HeadingSubTopic">coalesce</p>

    let somevar = avar ?? “hello”;   &nbsp;  &nbsp; ==> Set the somevar to avar unless that is null or undefined, in that case, set it to “hello”<br/>


    
    <p class="HeadingSubTopic">destructuring</p>

    <pre>
      <code>
        let obj1 = &lbrace;name:"Noel", age:32, phone:"555"&rbrace;;<br/>
        const &lbrace;name, age, ext&rbrace; = obj1;<br/>
        console.log(name) //Noel<br/>
      </code>
    </pre>
  
<br/>
<pre>
  <code>
    let obj1 = &lbrace;name:"Noel", age:32, phone:"555"&rbrace;;<br/>
    const  &lbrace;name:username, age:userage, ext:userextension&rbrace; = obj1;<br/>
    const  &lbrace;age:userage2, name:username2, ext:userextension2&rbrace; = obj1;<br/><br/>

    console.log(username);//Noel<br/>
    console.log(username2);//Noel<br/>
    console.log(name);//name is not defined<br/>
  </code>
</pre>
 
<br/>
<pre>
  <code>
    let [a,b] = [1,2,3,4];<br/>
    let [aa,bb,,,cc]= [1,2,3,4,5];//it knows where to put them<br/><br/>
    
    let aaa = 1; let bbb = 2;<br/>
    [aaa,bbb] = [bbb,aaa]//switch values<br/><br/>
    
    console.log(a);//1 <br/>
    console.log(b);//2<br/><br/>
    
    console.log(aa);//1<br/>
    console.log(bb);//2<br/>
    console.log(cc);//5<br/><br/>
    
    console.log(aaa);//2<br/>
    console.log(bbb);//1<br/>
  </code>
</pre>

<br/>
<pre>
  <code>
    let [a,b,...arr] = [1,2,3,4,5,6];<br/><br/>

    console.log(a);//1<br/>
    console.log(b);//2<br/>
    console.log(arr[0]);//3<br/>
    console.log(arr[1]);//4<br/>
    console.log(arr[2]);//5<br/>
    console.log(arr[3]);//6<br/>
    console.log(arr[4]);//undefined<br/>
  </code>
</pre>

<br/>
… can also be used to copy an array: […arr]  You can also use it combined:
let sentence =  ["learning", ...fragment, "is"];
<br/>
<br/>

<p class="HeadingSubTopic">callback func</p>
<pre>
  <code>
    Array.prototype.myMap = function(<b>callback</b>) &lbrace;<br/>
    var newArray = [];<br/>
    // Only change code below this line<br/>
    for (let i = 0; i < this.length; i++)&lbrace;<br/>
    &nbsp;  newArray.push(<b>callback(this[i])</b>);<br/>
    &rbrace;<br/>
    // Only change code above this line<br/>
    return newArray;<br/>
    &rbrace;;<br/>
  </code>
</pre>





  </div>



</div> 
