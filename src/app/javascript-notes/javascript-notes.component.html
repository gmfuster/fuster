
<div class="PaddedContents">

  <br/>
  <h2 class="CenterMe">JavaScript notes - Basics</h2>  
  <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
  <h4 class="CenterMe">You can type the JavaScript code  
    <a class="CenterMe" href="https://replit.com/languages/nodejs" target="_new">on replit.com</a> 
    to see how it works (it is nodejs but you can also choose JavaScript): <br/>
 
  </h4>

  <br/>

  <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
    <p>
      <a  href="/javascript-notes/#scope">Scope</a>
    <p>
    <p>
      <a  href="/javascript-notes/#functions">functions</a>
    </p>
    <p>
      <a  href="/javascript-notes/#arrays">Arrays</a>
    </p>
  </div>
  
  <div class="PaddedContents">

    <!-------------------------------------------------------------->
    <!--SCOPE-->
    <!-------------------------------------------------------------->
    <div id="scope"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe" >Scope</h2>
    <hr class="hrHeaderClass"/>

    <code><strong><u>Scope - variables</u></strong></code><br />
    There are two types of scope in JavaScript: Global and Local.  You get global scope when you declare a variable outside of a block, or outside of 
    a function.  Global scope on the browsert is the "window".<br/>
    We can declare variables with var, let, const.  LET and CONST are the same as far as scope is concerned.  Using "var"<br/><br/>

    <img width="100%" src="assets\images\js\varscope1.png" alt="var scope" /><br/><br/>

    Similar code, but now we use LET which has block scope<br/><br/>

    <img width="100%" src="assets\images\js\letscope1.png" alt="let scope" /><br/><br/>

    How about if you use var, outside a function and inside a function (we already know there is no block scope)<br/><br/>

    <img width="100%" src="assets\images\js\varscope2.png" alt="var scope outide func" /><br/><br/>

    When working with JavaScript, 
    make sure you declare the variables before you use them because if you forget to declare a variable and just assign it, you will be creating global variables. 
    HOWEVER, you can stop that by declaring the code with "use strict"<br/>
    <img width="100%" src="assets\images\js\globalbymistake.png" alt="global by  mistake" /><br/><br/>

    Parameters passed to functions act as local variables to the function.

    
    <hr class="hrClass" />

    <code><strong><u>Scope - Hoisting</u></strong></code><br />

    Hoisting means JavaScript moving variables or function declarations to the top of their context. 
    This means that in JavaScript, functions and variables can be accessed before they have been declared.<br/>
    Variables declared with var, are accessible before they are declared, variables declared with let (or const) are not. See the differences here:<br/><br/>

    <img width="100%" src="assets\images\js\assignthendeclare.png" alt="assign then declare" /><br/><br/>
   
    JavaScript hoists the declarations but not the initializations.  That means, printing a variable to the console before it has been assigned will print undefined.

    <br/>

    <hr class="hrClass" />

    <code><strong><u>Scope - Closures</u></strong></code><br />

    JavaScript allows for functions inside functions (nested functions). 
    When a function is defined within another function, the inner function has access to the variable scope of the outer function. 
    This is what function closures are.

    <img width="100%" src="assets\images\js\closures1.png" alt="closures 1" /><br/><br/>

    The inner function has access to the parent function at the time of creation, not only while the parent function is running.  This will also work:<br/><br/>

    <img width="100%" src="assets\images\js\closures2.png" alt="closures 2" /><br/><br/>


    <!-------------------------------------------------------------->
    <!--FUNCTIONS-->
    <!--------------------------------------------------------------> 
    <div id="functions"></div>   <br/>
    <hr class="hrHeaderClass" />
      <h2 class="CenterMe" >Functions</h2>
    <hr class="hrHeaderClass"/>
    <br/>

    JavaScript functions are objects.  <br/><br/>

    <code><strong><u>Regular Functions</u></strong></code><br /><br/>

    Because regular functions are objects, you can add a property to the function but just doing myFunc.myProp = "hey"<br/>

    <img width="100%" src="assets\images\js\functions1.png" alt="functions 1" /><br/><br/>

    A function that doesn't return something will return undefined.<br/>

    <img width="100%" src="assets\images\js\functions2.png" alt="functions 2" /><br/><br/>

    You can assign anonymous functions to a variable, then call them through that variable.<br/>

    <img width="100%" src="assets\images\js\functions3.png" alt="functions 3" /><br/><br/>

    The "this" keyword from inside the function.<br/>

    <img width="100%" src="assets\images\js\functions4.png" alt="functions 4" /><br/><br/>

    functions can be called before they are declared, because they are hoisted.<br/>

    <img width="100%" src="assets\images\js\functions5.png" alt="functions 5" /><br/><br/>

    A function can return a function.  (see example on scope section)<br/><br/>

    <code><strong><u>Arrow Functions</u></strong></code><br /><br/>

    <img width="100%" src="assets\images\js\arrow1.png" alt="arrow 1" /><br/><br/>

    Arrow functions don't have their own "this" but the one from the parent. <br/>

    <img width="100%" src="assets\images\js\arrow2.png" alt="arrow 2" /><br/><br/>

    Arrow functions don't have the "arguments" keyword.<br/>

    <img width="100%" src="assets\images\js\arrow3.png" alt="arrow 3" /><br/><br/>

    Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.<br/>

    Regular functions created using function declarations or expressions are ‘constructible’ and ‘callable’.  
    Being constructible means they can be used with the keyword “new”.  Arrow functions are not. <br/>

    <img width="100%" src="assets\images\js\arrow4.png" alt="arrow 4" /><br/><br/>



    <code><strong><u>Default Parameters</u></strong></code><br /><br/>

    You should put the default paramenters at the end of the parameters of the function.<br/>

    <img width="100%" src="assets\images\js\defaultparams.png" alt="default params" /><br/><br/>

    <code><strong><u>Currying</u></strong></code><br /><br/>

    We can use this to take advantage of closures.  <br/>

    <img width="100%" src="assets\images\js\currying1.png" alt="currying" /><br/><br/>




    <code><strong><u>Function Composition</u></strong></code><br /><br/>

    Function composition is the process of combining two or more functions to produce a new function.  
    A composable function should have 1 input argument and 1 output value.
    When composing functions, you have to indicate how the composition is going to be.  In math, we are talking about f(g(x)).<br/>

    <div class="codeBlock">
      const sum = (n) => n+1;<br/>
      const compose = (f,g) => (a) => f(g(a));<br/>
      console.log(compose(sum, sum) (5)); --> using the same function twice in the composition.<br/>
    </div>

    <img width="100%" src="assets\images\js\composition1.png" alt="composition for same function twice" /><br/><br/>

    <div class="codeBlock">
      const sum = (n) => n+1;<br/>
      const  mult = (n) => n*2;<br/>
      const sub = (n) => n -1;<br/>
    
      //have one with 2 parameters<br/>
      const sub2 = (n, i) => n -1 + i;<br/>
      
      const compose = (f,g,x) => (a) => f(g(x(a)));<br/>
      
      //sum(mult(sub(2))) = sum(mult(2-1)) = sum(mult(1))=sum(1*2) = sum(2) = 2+1 = 3<br/>
      console.log(compose(sum, mult, sub) (2));<br/>
      //mult(sum(sub(2))) = mult(sum(2-1))= mult(sum(1))=mult(1+1) = mult(2)= 2*2 = 4<br/>
      console.log(compose(mult, sum, sub) (2));<br/>
    
      //compose for 2 parameters<br/>
      const compose2 = (f,g,x) => (a, b) => f(g(x(a)), b);<br/>
      
      //make sure the second arguments is used with the right<br/>
      //func, by composing it on the right location<br/>
      //sub2(sum(mult(2)),7) = sub2(sum(2*2),7) = sub2(sum(4),7) =sub2((4+1),7) = sub2(5,7) = 5-1+7 = 11<br/>
      console.log(compose2(sub2, sum, mult ) (2, 7));<br/>
    </div>  

    <img width="100%" src="assets\images\js\composition2.png" alt="composition for 3 functions, one with 2 arguments" /><br/><br/>

    <code><strong><u>IIFE (IMMIEDIATELY INVOKE FUNCTION EXPRESSION)</u></strong></code><br /><br/>

    Notice the function being inside () for this:<br/>

    <div class="codeBlock">
      (function hey (a)&lbrace;<br/>
        console.log(a);<br/>
    &rbrace;)("hi");<br/>        
    </div>
    <br/><br/>


    <code><strong><u>call, apply, bind</u></strong></code><br /><br/>

    call will call a function. You can call the function in an object, so it will use the data on another object, not the one with the function.<br/>

    <img width="100%" src="assets\images\js\call.png" alt="call" /><br/><br/>

    If the function takes parameters:<br/>

    <img width="100%" src="assets\images\js\call2.png" alt="call with args" /><br/><br/>

    Apply is similar to call, but for the arguments, we pass an array instead of comma delimmited.<br/>

    <img width="100%" src="assets\images\js\apply.png" alt="apply with args" /><br/><br/>

    Bind is similar to call/ apply but returns a new function without running it.  You cannot give an argument on calling it if you already gave it on binding.<br/>

    <img width="100%" src="assets\images\js\bind.png" alt="bind with args" /><br/><br/>

    You can provide the argument later if you don't provide it on binding:<br/>

    <img width="100%" src="assets\images\js\bind2.png" alt="bind with args 2" /><br/><br/>

    <code><strong><u>Higher Order Functions</u></strong></code><br /><br/>

    In JavaScript functions can take other functions as arguments and they can return a function.  Those functions are called Higher Order Functions.
    Examples of HOF are JS map, filter, reduce etc.<br/><br/>

    <code><strong><u>New</u></strong></code><br /><br/>

    Using the new with regular functions:<br/>
    <img width="100%" src="assets\images\js\functionsnew.png" alt="functins with new" /><br/><br/>



    <!-------------------------------------------------------------->
    <!--Arrays-->
    <!-------------------------------------------------------------->
    <div id="arrays"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe" >Arrays</h2>
    <hr class="hrHeaderClass"/>

    Since functions are objects in JS, an array could contain functions.  Arrays are zero-based.  Ex: var cars = [“Saab”, “Volvo”]’;<br/>

    <code><strong><u>forEach</u></strong></code><br /><br/>

    forEach will go through every element in the array and perform a specific action to each item.
   
    The code inside the foreach will be performed, but look at this:<br/>
    If we have:<br/>
    <div class="codeBlock">
      var arr1 = [1,2,3,4,5];
    </div>
    This code will perform the *2 but it won't go anywhere, arr2 will not be arr1*2:<br/>
    <div class="codeBlock">
      var arr2 = arr1.forEach( (item) => &lbrace; item *2;&rbrace; )<br/>    
    </div>
    This code returns but the arr3 is not changed either.<br/>
    <div class="codeBlock">
      var arr3 = arr1.forEach ( (item) => &lbrace;     <br/>
        return item*2;<br/>
        &rbrace;)    <br/>       
    </div>
    To get the new arrays to be *2 the arr1:<br/>
    <div class="codeBlock">
    var arr4 = [];<br/>
    arr1.forEach ((item) => &lbrace; <br/>
      <b>arr4.push(item * 2)    ;</b><br/>
    &rbrace;)<br/>   
    </div>  
    <br/>
    <code><strong><u>Array.prototype</u></strong></code><br /><br/>

    Sometimes we can have variables that are like arrays but are not arrays. These almost arrays will not have all methods that are available to arrays.  
    One example in older browser is forEach. But, if the structure is like arrays without being an array, we can also use forEach with Array.Prototype.<br/>

    <img width="100%" src="assets\images\js\arrforeach.png" alt="array foreach" /><br/><br/>


    <code><strong><u>map</u></strong></code><br /><br/>
    This code will <mark>NOT</mark> populate the second array with what is expected, but it will create 5 undefined elements:<br/>
    <div class="codeBlock">
        var arr1 = [1,2,3,4,5];<br/>
        var arr2 = [];<br/>

         &nbsp; arr2 = arr1.map ((item) => &lbrace;<br/>
         &nbsp;item * 2 ;<br/>
        &rbrace;)    <br/>
    </div>
    Changing the above code to this (adding the return) will populate it:<br/>
    <div class="codeBlock">
      arr2 = arr1.map ((item) => &lbrace;<br/> 
      &nbsp; return item * 2 ;<br/>
     &rbrace;)<br/>
    </div>  
    Since the code really only has one line, we could do this and it implied the return:<br/>
    <div class="codeBlock">
      arr2 = arr1.map ( item => item * 2);
    </div>

    <br/>
    <code><strong><u>filter</u></strong></code><br /><br/>

    It will return only the items from the array that satisfy a given condition.<br/>
    <div class="codeBlock">
      var arr1 = [1,2,3,4,5];<br/>
      var arr2 = [];  <br/>

      arr2 = arr1.filter(item => item>= 3); //will be 3,4,5<br/>
    </div>

    <br/>
    <code><strong><u>reduce</u></strong></code><br /><br/>


    It reduces the array to a single value.  It uses a reducer function that we create and it applies it to every element on the array.<br/>

    The reducer is super confusing, so here are a few examples because this is easier.  All the example use this array: <br/>
    <div class="codeBlock">
      var arr1 = [1,2,3,4];
    </div>

    See the image at the end if arrows help you.<br/>
    The below example gives 5 as the original value (used when there is no previous value).<br/>
    <div class="codeBlock">
      <br/>
      const reducer = (previousValue, currentValue) => previousValue + currentValue;<br/><br/>
      //5+1 = 6<br/>
      //6+2 = 8<br/>
      //8+3 = 11<br/>
      //11+4=15<br/>
      console.log(arr1.reduce(reducer, 5)); --> will print 15<br/>
    </div>

    The next example has no initial value passed to it so the previousValue for the first element will be 0 but still using the same reducer.<br/>

    <div class="codeBlock">
    //1+0 = 1<br/>
    //2+1=3<br/>
    //3+2=6<br/>
    //6+4=10<br/>
    console.log(arr1.reduce(reducer)); --> will print 10<br/>
    console.log("----------------------")<br/>
    </div>  

    The next one uses a different reducer.<br/>
    <div class="codeBlock">
      const reducer2 = (previousValue, currentValue) => previousValue * currentValue;<br/>
      //2*1=2<br/>
      //2*2=4<br/>
      //4*3=12<br/>
      //12*4=48<br/>
      console.log(arr11.reduce(reducer2, 2)); --> will print 48<br/>
      console.log("----------------------")<br/>
    </div>  

    The next one has yet a different reducer, with a +1 added to each element.<br/>

    <div class="codeBlock">
      const arr12 = [1, 2, 3, 4];<br/>
      const reducer3 = (previousValue, currentValue) => (previousValue * currentValue) + 1;<br/>

      //2*1 + 1 = 3<br/>
      //3*2 + 1 = 7<br/>
      //7*3 + 1 = 22<br/>
      //22 * 4 + 1 = 89 --? will print 89<br/>      
      console.log(arr11.reduce(reducer3, 2));
    </div>
    <br/>

    <img width="100%" src="assets\images\js\reduce1.png" alt="reduce 1" /><br/><br/>

    <img width="100%" src="assets\images\js\reduce2.png" alt="reduce 2" /><br/><br/>

    We can also use reduceRight which is the same thing but it starts from the end.<br/>





  </div>



</div> 
