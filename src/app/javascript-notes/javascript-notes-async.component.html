<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">JavaScript notes - Async</h2>       
    <h4 class="CenterMe">You can type the JavaScript code  
      <a class="CenterMe" href="https://replit.com/languages/nodejs" target="_new">on replit.com</a> 
      to see how it works (it is nodejs but you can also choose JavaScript): <br/>   
    </h4>
  
    <br/>
  
    <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
      <p>
        <a  href="/javascript-notes-async/#promises">Promises</a>
      <p>        
        <a  href="/javascript-notes-async/#catch">Catch-Finally</a>      
      </p>       
      <p>        
        <a  href="/javascript-notes-async/#chains">Chains</a>      
      </p>  
      <p>
        <a  href="/javascript-notes-async/#static">Static func.</a>
      </p>
      <p>
        <a  href="/javascript-notes-async/#await">Await</a>
      </p>
    </div>
    
    <div class="PaddedContents">
  
      <!-------------------------------------------------------------->
      <!--Promises-->
      <!-------------------------------------------------------------->
      <div id="promises"></div><br/>
      <hr class="hrHeaderClass" />
          <h2 class="CenterMe">Promises</h2>
      <hr class="hrHeaderClass"/>
  
      <code><strong><u>Basics</u></strong></code><br />
      Promises are objects.<br/>
      The promise object returns properties: <b>state</b> (pending, fulfilled, rejected), <b>result</b> (undefined, value, error).<br/>
      A promise that is fulfilled or rejected is settled.<br/>

      <div class="codeBlock">
        let myPromise = new Promise ( function(resolve, reject)<br/>
        &lbrace;<br/>
          console.log("About to call func with setTimeOut");<br/>
          setTimeout(<br/>
            &nbsp;() => &lbrace;<br/>
            &nbsp;&nbsp;console.log("Sending a resolve");<br/>
            &nbsp;&nbsp;resolve("RESOLVED!!!");<br/>
            &rbrace;, 3000)<br/>
          console.log("Waiting for setTimeout to finish...");  <br/>
        &rbrace;);<br/><br/>
        
        let consumePromise = () => &lbrace;<br/>
        &nbsp; myPromise.then( <br/>
        &nbsp;&nbsp;(resolve) => console.log(resolve) );<br/>
        &rbrace;<br/><br/>
        
        consumePromise();<br/>
      </div>


  
    <img width="100%" src="assets\images\js\promise1.png" alt="promise 1" /><br/><br/>

      The above example only has code for the resolve, if we wanted to have somewhere in the code to send the reject, it would look something like <br/>
      <div class="codeBlock">
          reject( new Error("Rejected!!!"));
      </div>    
      and then in the code inside the then() you do 
      <div class="codeBlock">
        myPromise.then( <br/>
        (resolve) => console.log(resolve) ;<br/>
        (reject) => console.log(reject) )<br/>
    </div>
    We could also do this.  Notice if the promise doesn't return a resolve, just use null in its place, don't just ignore it and leave it out.<br/>
    <div class="codeBlock">
        let myPromise = new Promise ( function(resolve, reject)<br/>
        &lbrace;<br/>
            &nbsp;console.log("About to call func with setTimeOut");<br/>
            &nbsp;setTimeout(<br/>
                &nbsp;() => &lbrace;<br/>
                    &nbsp;&nbsp;   console.log("Sending a reject");<br/>
                    &nbsp;&nbsp; reject(new Error("REJECTED!!!"));<br/>
                    &nbsp;&rbrace;, 3000)<br/>
                    &nbsp;console.log("Waiting for setTimeout to finish...");  <br/>
        &rbrace;);<br/><br/>

        let consumePromise = () => &lbrace;<br/>
            &nbsp; myPromise.then( <br/>
                &nbsp;&nbsp;  (null),<br/>
                &nbsp;&nbsp; (reject) => console.log(reject));<br/>
        &rbrace;
        <br/><br/>
        consumePromise();<br/>
    </div><br/>
    <img width="100%" src="assets\images\js\promise2.png" alt="promise 2" /><br/><br/>
    The consumePromise doesn't have to name (resolve) and (reject) that way, you can name it whatever. Changing that part of the code to this also works:
    <div class="codeBlock">
        let consumePromise = () => &lbrace;<br/>
        &nbsp; myPromise.then( <br/>
        &nbsp; &nbsp; (null),<br/>
        &nbsp; &nbsp; (rejectOHNO) => console.log(rejectOHNO));<br/>
          &rbrace;<br/>
    </div><br/>
    If instead of reject(new Error("REJECTED!!!") we do reject("REJECTED!!!"); it will still go to the reject but it won't display as an error, but as a string.<br/>

    <!-------------------------------------------------------------->
    <!--catch finally-->
    <!-------------------------------------------------------------->
    <div id="catch"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Catch-Finally</h2>
    <hr class="hrHeaderClass"/>

    <code><strong><u>catch</u></strong></code><br />

    We could also be catching an error this way:<br/>
    <div class="codeBlock">
        let consumePromise = () => &lbrace;<br/>
           &nbsp; myPromise.catch(<br/>
           &nbsp;&nbsp;(errorOHNO) => &lbrace;console.log(errorOHNO);&rbrace;<br/>
           &nbsp;)<br/>
          &rbrace;<br/>
    </div>
    <br/>
    The catch will happen even if we don't send an Error, so having only reject( "REJECTED OH NO!"); will still go to the catch block.<br/>
    If we have both the reject and the catch, the catch will not happen:<br/>
    <div class="codeBlock">
        let consumePromise = () => &lbrace;<br/>
        &nbsp;myPromise.then(<br/>
        &nbsp; &nbsp; (resolve) => console.log("hello"),<br/>
        &nbsp; &nbsp; (reject) => console.log("OH no!!" + reject)<br/>
        &nbsp;  ).catch(<br/>
        &nbsp; &nbsp;    (errorOHNO) => &lbrace;console.log("IN CATCH");&rbrace;<br/>
        &nbsp;  )<br/>
          &rbrace;<br/>
    </div>
    <br/>
    <img width="100%" src="assets\images\js\promise3.png" alt="promise 3" /><br/><br/>

    <code><strong><u>finally</u></strong></code><br />
    Finally always happen, no matter resolve or reject.<br/>
    <div class="codeBlock">
        let consumePromise = () => &lbrace;<br/>
        &nbsp; myPromise.then(<br/>
        &nbsp; &nbsp;  (resolve) => console.log("hello"),<br/>
        &nbsp; &nbsp;  (reject) => console.log("OH no!!" + reject)<br/>
        &nbsp; ).catch(<br/>
        &nbsp; &nbsp;    (errorOHNO) => &lbrace;console.log("IN CATCH");&rbrace;<br/>
        &nbsp;  ).finally(<br/>
        &nbsp; &nbsp;     console.log("FINALLY!")<br/>
        &nbsp;   )<br/>                    
    </div>
    But look what that prints:
    <div class="codeBlock">
        About to call func with setTimeOut<br/>
        Waiting for setTimeout to finish...<br/>
        <b>FINALLY!</b><br/>
        Hint: hit control+c anytime to enter REPL.<br/>
        Sending a reject<br/>
        OH no!!Error: rejected!!!<br/>
    </div>  


    <!-------------------------------------------------------------->
    <!--chains-->
    <!-------------------------------------------------------------->
    <div id="chains"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Chains</h2>
    <hr class="hrHeaderClass"/>

    We can have then after then, such as then(...).then(...) etc. However, the resolve from the myPromise will only make it to the first then.
    If than then doesn't return it, the following thens will not have it:

    <img width="100%" src="assets\images\js\promisechain.png" alt="promise chain" /><br/><br/>
    <br/>
    But if the previous then returns, then:<br/>
    <img width="100%" src="assets\images\js\promisechain2.png" alt="promise chain 2" /><br/><br/>

    If we had more than one promise (let myPromise = new Promise), the then() can return one of the additional promises instead of just returning a string or whatever.<br/>




    <!-------------------------------------------------------------->
    <!--static functions-->
    <!-------------------------------------------------------------->
    <div id="static"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Static functions</h2>
    <hr class="hrHeaderClass"/>

    JS has some static functions to deal with promises. This is just a brief summary.<br/>

    <code><strong><u>all</u></strong></code><br />
    <div class="codeBlock">
        Promise.all([myPromise1, myPromise2]).then(<br/>
            (values) => console.log("ALL DONE with " + values)<br/>
          )<br/>
    </div>  <br/>

    <img width="100%" src="assets\images\js\promise_all.png" alt="promise all" /><br/><br/>
    It is a good idea to have a catch with the Promise.all in case one of the promises fails.<br/>

    <code><strong><u>allsettled</u></strong></code><br />
    This will have the then happen, regardless of resolve or reject.  And values will have the status and result of the promises.

    <code><strong><u>any</u></strong></code><br />

    Promise.any[ list of promises] will wait for just one to finish.  Once that happens, the others are ignored.<br/>

    <code><strong><u>race</u></strong></code><br />

    Will happen with whatever promise finishes first, it doesn't matter if with resolve or reject.<br/>

    <code><strong><u>resolve</u></strong></code><br />
    the resolve will call the first function in the arguments.
    <div class="codeBlock">
        Promise.resolve("YAY").then(<br />
         &nbsp;   ()=>console.log("pretend I'm a func called 4 resolve"),<br />
         &nbsp;   ()=>console.log("pretend I'm a func called 4 reject")<br />
          )<br />
    </div>  <br/>

    <img width="100%" src="assets\images\js\resolve.png" alt="resolve" /><br/><br/>


    <code><strong><u>reject</u></strong></code><br />
    similar to the resolve but it goes to the second function provided, the reject one.<br/>

    <div class="codeBlock">
        Promise.reject( new Error("Oops")).then(<br/>
        &nbsp;  ()=>console.log("pretend I'm a func called 4 resolve"),<br/>
        &nbsp;  ()=>console.log("pretend I'm a func called 4 reject")<br/>
)
    </div>


    <!-------------------------------------------------------------->
    <!--Await-->
    <!-------------------------------------------------------------->
    <div id="await"></div><br/>
    <hr class="hrHeaderClass" />
        <h2 class="CenterMe">Await</h2>
    <hr class="hrHeaderClass"/>

    AWAIT is used to wait for a promise or a value if what we return is not a promise, but it will be turned into a promise.  
    <b>AWAIT has to be called inside a async function.</b><br/>
    If the Promise bein awaited is rejected, the await expression throws the rejected value.<br/>
    <b>The await will wait for the promise it got to be resolved.</b>  If we return a value right away, it will not be waiting.  If the called
    function waits and then returns something, the await will have moved on.  It expects a promise, then it waits for it to finish.  It doesn't wait 
    for the promise to be returned after a while.

    <div class="codeBlock">
        function callMe()&lbrace;
           &nbsp; console.log("returning promise with timeout");<br/>
           &nbsp; return new Promise(function (resolve,reject) &lbrace;<br/>
           &nbsp;&nbsp;   setTimeout(() => &lbrace;<br/>
           &nbsp;&nbsp;     resolve(9);<br/>
           &nbsp;   &rbrace;, 3000);<br/>
           &nbsp;  &rbrace;);<br/>
          &rbrace;<br/>
          
          async function iCallWait()&lbrace;<br/>
          &nbsp;   let vble = await callMe()  ;  <br/>
          &nbsp;   console.log("Hello, I got " + vble);<br/>
          &nbsp;  &rbrace;<br/>
          
          iCallWait()<br/>
    </div><br/>
    <img width="100%" src="assets\images\js\await1.png" alt="await 1" /><br/><br/>

    If the promise can reject, do a try-catch:<br/>

    <div class="codeBlock">
        async function iCallWait()&lbrace;<br/>
        &nbsp; try&lbrace;<br/>
        &nbsp; &nbsp;  let vble = await callMe()  ;  <br/>  
        &nbsp; &nbsp;  console.log("Hello, I got " + vble);<br/>
        &nbsp; &nbsp;   &rbrace;catch&lbrace;<br/>
        &nbsp;     console.log("oh no");<br/>
            &rbrace;  <br/>          
    </div><br/>
    Could also do this but less clear: <code><strong><u>var response = await callMe().catch((err) => &lbrace; console.error(err); &rbrace;);</u></strong></code><br/><br/>
    You can also do: <code><strong><u>let response = await fetch(url); </u></strong></code> (in async function, try in browser's console, Calling fetch () returns a promise)<br/><br/>
    If we call a function with await that just waits and then returns something, the wait will not wait (see explanation at top of section):<br/><br/>
    <div class="codeBlock">
        function callMe()&lbrace;<br/> 
        &nbsp;setTimeout(() => &lbrace;<br/> 
        &nbsp;&nbsp;  return 9;<br/> 
        &nbsp;  &rbrace;, 3000);  <br/> 
        &rbrace;
    </div>












    </div>    
</div>
    