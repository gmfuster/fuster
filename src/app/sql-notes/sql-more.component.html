<div class="PaddedContents ">    

<div >

    <br/>
    <h2 class="CenterMe">SQL notes - More</h2>      
    <div class="TopLinks" #HeadingsContainer>      
        <top-links ></top-links>      
      </div>  
      <br/>
            
        <p class="HeadingSubTopic" id="WITH" HeadingSubTopicDir>WITH Keyword (CTEs:Common Table Expressions)</p>

        <pre>
            
            WITH MyQuery AS (
	            SELECT * FROM Customers WHERE CompanyName LIKE 'G%'
            )

            SELECT * FROM MyQuery

            --Multiple ones
            WITH <b>MyCustomers</b> AS (
	            SELECT * FROM Customers WHERE CompanyName LIKE 'G%'
            )<b>,</b>
            MyOrders AS(
	            SELECT * FROM orders WHERE CustomerId IN (SELECT CustomerId FROM <b>MyCustomers</b>) 
            )

            --SELECT * FROM MyCustomers  --comment this one out because we can only have 1 statement after the WITH

            <b>SELECT * FROM MyOrders ORDER BY CustomerID</b>

        </pre>

        <p class="HeadingSubTopic" id="Exists" HeadingSubTopicDir>Exists</p>

        <pre>
            --only the suppliers that have products with a unit price over 25
            SELECT *
            FROM Suppliers
            WHERE EXISTS (SELECT ProductName FROM Products WHERE Products.SupplierID = Suppliers.supplierID AND UnitPrice > 25);

            --Can also do WHERE NOT EXISTS

            --to check if a table exists, before doing something with it 
            IF EXISTS (SELECT * FROM sys.objects WHERE OBJECT_NAME(object_id) = 'customers' AND SCHEMA_NAME(schema_id) = 'dbo' AND
	        OBJECTPROPERTY(object_id, 'IsUserTable') = 1)
            BEGIN
	            PRINT 'it exists'
            END 
            GO

            --check for DB existence
            IF NOT EXISTS (SELECT 'True' FROM sys.databases WHERE name = 'Northwind1111')
            BEGIN
	            PRINT 'it does not exists'
            END 
            GO

        </pre>

        <p class="HeadingSubTopic" id="Cast-Convert" HeadingSubTopicDir>Cast and Convert</p>

        About the same thing, but for dates, convert can also do formatting.
        <pre>
            SELECT 'supplierID is ' + CAST(supplierId AS varchar)
            FROM
            Suppliers


            SELECT 'supplierID is ' + CONVERT(VARCHAR, supplierId) AS CONVERTED
            FROM
            Suppliers
        </pre>

        <p class="HeadingSubTopic" id="Merge" HeadingSubTopicDir>Merge</p>
        Combination of insert, delete, update.  So if there is a Source table and a Target table that are to be merged, 
        then with the help of MERGE statement, all the three operations (INSERT, UPDATE, DELETE) can be performed at once.
        <pre>
            --BY TARGET is the default if not indicated.

            MERGE TARGET_LIST AS TARGET USING SOURCE_LIST AS SOURCE	

	        ON (TARGET.P_ID = SOURCE.P_ID)
            	WHEN MATCHED
		            AND TARGET.P_NAME &lt;&gt; SOURCE.P_NAME		            	
	            THEN UPDATE
		            SET TARGET.P_NAME = SOURCE.P_NAME,		        
			
            	WHEN NOT MATCHED BY TARGET
	                THEN INSERT (P_ID, P_NAME, P_PRICE)		
		            VALUES (SOURCE.P_ID, SOURCE.P_NAME, SOURCE.P_PRICE)
			
	            WHEN NOT MATCHED BY SOURCE
	                THEN DELETE

            --you can also add OUTPUT at the end if you want to obtain back a result set of what happened.
        </pre>

        <p class="HeadingSubTopic" id="Functions" HeadingSubTopicDir>Functions</p>

        <pre>
            SELECT 
                <b>ROW_NUMBER()</b> OVER ( ORDER BY EmployeeId) row_num,  --get this estra column with row ids
                LastName,
                FirstName,
                EmployeeId
            FROM
                employees;

                SELECT 
                ROW_NUMBER() OVER ( ORDER BY EmployeeId) row_num,  --get this estra column with row ids
                LastName,
                FirstName,
                EmployeeId
            FROM
                employees;
            WHERE row_num > 10

            SELECT 
                <b>RANK()</b> OVER ( ORDER BY Title) theRank, 
                LastName,
                FirstName,
	            EmployeeId
            FROM
                employees;

            
            /*theRank	LastName	FirstName	EmployeeId
            1	Callahan	Laura	8
            2	Buchanan	Steven	5
            3	Suyama	Michael	6
            3	King	Robert	7
            3	Dodsworth	Anne	9
            3	Davolio	Nancy	1
            3	Leverling	Janet	3
            3	Peacock	Margaret	4
            <b>9</b>	Fuller	Andrew	2*/

            /*Different from the RANK() function, the DENSE_RANK() function always generates consecutive rank values.*/

            SELECT 
                <b>DENSE_RANK()</b> OVER ( ORDER BY Title) theRank, 
                LastName,
                FirstName,
	            EmployeeId
            FROM
                employees;
            /*theRank	LastName	FirstName	EmployeeId
            1	Callahan	Laura	8
            2	Buchanan	Steven	5
            3	Suyama	Michael	6
            3	King	Robert	7
            3	Dodsworth	Anne	9
            3	Davolio	Nancy	1
            3	Leverling	Janet	3
            3	Peacock	Margaret	4
            <b>4</b>	Fuller	Andrew	2*/

            --NTILE divides the reesults into categories.
            SELECT 
                <b>NTILE(3)</b>  OVER ( ORDER BY Title) theRank, 
                LastName,
                FirstName,
	            EmployeeId
            FROM
                employees;

            /*theRank	LastName	FirstName	EmployeeId
            1	Callahan	Laura	8
            1	Buchanan	Steven	5
            1	Suyama	Michael	6
            2	King	Robert	7
            2	Dodsworth	Anne	9
            2	Davolio	Nancy	1
            3	Leverling	Janet	3
            3	Peacock	Margaret	4
            3	Fuller	Andrew	2*/

            SELECT    
                LastName,
                FirstName,
                EmployeeId
            FROM
                employees
            ORDER BY EmployeeId --need this order by
            <b>OFFSET 0 ROWS --number of rows to skip before retrieving.
            FETCH NEXT 2 ROW ONLY</b>



        </pre>

    </div>
</div>