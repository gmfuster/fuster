<div>

    <div class="PaddedContents">

        <br/>
        <h3 class="CenterMe">There is no @Service like there is @Component and @Directive</h3>
        <h3 class="CenterMe">You can add a service to the [providers] in the app module and it will be available everywhere.</h3>
        <h3  class="CenterMe">In Angular 6+, @Injectable(&lbrace;  providedIn: 'root' &rbrace;) export class MyService and it will be available everywhere.</h3><br/>

        <hr class="hrHeaderClass"/>
        <h2 class="CenterMe">Services</h2>
        <hr class="hrHeaderClass"/>

        <code><strong><u>Call Function in Service</u></strong></code><br />     
        <code>export class MathServices</code>   <br/>
        <code>To use svc, in ts: import &lbrace; Injectable &rbrace; from "@angular/core"; </code><br/>
        <code>import  &lbrace; MathServices &rbrace; from '../shared/forexamples.service';</code><br/>
        <code>in ts using svc: providers: [MathServices]</code><br/>
        <code>in ts using svc, before export: @Injectable()</code><br/>
        <code>in ts using svc:  constructor (private mathServices:MathServices)</code><br/>
        <code>to call: this.mathServices.getRandom1ToN(10)</code><br/>

        I have a service MathServices that has a getRandom1ToN function.  Click the button to call that service function and show the number we get.
        <button (click)="onClickMeClicked()">Click me</button>

        <hr class="hrClass" />


        <code><strong><u>Call Function in Service with @Injectable(&lbrace;  providedIn: 'root' &rbrace;)</u></strong></code><br />     
        <code>Injectable(&lbrace;providedIn: 'root' &rbrace;) before export class StringServices</code>   <br/>
        <code>In the svc, set function as public: public getAString() </code><br/>        
        <code>in ts using svc:  constructor (private mathServices:MathServices, private stringServices:StringServices)</code><br/>        

        I have a service StringServices created with the @Injectable(&lbrace;  providedIn: 'root' &rbrace;).  Click to call 
        a function on that service.  What not indicated above is the same as before.<br/>
        <button (click)="onClickMeClicked2()">Click me 2!</button><br/>

        This offers an advantage: Services can be lazy loaded by Angular when needed.  Better performance.


        <hr class="hrClass" />


        <code ngnonbindable><strong><u>Call Function in Service @NgModule</u></strong></code><br />     
        <code>in app.module: import &lbrace; OtherServices &rbrace; from './shared/forexamples.service'; under ngModule</code><br/>
        <code>function in the service should be public</code><br/>
        <code>No need add to providers in component</code><br/>
        <code>constructor (private mathServices:MathServices, private stringServices:StringServices, private otherServices:OtherServices)</code><br/>
                        
        Instead of on each component, import in the app module.  No need to add to providers in component.
        
        <button (click)="onClickMeClicked3()">Click me 3!</button><br/>
        

        <hr class="hrClass" />


        <code><strong><u>Call method that emmits event and listen to it</u></strong></code><br />     
        <code>in component, call service: this.otherServices.callMeToEmitEvent();    </code><br/>
        <code>the service will: this.somethingHappened.emit(now.toString()); with somethingHappened = new EventEmitter&lt;string &gt;();</code><br/>
        <code>in constructor of component: this.otherServices.somethingHappened.subscribe( 
            (text:string) =>&lbrace; this.somethingHappenedText = text;&rbrace;
        );</code><br/>
        <code >in html, &lt;span style="background-color: lightgreen;"&gt; &lbrace;&lbrace;somethingHappenedText&rbrace;&rbrace; &lt;/span&gt;</code><br/>
                        
        Clicking the button will call a service method that will return an event.  There will be code listening to that event from the service and it will set 
        the span with a "I got Notified at " and the time.<br/>
        
        <button (click)="onClickMeClicked4()">Click me 4!</button><br/>
        <span style="background-color: lightgreen;">{{somethingHappenedText}}</span>

        <hr class="hrClass" />



        <hr class="hrHeaderClass"/>
        <h2 class="CenterMe">Routing</h2>
        <hr class="hrHeaderClass"/>

        When you create an Angular app with VSC, it will create the initial routing for you:<br/>
        app.module.ts will have: <code ngNonBindable>import &lbrace; AppRoutingModule &rbrace; from './app-routing.module';</code><br/>
        Which has: <code ngNonBindable>import &lbrace; RouterModule, Routes &rbrace; from '@angular/router';</code> and includes routes such as:<br/>
        <code ngNonBindable>const routes: Routes = [  &lbrace; path: '', component: HomeComponent, pathMatch: 'full' &rbrace;,...</code><br/>
        <code ngNonBindable>@NgModule( &lbrace; imports: [RouterModule.forRoot(routes)], exports: [RouterModule] &rbrace;)</code><br/>
        <br/>
        The forRoot is what registers the routes.  Without this, they will not work.<br/>
        Whatever paths and components are indicated in the routes, they will be load it on <code ngNonBindable>&lt;router-outlet&gt;</code><br/>
        Once we have the routes set up, we could use them in the href of a link and that would work, but that would refresh the whole 
        page, which is not what we want when we are using Angular and its components.  Using the routes with href is like typing the 
        address on the browser.<br/>
        Instead use routerLink.  In the Home component, there is a link to read backwards, like this:
        <code ngNonBindable>&lt;a [routerLink]='["/read-back"]' &gt;&lt;/a&gt;</code> <br/>
        <a [routerLink]="['/read-back']"  >
            Click it and come back
        </a>
        <br/><br/>
        NOTE: If you are getting an error that it cannot find routerLink, make sure you introduced the component to the app.module.ts or Whatever
        module it should belong to.<br/>
        Make sure you test all your links.  You don't want to end up using an absolute path when you need a relative path or viceversa.  <br/>
        Use <code>[routerLinkActive]</code> set to a class to indicate what the link will look like when it is the active one (Angular will handle the how it knows)
        .  To use the Bootstrap one, just set it to "active".<br/>
        Use <code>[routerLinkActiveOptions]='&lbrace; exact: true &rbrace;'</code> to indicate for a link to be active it has to match the path exactly.
        If you don't, you will always have the home link active because all your other paths will include /, which is the home one.<br/>
        <br/>
        Besides links, we can also navigate through buttons or in the code. <br/>
        To use in a button on your code, import it in the ts file of the component, and add it to the constructor<br/>
        <code>import &lbrace; Router &rbrace; from '@angular/router';</code><br/>
        <code>constructor ( private router:Router)</code><br/>
        <code> In the event code ==> this.router.navigate(["/read-back"]);</code><br/>
        <button (click)="onClickToRouteSomewhereElse()">Click me to go somewhere else</button><br/>
        Note: Keep in mind that the code in the ts file doesn't know where you currently are, like it would happen with the routerLink.<br/>
        There is a way to get that information though, and that is by adding <code>ActivatedRoute</code> to the import, and then, we 
        can pass this as a second parameter to navigate <code>&lbrace;relativeTo:this.route&rbrace;</code>. this.route will contain where we are at the time.
        <br/><br/>

        <code><strong><u>dynamic Paths</u></strong></code><br />   
        <code>this.router.navigate(["/dynamic-notes/" + sendId]);  </code>
        <code>import &lbrace; ActivatedRoute, Router &rbrace; from '@angular/router';</code><br/>
        <code>constructor(private route:ActivatedRoute)</code><br/>
        <code>this.id = Number(this.route.snapshot.params['id']); </code><br/>    
        <code>path: 'dynamic-notes/:id'</code>    <br/>
        We can have dynamic paths, which will look like like <code>path:"users/:id", component:userComponent</code>. The part after : is the part
        that will be dynamic.<br/>
        I have a component just to show the data from the path on the screen. It will just take the id from the path and display it.<br/>
        <button (click)="onDynamicNotesClicked()">Go with no id (will def to 999)</button>  <br/>
        <button (click)="onDynamicNotesClicked(50)">Go with no id=50</button>  <br/>
        You can also type some other number on the url and you will see it.<br/>      
        You can have more than one dynamic parameter in the path.  You will get each one with snapshot.params.<br/>
        If you have the button requesting a different user on the same component where you are showing the data, the component will not reload
        just because the parameter changed, so you may not see the data you expect on the page.  But you can subscribe to the params changing so you 
        can update your variables when the path changes. <code>this.route.params.subscribe(params:Params => &lbrace; code to update your variables &rbrace;);</code>
        <br/>

    </div>  
</div>