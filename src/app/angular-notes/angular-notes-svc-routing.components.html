<div>

    <div class="PaddedContents">

        <br/>
        <h3 class="CenterMe">There is no @Service like there is @Component and @Directive</h3>
        <h3 class="CenterMe">You can add a service to the [providers] in the app module and it will be available everywhere.</h3>
        <h3  class="CenterMe">In Angular 6+, @Injectable(&lbrace;  providedIn: 'root' &rbrace;), export class MyService and it will be available everywhere.</h3>

        <span  id="services"></span>
        <br/>
        <!--<a  [routerLink]='["/angular-notes-svc-routing"]' fragment="routing" class="CenterMe">Jump To Routing</a>-->
        <h3  class="CenterMe">
            <a  href="/angular-notes-svc-routing/#routing">Jump To Routing</a>
        </h3>

        <hr class="hrHeaderClass"/>
        <h2 class="CenterMe" >Services</h2>
        <hr class="hrHeaderClass"/>

        <code><strong><u>Call Function in Service</u></strong></code><br />     
        <code>export class MathServices on the service file.</code>   <br/>
        <code>To use svc, in ts: import &lbrace; Injectable &rbrace; from "@angular/core"; </code><br/>
        <code>import  &lbrace; MathServices &rbrace; from '../shared/forexamples.service';</code><br/>
        <code>in ts using svc: providers: [MathServices]</code><br/>
        <code>in ts using svc, before export: @Injectable()</code><br/>
        <code>in ts using svc:  constructor (private mathServices:MathServices)</code><br/>
        <code>to call: this.mathServices.getRandom1ToN(10)</code><br/>

        I have a service MathServices that has a getRandom1ToN function.  Click the button to call that service function and show the number we get.
        <button (click)="onClickMeClicked()">Click me</button>

        <hr class="hrClass" />


        <code><strong><u>Call Function in Service with @Injectable(&lbrace;  providedIn: 'root' &rbrace;)</u></strong></code><br />     
        <code>Injectable(&lbrace;providedIn: 'root' &rbrace;) before export class StringServices</code>   <br/>
        <code>In the svc, set function as public: public getAString() </code><br/>        
        <code>in ts using svc:  constructor (private mathServices:MathServices, private stringServices:StringServices)</code><br/>        

        I have a service StringServices created with the @Injectable(&lbrace;  providedIn: 'root' &rbrace;).  Click to call 
        a function on that service.  What not indicated above is the same as before.<br/>
        <button (click)="onClickMeClicked2()">Click me 2!</button><br/>

        This offers an advantage: Services can be lazy loaded by Angular when needed.  Better performance.


        <hr class="hrClass" />


        <code ngnonbindable><strong><u>Call Function in Service @NgModule</u></strong></code><br />     
        <code>in app.module: import &lbrace; OtherServices &rbrace; from './shared/forexamples.service'; under ngModule</code><br/>
        <code>function in the service should be public</code><br/>
        <code>No need add to providers in component</code><br/>
        <code>constructor (private mathServices:MathServices, private stringServices:StringServices, private otherServices:OtherServices)</code><br/>
                        
        Instead of on each component, import in the app module.  No need to add to providers in component.
        
        <button (click)="onClickMeClicked3()">Click me 3!</button><br/>
        

        <hr class="hrClass" />


        <code><strong><u>Call method that emmits event and listen to it</u></strong></code><br />     
        <code>in component, call service: this.otherServices.callMeToEmitEvent();    </code><br/>
        <code>the service will: this.somethingHappened.emit(now.toString()); with somethingHappened = new EventEmitter&lt;string &gt;();</code><br/>
        <code>in constructor of component: this.otherServices.somethingHappened.subscribe( 
            (text:string) =>&lbrace; this.somethingHappenedText = text;&rbrace;
        );</code><br/>
        <code >in html, &lt;span style="background-color: lightgreen;"&gt; &lbrace;&lbrace;somethingHappenedText&rbrace;&rbrace; &lt;/span&gt;</code><br/>
                        
        Clicking the button will call a service method that will return an event.  There will be code listening to that event from the service and it will set 
        the span with date and time.<br/>
        
        <button (click)="onClickMeClicked4()">Click me 4!</button><br/>
        <span style="background-color: lightgreen;">{{somethingHappenedText}}</span>

        <hr class="hrClass" />


        <br  id='routing'/><br />
        <hr class="hrHeaderClass"/>
        <h2 class="CenterMe"  >Routing</h2>
        <hr class="hrHeaderClass"/>
        <h3  class="CenterMe">
            <a   href="/angular-notes-svc-routing/#services">Jump To Services</a><br/><br/>
        </h3>

        When you create an Angular app with VSC, it will create the initial routing for you:<br/>
        app.module.ts will have: <code ngNonBindable>import &lbrace; AppRoutingModule &rbrace; from './app-routing.module';</code><br/>
        Which has: <code ngNonBindable>import &lbrace; RouterModule, Routes &rbrace; from '@angular/router';</code> and includes routes such as:<br/>
        <code ngNonBindable>const routes: Routes = [  &lbrace; path: '', component: HomeComponent, pathMatch: 'full' &rbrace;,...</code><br/>
        <code ngNonBindable>@NgModule( &lbrace; imports: [RouterModule.forRoot(routes)], exports: [RouterModule] &rbrace;)</code><br/>
        <br/>
        The forRoot is what registers the routes.  Without this, they will not work.<br/>
        Whatever paths and components are indicated in the routes, they will be loaded on <code ngNonBindable>&lt;router-outlet&gt;</code><br/>
        Once we have the routes set up, we could use them in the href of a link and that would work, but that would refresh the whole 
        page, which is not what we want when we are using Angular and its components.  Using the routes with href is like typing the 
        address on the browser.<br/>
        Instead use routerLink.  In the Home component, there is a link to read backwards, like this:
        <code ngNonBindable>&lt;a [routerLink]='["/read-back"]' &gt;&lt;/a&gt;</code> <br/>
        <a [routerLink]="['/read-back']"  >
            Click it and come back
        </a>
        <br/><br/>

        NOTE: If you are getting an error that it cannot find routerLink, make sure you introduced the component to the app.module.ts or whatever
        module it should belong to.<br/>
        Make sure you test all your links.  You don't want to end up using an absolute path when you need a relative path or viceversa.  <br/>
        Use <code>[routerLinkActive]</code> set to a class to indicate what the link will look like when it is the active one (Angular will handle the how it knows)
        .  To use the Bootstrap one, just set it to "active".<br/>
        Use <code>[routerLinkActiveOptions]='&lbrace; exact: true &rbrace;'</code> to indicate for a link to be active it has to match the path exactly.
        If you don't, you will always have the home link active because all your other paths will include /, which is the home one.<br/>
        <br/>
        Besides links, we can also navigate through buttons or in the code. <br/>
        To use in a button on your code, import it in the ts file of the component, and add it to the constructor<br/>
        <code>import &lbrace; Router &rbrace; from '@angular/router';</code><br/>
        <code>constructor ( private router:Router)</code><br/>
        <code> In the event code ==> this.router.navigate(["/read-back"]);</code><br/>
        <button (click)="onClickToRouteSomewhereElse()">Click me to go somewhere else</button><br/>
        Note: Keep in mind that the code in the ts file doesn't know where you currently are, like it would happen with the routerLink.<br/>
        There is a way to get that information though, and that is by adding <code>ActivatedRoute</code> to the import, and then, we 
        can pass this as a second parameter to navigate <code>&lbrace;relativeTo:this.route&rbrace;</code>. This.route will contain where we are at the time.
        <br/><br/>

        <hr class="hrClass" />

        <code><strong><u>dynamic Paths</u></strong></code><br />   
        <code>this.router.navigate(["/dynamic-notes/" + sendId]);  </code>
        <code>import &lbrace; ActivatedRoute, Router &rbrace; from '@angular/router';</code><br/>
        <code>constructor(private route:ActivatedRoute)</code><br/>
        <code>this.id = Number(this.route.snapshot.params['id']); </code><br/>    
        <code>path: 'dynamic-notes/:id'</code>    <br/>
        We can have dynamic paths, which will look like like <code>path:"users/:id", component:userComponent</code>. The part after : is the part
        that will be dynamic.<br/>
        I have a component just to show the data from the path on the screen. It will just take the id from the path and display it.<br/>
        <button (click)="onDynamicNotesClicked()">Go with no id (will def to 999)</button>  <br/>
        <button (click)="onDynamicNotesClicked(50)">Go with id as 50</button>  <br/>
        You can also type some other number on the url and you will see it.<br/>      
        You can have more than one dynamic parameter in the path.  You will get each one with snapshot.params.<br/>
        If you have the button requesting a different user on the same component where you are showing the data, the component will not reload
        just because the parameter changed, so you may not see the data you expect on the page.  But you can subscribe to the params changing so you 
        can update your variables when the path changes. <code>this.route.params.subscribe(params:Params => &lbrace; code to update your variables &rbrace;);, access 
            with params['whateverparameteryouused']
        </code>
        <br/><br/>

        <hr class="hrClass" />


        
         <code><strong><u>dynamic Paths with dynamic part in the middle</u></strong></code><br />   
         You could add something else after the dynamic element of the path, something like this: <code>... path: 'dynamic-notes/:id/<b>edit</b>', ...</code>
         The link could be something like <code>[routerLink]='["/dynamic-notes",5, "edit" ]'</code><br/>
        
         When you are using [routerLink] and you need to pass parameters with data (usually passed after the ? on the link), you can add 
         <code>[queryParams]="&lbrace;param1:'value1', param2:'value2'&rbrace;"</code>.  Now param1 and param2 will show up in the link after the ?.  The 
         parameters will be separated with &.  With this you can also add a fragment="Loading or whatever" and that will add #Loading or whatever at the end of the link. 

         To do the same in code, you would use :<br/>
         <code>this.router.navigate(["/dynamic-notes/" + sendId, "edit"], &lbrace; queryParams: &lbrace;param1:'value1', param2:'value2'&rbrace;, fragment:'loading'  &rbrace; ); </code>

         <br/>

         To get the parameters it is similar to other things fro the link: this.route.snapshot.queryParams, this.route.snapshot.fragment.  We can also subscribe to those.
        

         <br/>

         <hr class="hrClass"/>
         <code><strong><u>Nested Routing</u></strong></code><br />   

         I you end up with different routes that have the same at the beginning of the path, you may be better of changing them to have a main path, and 
         then children paths (routes) under it. For example, if you have paths:<br/>         
         &lbrace; path: 'commonpath', component: SomeComponent&rbrace;,<br/>
         &lbrace; path: 'commonpath/:id', component: SomeComponentId&rbrace;,<br/>
         &lbrace;path: 'commonpath/:id/edit', component: SomeComponentIdEdit&rbrace;,<br/>


         You can split it up in a parent and its children, like this:<br/>
         <code>
         &lbrace; path: 'commonpath', component: SomeComponent, children: [<br/>
            &nbsp;&lbrace; path: ':id', component: SomeComponentId&rbrace;,<br/>
            &nbsp;&lbrace; path: ':id/edit', component: SomeComponentIdEdit&rbrace;,<br/>
            ]&rbrace;
        </code>
        <br/>
        When we have nested routes, we also need rested router-outlets.  In this case, the SomeComponent will load in the main router-outlet 
        and this SomeComponent html should have another router-outlet where the child will load.<br/>
        If you want to navigate to a child from SomeComponent, you could do it like this:<br/>
        <code>this.router.navigate(['commonpath', someidvarintparentcomponent, 'edit']);</code><br/>
        or<br/>
        <code>this.router.navigate(['edit'] , &lbrace; this.route &rbrace;);</code><br/>
        If we are using the queryParams from the parent in the navigation, we will lose them when we navigate.  To preserve them, do this :
        <code>this.router.navigate(['edit'], &lbrace;relativeTo: this.route, <b>queryParamsHandting: 'preserved' </b>&rbrace; ) </code>

        <br/>
        <br/>

    </div>  
</div>