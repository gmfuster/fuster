<div>

    <div class="PaddedContents">

        <br/>
        <h3 class="CenterMe">There is no @Service like there is @Component and @Directive</h3>
        <h3 class="CenterMe">You can add a service to the [providers] in the app module and it will be available everywhere.</h3>
        <h3  class="CenterMe">In Angular 6+, @Injectable(&lbrace;  providedIn: 'root' &rbrace;) export class MyService and it will be available everywhere.</h3><br/>

        <hr class="hrHeaderClass"/>
        <h2 class="CenterMe">Services</h2>
        <hr class="hrHeaderClass"/>

        <code><strong><u>Call Function in Service</u></strong></code><br />     
        <code>export class MathServices</code>   <br/>
        <code>To use svc, in ts: import &lbrace; Injectable &rbrace; from "@angular/core"; </code><br/>
        <code>import  &lbrace; MathServices &rbrace; from '../shared/forexamples.service';</code><br/>
        <code>in ts using svc: providers: [MathServices]</code><br/>
        <code>in ts using svc, before export: @Injectable()</code><br/>
        <code>in ts using svc:  constructor (private mathServices:MathServices)</code><br/>
        <code>to call: this.mathServices.getRandom1ToN(10)</code><br/>

        I have a service MathServices that has a getRandom1ToN function.  Click the button to call that service function and show the number we get.
        <button (click)="onClickMeClicked()">Click me</button>

        <hr class="hrClass" />


        <code><strong><u>Call Function in Service with @Injectable(&lbrace;  providedIn: 'root' &rbrace;)</u></strong></code><br />     
        <code>Injectable(&lbrace;providedIn: 'root' &rbrace;) before export class StringServices</code>   <br/>
        <code>In the svc, set function as public: public getAString() </code><br/>        
        <code>in ts using svc:  constructor (private mathServices:MathServices, private stringServices:StringServices)</code><br/>        

        I have a service StringServices created with the @Injectable(&lbrace;  providedIn: 'root' &rbrace;).  Click to call 
        a function on that service.  What not indicated above is the same as before.<br/>
        <button (click)="onClickMeClicked2()">Click me 2!</button><br/>

        This offers an advantage: Services can be lazy loaded by Angular when needed.  Better performance.


        <hr class="hrClass" />


        <code ngnonbindable><strong><u>Call Function in Service @NgModule</u></strong></code><br />     
        <code>in app.module: import &lbrace; OtherServices &rbrace; from './shared/forexamples.service'; under ngModule</code><br/>
        <code>function in the service should be public</code><br/>
        <code>No need add to providers in component</code><br/>
        <code>constructor (private mathServices:MathServices, private stringServices:StringServices, private otherServices:OtherServices)</code><br/>
                        
        Instead of on each component, import in the app module.  No need to add to providers in component.
        
        <button (click)="onClickMeClicked3()">Click me 3!</button><br/>
        

        <hr class="hrClass" />


        <code><strong><u>Call method that emmits event and listen to it</u></strong></code><br />     
        <code>in component, call service: this.otherServices.callMeToEmitEvent();    </code><br/>
        <code>the service will: this.somethingHappened.emit(now.toString()); with somethingHappened = new EventEmitter&lt;string &gt;();</code><br/>
        <code>in constructor of component: this.otherServices.somethingHappened.subscribe( 
            (text:string) =>&lbrace; this.somethingHappenedText = text;&rbrace;
        );</code><br/>
        <code >in html, &lt;span style="background-color: lightgreen;"&gt; &lbrace;&lbrace;somethingHappenedText&rbrace;&rbrace; &lt;/span&gt;</code><br/>
                        
        Clicking the button will call a service method that will return an event.  There will be code listening to that event from the service and it will set 
        the span with a "I got Notified at " and the time.<br/>
        
        <button (click)="onClickMeClicked4()">Click me 4!</button><br/>
        <span style="background-color: lightgreen;">{{somethingHappenedText}}</span>

        <hr class="hrClass" />



        <hr class="hrHeaderClass"/>
        <h2 class="CenterMe">Routing</h2>
        <hr class="hrHeaderClass"/>

        When you create an Angular app with VSC, it will create the initial routing for you:<br/>
        app.module.ts will have: <code ngNonBindable>import &lbrace; AppRoutingModule &rbrace; from './app-routing.module';</code><br/>
        Which has: <code ngNonBindable>import &lbrace; RouterModule, Routes &rbrace; from '@angular/router';</code> and includes routes such as:<br/>
        <code ngNonBindable>const routes: Routes = [  &lbrace; path: '', component: HomeComponent, pathMatch: 'full' &rbrace;,...</code><br/>
        <code ngNonBindable>@NgModule( &lbrace; imports: [RouterModule.forRoot(routes)], exports: [RouterModule] &rbrace;)</code><br/>
        <br/>
        The forRoot is what registers the routes.  Without this, they will not work.<br/>
        Whatever paths and components are indicated in the routes, they will be load it on <code ngNonBindable>&lt;router-outlet&gt;</code><br/>
        Once we have the routes set up, we could use them in the href of a link and that would work, but that would refresh the whole 
        page, which is not what we want when we are using Angular and its components.  Using the routes with href is like typing the 
        address on the browser.<br/>
        Instead use routerLink.  In the Home component, there is a link to read backwards, like this:
        <code ngNonBindable>&lt;a [routerLink]='["/read-back"]' &gt;&lt;/a&gt;</code> <br/>
        <a [routerLink]="['/read-back']"  >
            Click it and come back
        </a>
        <br/><br/>
        NOTE: If you are getting an error that it cannot find routerLink, make sure you introduced the component to the app.module.ts or Whatever
        module it should belong to.<br/>

    </div>  
</div>