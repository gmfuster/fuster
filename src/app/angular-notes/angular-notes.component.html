
<div>
  <h2 class="CenterMe">Angular notes - Basics</h2>  
  <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>
  <h4 class="CenterMe">When adding new components, remember you may have to restart for them to be found.</h4>
  <h3 class="CenterMe"> <a href="https://medium.com/nerd-for-tech/angular-vs-react-compare-the-very-basics-776fd96fec23"
    target="_new">Check out Angular vs React - basics</a></h3>
  <br />
  <h3 class="CenterMe">Input fields, in general, take only numbers. </h3>


  <div class="PaddedContents">

    
    <p class="HeadingSubTopic">String Interpolation</p>   
    <code ngNonBindable>{{theVariable}}</code><br />
    <code>&lt; input #theInput type="number"/&gt; </code><br />
    <code> &lt; button (click)="onClickButton1(theInput.value)"&gt; </code><br />
    Type something in this input set as #theInput (only numbers) <input #theInput type="number" /> and send it with this button with (click)="onClickButton1(theInput.value)
     <button (click)="onClickButton1(theInput.value)">send it</button>. It displays in the marked field below, which displays theVariable.<br />
    <mark>{{theVariable}}</mark>

    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">Property Binding</p>
    <code>On second button: [disabled]="theBoolVar"</code><br />
    <code>On button always disabled: [disabled]=true</code><br />
    <code>On Switch Bool button: &lt; (click)="onSwitchTheBoolVar()"&gt; Switch Bool&lt;/button&gt;</code><br />
    Use the syntax as [] for the html attributes and use quotes to use a variable for the attributes. Use no quotes assigned to the attribute to <b>hardcode</b> the value.  
    Click the button to switch between true and false and enable or disable the second button (which does nothing).
    <button (click)="onSwitchTheBoolVar()">Switch Bool</button> &nbsp; <button [disabled]="theBoolVar">Will Go On/Off</button> &nbsp;<button [disabled]=true>Always Disabled</button><br />
    For an event, use (click)="onSwitchTheBoolVar<b>($event)</b>" and <b>event:any or event:Event</b> in the ts file as the parameter received for the event, if you need access to the event info.

    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">2-way Binding</p>
    <code ngNonBindable>&lt;input type="number"[(ngModel)]="theVariable"/&gt;</code><br />
    <code ngNonBindable>app.module.ts -- import FormsModule from '@angular/forms'</code><br />
    Use ngModel in the input field.  It will update the variable right away and from the ts code, which we link to the same variable for the display too, 
    it will update right away.  Click the button to update the variable to something different.
    <input type="number" [(ngModel)]="theVariable"/><br/><br/>
    <mark>{{theVariable}}</mark><br/><br/>
    <button (click)="onSetVariableToHello()">call onSetVariableToHello</button>
    

    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">Angular Directive</p>
    <code ngNonBindable>*ngIf</code><br />
    <code ngNonBindable>&lt;mark *ngIf="theBoolVar" &gt;</code><br />
    The marked test below will show depending on a boolean variable on the ts file.  Change the value with the button.<br/>
    <button (click)="onSwitchTheBoolVar()">Switch Boolean</button><br/><br/>
    <mark *ngIf="theBoolVar">I go on and off</mark><br/><br/>
    
    <code ngNonBindable><u>*ngIf with else</u></code><br />    
    <code ngNonBindable>&lt;mark *ngIf="theBoolVar; else onElse;" &gt;I go on and off&lt;/mark&gt;</code><br/>
    <code ngNonBindable>&lt;ng-template #onElse&gt;I show up on else (false)&lt;/mark&gt;</code><br/>
    The marked test below will show depending on a boolean variable on the ts file.  There is an ng-template for the else
    that will show on false.  Change the value with the button.<br/>
    <button (click)="onSwitchTheBoolVar()">Switch Boolean</button><br/><br/>
    <mark *ngIf="theBoolVar; else onElse;" >I go on and off</mark><br/><br/>
    <ng-template #onElse><mark >I show up on else (false)</mark></ng-template>

    <hr class="hrClass" />
      
    <p class="HeadingSubTopic">Angular Directive</p>
    <code ngNonBindable>[ngStyle]="&lbrace;backgroundColor:theColor&rbrace;"</code><br />    
    Click the button to get a random background color by changing theColor property. Could also have a method instead
    of theColor in the span element.  <button (click)="onRandomColor()">Random Color</button><br/>
    span element: <span [ngStyle]="{backgroundColor:theColor}">Hello!</span><br/>
    
    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">Angular Directive</p>
    <code ngNonBindable>[ngClass]="&lbrace;redClass:theBoolVar&rbrace;"</code><br />    
    Similar to the examples above, set ngClass to a class (redClass) to set the font to red based on the boolean value (when true). The redClass is in the css file.<br/>
    <button (click)="onSwitchTheBoolVar()">Switch Boolean</button><br/><br/>
    <span [ngClass]="{redClass: theBoolVar}">I'll be red when TheBoolVar is true</span>
  
    <hr class="hrClass" />

    <p class="HeadingSubTopic">Angular Directive</p>
    <code ngNonBindable>&lt;input type="number" (keydown)="onValueChanged($event)"/&gt;</code><br/>
    <code ngNonBindable>&lt;div*ngFor="let item of theNumArray;"&gt;</code><br />    
    <code ngNonBindable>ts file : onValueChanged(event:KeyboardEvent)...for(let i = 1; i <= parseInt(event.key); i++) populate theNumArray</code><br />    
    Enter a number from 1 to 5 (you can enter more too) and the code will show that many lines.<br/>  
    You can also add let i = index in the ngFor to get the index of the iteration.<br/>
    <input type="number" (keydown)="onValueChanged($event)"/><br/><br/>
    <div *ngFor = "let item of theNumArray;"> {{item}}</div>
    <br/>

    <hr class="hrClass" />

    <p class="HeadingSubTopic">Angular Directive</p>
    <code ngNonBindable>&lt;div [ngSwitch]="theColor" [ngStyle]= "&lbrace; border:'2px solid skyblue'&rbrace;"/&gt;</code><br/>
    <code ngNonBindable>&lt;p elements inside the div with the ngSwitch: *ngSwitchCase="'aqua'"/&gt;</code><br/>
    The random color button above returns aqua, red, pink, yellow, green, and gray.  Have a switch for the theColor variable for each of those.<br/>
    Notice the single quotes inside the "" on the case elements.  If numbers, don't include the single quotes.  The color is not changing, but the word will change 
    to match the theColor value.<br/>
    <button (click)="onRandomColor()">Random Color</button><br/><br/>
    <div [ngSwitch]="theColor" [ngStyle]="{border:'2px solid skyblue'}">
      <p *ngSwitchCase="'aqua'">aqua</p>
      <p *ngSwitchCase="'red'">red</p>
      <p *ngSwitchCase="'yellow'">yellow</p>
      <p *ngSwitchCase="'green'">green</p>
      <p *ngSwitchCase="'gray'">gray</p>
      <p *ngSwitchDefault>Default</p>
    </div>
    <br/>
    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">Get Data from Parent Component</p>
    <code>button calls onRandomColor which assigns a color string to theColor:</code><br />
    <code ngNonBindable>&lt;some-child-component [myColor]= "theColor" [myTextAlias]="theColor"&gt;  -- note this uses the alias name</code><br/>
    <code>On child ts:</code><br />
    <code>@Input() myColor :string="";</code><br />
    <code>@Input('myTextAlias') myText :string="";</code><br />    
    <code>child component: [ngStyle] has backgroundColor:myColor</code><br/>
    <code ngNonBindable>on child component: &lbrace;&lbrace; myText &rbrace;&rbrace; -- use the variable name, not the alias name </code>
    In this angular-notes component we have a theColor variable used above.  Using it here again, but this time, include also a child component
    which will change its background based on the value we get.  It will also display the text sent to it as an alias.<br/>
    (Disregard the button in the child component, it is not being listened to in this code).<br/>
    <button (click)="onRandomColor()">Random Color</button><br/><br/>
    The child component takes in a myColor and a myTextAlias properties.  Both set to the variable.
    <some-child-component [myColor]= "theColor" [myTextAlias]="theColor"></some-child-component>

    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">Tell Parent of Change in Child</p>
    <code>&lt;some-child-component (eventOnChildComponentWithEventReturn)="onChildEvent1($event)" (eventOnChildComponentWithKnownObjReturn)="onChildEvent2($event)"&gt;</code><br/>
    <code>On Child: &lt;button (click)="launchEvents($event)"&gt;</code><br/>
    <code>On child ts: @Output() eventOnChildComponentWithKnownObjReturn = new EventEmitter&lt;&lbrace;theName:string, theText:string&rbrace;&gt;();</code><br/>
    <code>On child ts: @Output() eventOnChildComponentWithEventReturn = new EventEmitter&lt;Event&gt;();</code><br/>
    <code>On launchEvents: this.eventOnChildComponentWithKnownObjReturn.emit(&lbrace;theName:"Child Name", theText:"Child Text Hello"&rbrace;);
      or just pass the event down to the eventOnChildComponentWithEventReturn
    </code><br/>
    <code>On parent ts events, have onChildEvent1(event:Event) or onChildEvent2(theEventObj:&lbrace;theName:string, theText:string&rbrace;)</code><br/>
    The parent (this angular notes component) will be listening to events of the child component (some-child-component).<br/>
    When adding EventEmitter, check your import statements.  Make sure it is imported from angular/core.<br/>
    You can get just event from the event on the child, or something specific. Use void if the event returns nothing.<br/><br/>

    <img width="100%" src="assets\images\misc\parentlistenstochildevents.png" alt="parents listens to child events" /><br/><br/>

    <some-child-component (eventOnChildComponentWithEventReturn)="onChildEvent1($event)" (eventOnChildComponentWithKnownObjReturn)="onChildEvent2($event)" ></some-child-component>
    <em><u>Text from event 1:</u> </em><br/>
    {{someText1}}<br/>
    <em><u>Text from event 2:</u> </em><br/>
    {{someText2}}<br/>

    <hr class="hrClass" />

    <div id="viewchild" ></div><br/>
    <p class="HeadingSubTopic">ViewChild</p>
    This concept has too much to be included here, so instead, check out my article on Medium 
    <a href="https://medium.com/nerd-for-tech/angular-viewchild-for-component-dom-element-element-of-component-and-directive-c23328ee1525"
    target="_new">Angular â€” ViewChild for component, DOM element, element of component, and directive</a><br/>
    However, for a brief refresher of what this is about, check out the images:<br/>

    <img width="100%" src="assets\images\misc\viewchild1.png" alt="viewchild1 content elements" /><br/><br/>
    <img width="100%" src="assets\images\misc\viewchild2.png" alt="viewchild2 content elements" /><br/><br/>
    <img width="100%" src="assets\images\misc\viewchild3.png" alt="viewchild3 content elements" /><br/><br/>
    <img width="100%" src="assets\images\misc\viewchild4.png" alt="viewchild4 content elements" /><br/><br/>

    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">ng-Content</p>
    <code><strong>In Parent Component:</strong></code><br/>
    <code>&lt;h1 class="class1" [ngStyle]="&lbrace;backgroundColor:'skyblue'&rbrace;"&gt;Header 1 with class1 going to ng-content on child&lt;/h1&gt;</code><br/>
    <code>&lt;h2 id="header2" [ngStyle]="&lbrace;backgroundColor:'teal'&rbrace;"&gt;Header 2 with header2 id going to ng-content on child&lt;/h2&gt;</code><br/>
    <code>&lt;span [ngStyle]="&lbrace;backgroundColor:'lightyellow'&rbrace;"&gt;I am just inside a span element&lt;/h2&gt;</code><br/>
    <code><strong>In Child Component:</strong></code><br/>
    <code>&lt;ng-content  select=".class1"&gt;   </code><br/>
    <code>&lt;ng-content  select="[id=header2]"&gt;   </code><br/>
    <code>&lt;ng-content  select="span"&gt;   </code><br/>
    I am going to have some ng-content elements in the some-child-component component.  Then I'll use that component here in the angular-notes component.
    Each ng-content in the child will display a different way and it will choose what to put in that container based on some element, class, and id.
    <b>(ng-content cannot have content besides what's passed to it)</b>.<br/>
    <img width="100%" src="assets\images\misc\ng-content.png" alt="ng content elements" /><br/><br/>

    <some-child-component>
      <span [ngStyle]="{backgroundColor:'lightyellow'}">I am just inside a span element</span>
      <h2 id="header2" [ngStyle]="{backgroundColor:'teal'}">Header 2 with header2 id going to ng-content on child</h2>  
      <h1 class="class1" [ngStyle]="{backgroundColor:'skyblue'}">Header 1 with class1 going to ng-content on child</h1>         
    </some-child-component>



    <hr class="hrClass" />    
    <p class="HeadingSubTopic">ContentChild for ng-Content (can't use ViewChild)</p>
    <code><strong>In Parent Component:</strong></code><br/>
    <code>&lt;h1 class="class1" #header1 [ngStyle]="&lbrace;backgroundColor:'skyblue'&rbrace;"&gt;Header 1 with class1 going to ng-content on child&lt;/h1&gt;</code><br/>
    <code>&lt;h2 id="header2" #header2 [ngStyle]="&lbrace;backgroundColor:'teal'&rbrace;"&gt;Header 2 with header2 id going to ng-content on child&lt;/h2&gt;</code><br/>
    <code>&lt;span #span1 [ngStyle]="&lbrace;backgroundColor:'lightyellow'&rbrace;"&gt;I am just inside a span element&lt;/h2&gt;</code><br/>
    <code><strong>In Child Component ts:</strong></code><br/>
    <code>@ContentChild("header1",&lbrace;static:true&rbrace;) header1vble: ElementRef=&lbrace;&rbrace; as ElementRef;</code><br/>
    <code>@ContentChild("header2",&lbrace;static:true&rbrace;) header2vble: ElementRef=&lbrace;&rbrace; as ElementRef;</code><br/>
    <code>@ContentChild("span1",&lbrace;static:true&rbrace;,read:NgStyle) spanvble: NgStyle=&lbrace;&rbrace; as NgStyle;</code><br/>
    You can't use ViewChild for content in an ng-content.  For that you need ContentChild. It returns the first element matching the selector.  
    If the content DOM changes, and a new child matches the selector, the property will be updated.  <b><u>Use ContentChild
    in the component that has the ng-content to find content that has been projected there.</u></b>  I am using the same child component as above, which has the ng-content.  
    Set up as in the above example <b><u>except adding #header2 to the h2 element, #header1 to the h1, and #span to the span (that's how I'll access them).  </u></b>
    Don't forget to import ContentChild from angular/core.<br/>
    Angular initializes the component first. It then raises the ngOnChanges, ngOnInit & ngDoCheck hooks. The projected components are initialized next. 
    And then Angular raises the AfterContentInit & AfterContentChecked hooks.  Then ContentChild is available.  That is the default.  We can use static as true to
    change it(the query will be available once the view has been created, but before change detection runs).  
    Just displaying the ContentChild variables in the console (though commented out).<br/>
    <img width="100%" src="assets\images\misc\contentchild1.png" alt="content child elements" /><br/><br/>

    <some-child-component>
      <h1 class="class1" #header1 [ngStyle]="{backgroundColor:'skyblue'}">Header 1 with class1 going to ng-content on child</h1>
      <h2 id="header2" #header2 [ngStyle]="{backgroundColor:'teal'}">Header 2 with header2 id going to ng-content on child</h2>
      <span #span1 [ngStyle]="{backgroundColor:'lightyellow'}">I am just inside a span element</span>
    </some-child-component>



    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">Angular Directives and Your Own</p>
    <code>&lt;p appSomeDirectiveDirective appSomeDirectiveDirective2 fontColor="deeppink"&gt;</code><br/>
    <code>OR</code>
    <code>&lt;p appSomeDirectiveDirective appSomeDirectiveDirective2 [fontColor]="'deeppink'"&gt;</code><br/>
    <code ><strong>In the directive ts file:</strong></code><br />
    <code>@Directive(&lbrace; selector: '[appSomeDirectiveDirective2]' &rbrace;;)</code><br/>
    <code>For directive 2:  @Input() fontColor :string = "green";</code><br/>
    <code>ngOnInit for directive 1: this.theElementRef.nativeElement.style.backgroundColor='lightblue';</code><br/>
    <code>ngOnInit for directive 2: this.theElementRef2.nativeElement.style.color = this.fontColor;</code><br/>
    <code>similar in both directives: constructor(private theElementRef2:ElementRef) - reference it ins the ngOnInit</code><br/>

    Angular directives are cool but we can also create our own.  I'm going to use a component directive some-directive-directive.
    <b><u>The ts file for this directive is not a @Component but a @Directive.</u></b> <strong> Not using renderer in this example </strong>, will use it later for the same thing.
    Remember to include the directive in the app.module.ts so it can be used.  I'll be using that directive in a p element here.  Like for components,
    keep in mind you use the select name on the element where you will use it.<br/>
    I have 2 directives in the same file, and one of them takes a fontColor<br/>

    <img width="100%" src="assets\images\misc\yourdirective.png" alt="custom directive" /><br/><br/>

    <p appSomeDirectiveDirective appSomeDirectiveDirective2 [fontColor]="'deeppink'">Some p element using the SomeDirectiveDirective.  </p>




    <hr class="hrClass" />
    
    <p class="HeadingSubTopic">Renderer</p>
    <code>&lt;p appSomeDirectiveDirective3>Some p element using the SomeDirectiveDirective3 with renderer2. </code>&gt;<br/>
    <code>constructor(private theElementRef3:ElementRef, private renderer:Renderer2)</code><br/>
    <code>this.renderer.setStyle(this.theElementRef3.nativeElement, 'background-color', 'green')</code><br/>
    Similar to the above one, but will get a directive 3 that will use renderer to access the style.  Don't forget to include the new directive in the app.module.  I keep 
    doing that. <br/>
    <p appSomeDirectiveDirective3>Some p element using the SomeDirectiveDirective3 with renderer2. </p>



    <hr class="hrClass" />

    <p class="HeadingSubTopic">HostBinding to change the directive style</p>
    <code> @HostBinding('style.backgroundColor') backColor :string = 'transparent';</code><br />
    <code>on ngOnInit: this.backColor = 'lightblue';</code><br />
    Going to use a 4th directive to make use of HostBinding to set the background.<br/>
    <p appSomeDirectiveDirective4>Some p element using the SomeDirectiveDirective4 with HostBinding. </p>



    <hr class="hrClass" />
    <p class="HeadingSubTopic">HostListener for Directive</p>
    <code>@HostBinding('style.backgroundColor') backColor :string = 'transparent';</code><br/>
    <code>@HostListener('mouseenter') mouseE(eventData:Event)&lbrace; this.backColor = 'lightblue'; &rbrace;</code><br/>
    <code>@HostListener('mouseenter') mouseL(eventData:Event)&lbrace; this.backColor = 'lightpink'; &rbrace;</code><br/>
    Using the paragraph with a 5th directive now, which will listen to the mouse events and change the color that way. Move the cursor on and off the p.<br/>
    <p appSomeDirectiveDirective5>Some p element using the SomeDirectiveDirective5 with HostBinding. </p>



    <hr class="hrClass" />    
    <p class="HeadingSubTopic">Your Own Structural Directive</p>
    <code>constructor(private templateRef:TemplateRef&lt;any&gt;, private vcRef: ViewContainerRef)&lbrace;&rbrace;</code><br/>
    <code>&lt;div *appSomeDirectiveDirectiveSTR="theNumVariable"&gt; -- set in the input field</code><br/>
    <code>@Input() set appSomeDirectiveDirectiveSTR(number:Number) -- name of set has to match name of selector in directive</code><br/>
    <code>this.vcRef.clear();   </code><br/>
    <code>in a for: this.vcRef.createEmbeddedView(this.templateRef);</code><br/>
    A structural directive is one that changes the structure of the DOM (like ngIf, ngFor, and we use them with *).
    <strong>TemplateRef</strong>: It represents an embedded template that can be used to instantiate embedded views.  
    <strong>ViewContainerRef:</strong> It represents a container where one or more views can be attached.<br/><br/>
    Input a number here to see that number of times repeated.<br/>
    <img width="100%" src="assets\images\misc\structuredirective.png" alt="structure directive" /><br/><br/>
    <input [(ngModel)]="theNumVariable" type="number" /><br/>
    <div *appSomeDirectiveDirectiveSTR="theNumVariable">
      I am div 
    </div>
    <br/>
    <br/>

    <hr class="hrClass" />
    <p class="HeadingSubTopic">Observables</p>
    An Observable is a data source.  We can use it importing the RxJS package.  Your code can be the observer to this observable.  There 
    are three types of data packages you can receive with these: data, errors, completions.  Observables are like a different approach to promises.<br/>
    You can install the package with <b>npm install --save rxjs@6</b> or whatever version you want.  You can also install <b>npm install --save rxjs-compat</b>

    <br/>
    In previous code we have used this.route.params.subscribe.  params is an observable.  In general, you will not need to create your own observables, but just 
    to know, a little bit here.<br/>
    To create your own observables, which are not a part of JS or TypeScript, you need <b>package rxjs</b>.  One of the easiest ways is importing <b>"interval"</b> from 
    the package.<br/>
    <pre>
      <code>
        <b>import &lbrace;interval, subscription&rbrace; from 'rxjs';</b>

        //in the ts file that's going to have this code, implement also from onDestroy so we can call to unsubscribe when we are no longer in this code. 

        ngOnit()&lbrace;
          //send value every second, we can subscribe like this
          //interval(period:1000).subscribe(next:value => console.log(value));
          //or we could also store the above line in a variable, say 
          <b>this.whatever = interval(period:1000).subscribe(next:value => console.log(value));</b>
        &rbrace;

        //if we are storing the subscription as above, now we can unsubscribe when we are done.
        <b>onDestroy()&lbrace;</b>
          <b>this.whatever.unsubscribe;</b>
        &rbrace;
      </code>
    </pre>
    It is important to unsubscribe so we don't end up with a memory leak, or wasting resources.  When we are using the Angular observables, like the params one,
    Angular will unsubscribe automatically so we don't have to do it.  interval fires a number every second or whatever interval we give.  What if instead of 
    subscribing to the Angular params, or the rxjs interval above we want to <b>subscribe to our own Observable?</b><br/>
    The subscribe and unsubscribe is going to be the same as above, but instead of interval(period:1000) we will use <b>myObservable.subscribe(...as above);</b>
    So creating the myObservable (use setInterval and indicate how often and what value to send):<br/>
    <pre>
      <code>
        const <b>myObservable</b> = Observable.create( //Observable has to be imported from rxjs
          <b>observer</b> => &lbrace;
            let <b>value</b> = 0;
            <b>setInterval</b> ( handler: () =>
              &lbrace;
                observer.next(<b>value</b>);
                value = value + 10;
              &rbrace;  , timeout:1000
            );
          &rbrace;
        )
      </code>
    </pre>
    The observer above, in the myObservable code, could also be throwing an error with <b>observer.error(new Error(message:"some error"));</b><br/>
    If we don't handle the possibility of an error when we are observing, the code will just break.  If we want to handle it, we can add another argument to the 
    <b>this.whatever = interval(period:1000).subscribe(next:value => console.log(value));</b>.  It could be something like 
    this.whatever = myObservable.subscribe(value => console.log(value), error => &lbrace;whatever&rbrace;);<br/>
    Once the observable throws an error, it gets cancelled. We can also complete the observable in the code with <b>observer.complete()</b>  If we want to 
    do something when there is a completion, we can add a third argument to our observer, with no arguments, like <br/>
    <b>this.whatever = myObservable.subscribe(value => console.log(value), error => &lbrace;whatever&rbrace;, () => &lbrace;whatever&rbrace; );</b><br/>
    An error will cancell the observable, that is not the same as a completion.
    <br/><br/>
    <b>Operators in the rxjs library:</b><br/>
    You can import the available operators from "rxjs/operators".  map is one of the most commonly used ones.  You can use this operators inside the code 
    of the observable you are creating. But you can also use them in your assignment of myObservable to this.whatever.  (so you can get the data with some 
    changes through the operators). Use myObservable.pipe( and in here your operators). If you need various operators, you have them here separated my commans,
    but remember to import the ones you want to use. They will execute on the data of the observable, in the order in which you put them in.<br/>
    Check out more at <a href="https://rxjs.dev/guide/operators" target="_new">https://rxjs.dev/guide/operators</a>
    <br/><br/>
    Another interesting thing from rxjs is <a 
    href="https://rxjs.dev/guide/subject#:~:text=What%20is%20a%20Subject%3F%20An%20RxJS%20Subject%20is,independent%20execution%20of%20the%20Observable%29%2C%20Subjects%20are%20multicast."
    target="_new">
    rxjs subjects</a>



  </div>

</div> 
