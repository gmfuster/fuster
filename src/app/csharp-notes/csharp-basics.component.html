<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">C# notes - Basics</h2>  
    <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
    <h4 class="CenterMe">You can type the C# code  
      <a class="CenterMe" href="https://replit.com/languages/csharp" target="_new">on replit.com</a> 
      to see how it works <br/>
   
    </h4>
  
    <br/>
                    
  
    <code><strong><u>null coalescing operator</u></strong></code><br /><br/>
    <pre>
        <code >
            class Program &lbrace;
            &nbsp;static void Main(string[] args) &lbrace;
                &nbsp; &nbsp;    string theString = "hello";
                &nbsp; &nbsp;    string theOtherString = null;
                &nbsp; &nbsp;    Console.WriteLine(<b>theString ?? "Just Me"</b>); //hello
                &nbsp; &nbsp;    Console.WriteLine(theOtherString ?? "Just Me");//Just Me
                &nbsp; &rbrace;
             &rbrace;
        </code>
    </pre>
   

    <code><strong><u>operator overloading</u></strong></code><br /><br/>
    This example is silly but it's just to illustrate how this works.  We have a clas SomeObj, and it has a method for the + of objects of that class:<br/>
    <pre>
        <code >
            ...
            public static SomeObj operator +(SomeObj o1, SomeObj o2)
            &lbrace;
            &nbsp; SomeObj newO = new SomeObj("");
            &nbsp;  newO.TheThing = o1.TheThing + "-" + o2.TheThing;
            &nbsp;  return newO;
            &rbrace;
            //to use 
            SomeObj obj1 = new SomeObj("hey");
            SomeObj obj2 = new SomeObj("helloooo");
            Console.WriteLine( (obj1 + obj2).TheThing);
        </code>
    </pre>  
    <br/>
    <img width="100%" src="assets\images\csharp\opoverloading1.png" alt="operator overloading" /><br/><br/>

    <code><strong><u>keywords as variables</u></strong></code><br /><br/>
    <pre>
        <code>
            using System;

            &nbsp;class Program &lbrace;    

                &nbsp;&nbsp;   static void Main(string[] args) &lbrace;
                    &nbsp;&nbsp;  <b>string @if = "using if as a variable";</b>
                    &nbsp;&nbsp;  Console.WriteLine (@if);
                    &nbsp;  &rbrace;
            &rbrace;
        </code>
    </pre>

    <code><strong><u>Ignore special chars</u></strong></code><br /><br/>

    <pre>
        <code>
            Console.WriteLine(@"blah blah \n \\hey ");//will print that same string
        </code>
    </pre>
    <br/>

    <code><strong><u>format strings with variables</u></strong></code><br /><br/>
    <pre>
        <code>
            string fillIt = "Michael";
            <b>Console.WriteLine($"My name is &lbrace;fillIt&rbrace;");</b>
            //the one below uses C so it will print with currency format:
            decimal amount = 8.94m;
            <b>Console.WriteLine($"My amount is &lbrace;amount:C&rbrace;");</b>//My amount is $8.94
        </code>
    </pre>
    <br/>

    <code><strong><u>params argument</u></strong></code><br /><br/>
    the params argument has to be the last one <br/>
    <pre>
        <code>
            class Program &lbrace;    

            &nbsp;  public static void SomeMethod(Int32 i, string s, <b> params string[] words</b>)&lbrace;
            &nbsp;  &nbsp;   Console.WriteLine(i);
            &nbsp;  &nbsp;   Console.WriteLine(s);
            &nbsp;  &nbsp;   Console.WriteLine(words.Length);
                &rbrace;
                  
                static void Main(string[] args) &lbrace;
                &nbsp;      SomeMethod(2, "hello",   "I","am","your","father");                  
                &rbrace;
            &rbrace;
        </code>
    </pre>
    Prints <br/>
    <pre>
        <samp>
        2
        hello
        4
        </samp>
    </pre>


    <code><strong><u>Default params</u></strong></code><br /><br/>

    <pre>
        <code>
            public static void SomeMethod(Int32 i, string s, string def1 = "defaulted 1", string def2 = "defaulted 2")&lbrace;  
            &nbsp;  Console.WriteLine(def1);
            &nbsp;  Console.WriteLine(def2);
            &rbrace;
              
            static void Main(string[] args) &lbrace;
            &nbsp;   SomeMethod(2, "hello");
            &nbsp;   SomeMethod(2, "hello", "for 1");
              
            &rbrace;
        </code>
    </pre>
    Prints:<br/>
    <pre>
        <samp>
            defaulted 1
            defaulted 2
            for 1
            defaulted 2
        </samp>
    </pre>

    <br/>
    <code><strong><u>Extension Methods</u></strong></code><br /><br/>

    Extension methods have to be created, for a type, in a non-generic static class.  That is why I'm changing the class program to be static.  The 
    use of this indicates the one that will be the string that has the method.<br/>

    <pre>
        <code>
            using System;

            public static class Program &lbrace;   
            
                public static bool LenGreaterThan6 (<b>this</b> string s)&lbrace;
                &nbsp;return s.Length > 6;
                &rbrace;
                public static bool LenGreaterThanInput (<b>this</b> string   s, string input)&lbrace;
                &nbsp;return s.Length > input.Length;
                &rbrace;
            
                
                static void Main(string[] args) &lbrace;
                Console.WriteLine("IAm4".LenGreaterThan6());//false
                Console.WriteLine("IAmMuchMoreThan4Or6".LenGreaterThan6());//true
                Console.WriteLine("IAm4".LenGreaterThanInput("theInput"));//false
                Console.WriteLine("IAm4".LenGreaterThanInput("I"));//true
                &rbrace;
            &rbrace;
        </code>
    </pre>


    <br/>
    <code><strong><u>Tuples</u></strong></code><br /><br/>

    We have System.Tuple (reference, the data members are properties) and System.ValueTuple (value, the data members are fields).<br/>

    For the System.tupple:<br/>
    <pre>
        <code>
            using System;

            public static class Program &lbrace;   

                &nbsp;public class Test&lbrace;
                &nbsp;&nbsp;public Tuple&lt;Int32&gt; intT = new Tuple&lt;Int32&gt;(100);
                &nbsp;&nbsp;public Tuple&lt;Int32, string&gt; intStringT = new Tuple&lt;Int32, string&gt;(1,"hey");
                &nbsp;&rbrace;;
        
                &nbsp;static void Main(string[] args) 
                &nbsp;&nbsp;Test t = new Test();
                &nbsp;&nbsp;Console.WriteLine(t.intT.Item1);//100
                &nbsp;&nbsp;Console.WriteLine(t.intStringT.Item2);//hey
                &rbrace;
            &rbrace;
        </code>
    </pre>
    You could also create the tuple this way:<br/>
    <code>
        var intT = Tuple.Create&lt;Int32&gt;(101);
    </code>

    <br/><br/>
    For the System.ValueTuple<br/>
    <pre>
        <code>
            public (Int32, double) intT = (100, 4.5);//has to have more than 1 item.
            public (Int32, string) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.Item1);//100
            Console.WriteLine(t.intStringT.Item2);//hey
        </code>
    </pre>
    You could also name the items:<br/>
    <pre>
        <code>
            public (Int32 i , double d) intT = (100, 4.5);
            public (Int32 i , string s) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.d);//4.5
            Console.WriteLine(t.intStringT.s);//hey
        </code>
    </pre>
    You can use == and != to compare these tuples, but it will compare the values, meaning, the names given to the fields will not matter.<br/>


    <code><strong><u>Generics</u></strong></code><br /><br/>

    
</div>