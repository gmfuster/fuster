<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">C# notes - Basics</h2>      
    <h4 class="CenterMe">You can type the C# code  
      <a class="CenterMe" href="https://replit.com/languages/csharp" target="_new">on replit.com</a> 
      to see how it works <br/>   
    </h4>
      <!--
    <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
        <p>
          <a  href="/csharp-basics/#accessmodifiers">Access Modifiers</a>
        <p>
        <p>
          <a  href="/csharp-basics/#nullcoalesce">Null coalescing</a>
        </p>
        <p>
          <a  href="/csharp-basics/#operatoroverloading">Operator Overloading</a>
        </p>
        <p>
          <a  href="/csharp-basics/#akeywordsasvars">Keywords as variables</a>
        </p>
        <p>
          <a  href="/csharp-basics/#accessmodifiers">Misc.</a>
        </p>
    </div>
      -->
    <!--<div class="PaddedContents">-->
        <p class="HeadingSubTopic">Access Modifiers</p>

        <b>private: </b> Member is accessible only inside its type.<br/>
        <b>internal: </b> Accessible inside the type and any type in the same assembly.<br/>
        <b>protected: </b>Accessible inside the type, and types that inherit from it.<br/>
        <b>public: </b>Accessible everywhere.<br/>
        <b>internal protected: </b>Accessible inside the type, same assembly, and types that inherit from it. <br/>
        <b>private protected: </b>Accesible inside the type, and any inherited type that is IN the same assembly.<br/>
        
        <p class="HeadingSubTopic">null coalescing operator</p>
        <pre>
            <code >
                class Program &lbrace;
                &nbsp;static void Main(string[] args) &lbrace;
                    &nbsp; &nbsp;    string theString = "hello";
                    &nbsp; &nbsp;    string theOtherString = null;
                    &nbsp; &nbsp;    Console.WriteLine(<b>theString ?? "Just Me"</b>); //hello
                    &nbsp; &nbsp;    Console.WriteLine(theOtherString ?? "Just Me");//Just Me
                    &nbsp; &rbrace;
                &rbrace;
            </code>
        </pre>
    
        
        <p class="HeadingSubTopic">operator overloading</p>
        This example is silly but it's just to illustrate how this works.  We have a clas SomeObj, and it has a method for the + of objects of that class:<br/>
        <pre>
            <code >
                ...
                public static SomeObj operator +(SomeObj o1, SomeObj o2)
                &lbrace;
                &nbsp; SomeObj newO = new SomeObj("");
                &nbsp;  newO.TheThing = o1.TheThing + "-" + o2.TheThing;
                &nbsp;  return newO;
                &rbrace;
                //to use 
                SomeObj obj1 = new SomeObj("hey");
                SomeObj obj2 = new SomeObj("helloooo");
                Console.WriteLine( (obj1 + obj2).TheThing);
            </code>
        </pre>  
        <br/>
        <img width="100%" src="assets\images\csharp\opoverloading1.png" alt="operator overloading" /><br/><br/>
        
        <p class="HeadingSubTopic">keywords as variables</p>
        <pre>
            <code>
                using System;

                &nbsp;class Program &lbrace;    

                    &nbsp;&nbsp;   static void Main(string[] args) &lbrace;
                        &nbsp;&nbsp;  <b>string @if = "using if as a variable";</b>
                        &nbsp;&nbsp;  Console.WriteLine (@if);
                        &nbsp;  &rbrace;
                &rbrace;
            </code>
        </pre>
        
        <p class="HeadingSubTopic">Ignore/use special chars</p>

        <pre>
            <code>
                Console.WriteLine(@"blah blah \n \\hey ");//will print that same string

                Console.WriteLine("Hello tab coming up \t see?"); //will print a tab after up

                Console.WriteLine("c:\totals"); // prints c:      otals

                Console.WriteLine("c:\\totals"); // prints c:\totals
                
            </code>
        </pre>
        <br/>
        
        <p class="HeadingSubTopic">format strings with variables</p>
        <pre>
            <code>
                string fillIt = "Michael";
                <b>Console.WriteLine($"My name is &lbrace;fillIt&rbrace;");</b>
                //the one below uses C so it will print with currency format:
                decimal amount = 8.94m;
                <b>Console.WriteLine($"My amount is &lbrace;amount:C&rbrace;");</b>//My amount is $8.94

                int i = 10;
                int j = 20;

                Console.WriteLine( format: "Number i is &lbrace;0&rbrace; and number 2 is &lbrace;1&rbrace;", 	arg0:i, arg1:j);
                //prints Number i is 10 and number 2 is 20

                private const string _name = "Michael";
                private const string _lname = "Jackson";
                private const string _fullName =  $"&lbrace;_name&rbrace;&lbrace;_lname&rbrace;"; // in console it would be Michael Jackson.

                Console.WriteLine(String.Format("The current price is &lbrace;0&rbrace; per ounce.", 100));

                //the -10 and the 6 indicate the alignment of the argument.
                //hardcoding the values here, instead of using variables for simplicity
                Console.WriteLine(   format: "&lbrace;0,-10&rbrace; &lbrace;1,6&rbrace;",   arg0: "Name",   arg1: "Count");
                Console.WriteLine(  format: "&lbrace;0, -10&rbrace; &lbrace;1, 6:N0&rbrace;",    arg0: "Bananas",    arg1: 5);
                Console.WriteLine(  format: "&lbrace;0, -10&rbrace; &lbrace;1, 6:N0&rbrace;",   arg0: "Apples",   arg1: 12);
            </code>
        </pre>
        <br/>
        Use double instead of decimal when accuracy is not important, especially when comparing numbers.<br/>

        
        <p class="HeadingSubTopic">Some little things</p>
        <pre>
            <code>
                int i = 10_123;
                Console.WriteLine(i); //prints number 10123
                Console.WriteLine( $"Number is &lbrace;i:C&rbrace;");//prints $10,123.00

                checked&lbrace;
                    //code that may result in an overflow, use the checked so we know if this happens, instead of it being ignored.
                &rbrace;
                //Also have the checked code inside a try catch so we can do something if the exception happens

                string  Method1(int i)
                &lbrace;
                    if (i == 1)
                    &lbrace;
                        return "One";
                    &rbrace;else if (i == 2)
                    &lbrace;
                        return "Two";
                        &rbrace;
                    else
                    &lbrace;
                        return "Something Else";
                        &rbrace;
                        &rbrace;

                static string Method2(int i) =>
                    i switch
                    &lbrace;
                        1 => "One", // what it will return
                        2 =>"Two",
                        _ => "Something Else"
                        &rbrace;;
            </code>
        </pre>
        C# has const and read only fields.  Const values have to be known at compile time, while read only fields can be set in the constructor.  Declare in the class, 
        set it in the constructor.<br/>
        With c#11 we have a <b>required</b> keyword: public required string Email &lbrace; get; set; &rbrace;.  If we do this, when we instantiate the class with the fields 
        marked as required, we will have to give values for them or we will get a compiler error.<br/><br/>
        We can have properties that can be instatiated once but not afterwards, for that we use the <b>init</b> keyword:<br/>
        <pre>
            <code>
                //have this property in class SomeClass.
                public string someS &lbrace; get; <b>init;</b> &rbrace;
                ...
                //the 2 lines below will <b>not compile</b>
                SomeClass theClass = new SomeClass();
                theClass.someS = "hey";
                ...
                //but the below <b>will compile</b> and print hey, but it cannot be set again
                SomeClass theClass = new()
                &lbrace;
                    someS = "hey" //separate more with commas
                &rbrace;;
            </code>
        </pre>


        
        <p class="HeadingSubTopic">params argument</p>
        the params argument has to be the last one <br/>
        <pre>
            <code>
                class Program &lbrace;    

                &nbsp;  public static void SomeMethod(Int32 i, string s, <b> params string[] words</b>)&lbrace;
                &nbsp;  &nbsp;   Console.WriteLine(i);
                &nbsp;  &nbsp;   Console.WriteLine(s);
                &nbsp;  &nbsp;   Console.WriteLine(words.Length);
                    &rbrace;
                    
                    static void Main(string[] args) &lbrace;
                    &nbsp;      SomeMethod(2, "hello",   "I","am","your","father");                  
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        Prints <br/>
        <pre>
            <samp>
            2
            hello
            4
            </samp>
        </pre>

        
        <p class="HeadingSubTopic">Default params</p>

        <pre>
            <code>
                public static void SomeMethod(Int32 i, string s, string def1 = "defaulted 1", string def2 = "defaulted 2")&lbrace;  
                &nbsp;  Console.WriteLine(def1);
                &nbsp;  Console.WriteLine(def2);
                &rbrace;
                
                static void Main(string[] args) &lbrace;
                &nbsp;   SomeMethod(2, "hello");
                &nbsp;   SomeMethod(2, "hello", "for 1");
                
                &rbrace;
            </code>
        </pre>
        Prints:<br/>
        <pre>
            <samp>
                defaulted 1
                defaulted 2
                for 1
                defaulted 2
            </samp>
        </pre>

        <p class="HeadingSubTopic">Default params</p>
        Parameters can be passed by value (default), by reference (<b>ref</b>), and as an <b>out</b> parameter.
        <br/>    
        <p class="HeadingSubTopic">Extension Methods</p>

        Extension methods have to be created, for a type, in a non-generic static class.  That is why I'm changing the class program to be static.  The 
        use of this indicates the one that will be the string that has the method.<br/>

        <pre>
            <code>
                using System;

                public static class Program &lbrace;   
                
                    public static bool LenGreaterThan6 (<b>this</b> string s)&lbrace;
                    &nbsp;return s.Length > 6;
                    &rbrace;
                    public static bool LenGreaterThanInput (<b>this</b> string   s, string input)&lbrace;
                    &nbsp;return s.Length > input.Length;
                    &rbrace;
                
                    
                    static void Main(string[] args) &lbrace;
                    Console.WriteLine("IAm4".LenGreaterThan6());//false
                    Console.WriteLine("IAmMuchMoreThan4Or6".LenGreaterThan6());//true
                    Console.WriteLine("IAm4".LenGreaterThanInput("theInput"));//false
                    Console.WriteLine("IAm4".LenGreaterThanInput("I"));//true
                    &rbrace;
                &rbrace;
            </code>
        </pre>


        <br/>    
        <p class="HeadingSubTopic">Tuples</p>

        We have System.Tuple (reference, the data members are properties) and System.ValueTuple (value, the data members are fields).<br/>

        For the <b>System.tupple:</b><br/>
        <pre>
            <code>
                using System;

                public static class Program &lbrace;   

                    &nbsp;public class Test&lbrace;
                    &nbsp;&nbsp;public Tuple&lt;Int32&gt; intT = new Tuple&lt;Int32&gt;(100);
                    &nbsp;&nbsp;public Tuple&lt;Int32, string&gt; intStringT = new Tuple&lt;Int32, string&gt;(1,"hey");
                    &nbsp;&rbrace;;
            
                    &nbsp;static void Main(string[] args) 
                    &nbsp;&nbsp;Test t = new Test();
                    &nbsp;&nbsp;Console.WriteLine(t.intT.Item1);//100
                    &nbsp;&nbsp;Console.WriteLine(t.intStringT.Item2);//hey
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        You could also create the tuple this way:<br/>
        <code>
            var intT = Tuple.Create&lt;Int32&gt;(101);
        </code>

        <br/><br/>
        For the <b>System.ValueTuple</b><br/>
        <pre>
            <code>
                public (Int32, double) intT = (100, 4.5);//has to have more than 1 item.
                public (Int32, string) intStringT = (1,"hey");
                ...
                Console.WriteLine(t.intT.Item1);//100
                Console.WriteLine(t.intStringT.Item2);//hey
            </code>
        </pre>
        You could also name the items:<br/>
        <pre>
            <code>
                public (Int32 i , double d) intT = (100, 4.5);
                public (Int32 i , string s) intStringT = (1,"hey");
                ...
                Console.WriteLine(t.intT.d);//4.5
                Console.WriteLine(t.intStringT.s);//hey
            </code>
        </pre>
        You can use == and != to compare these tuples, but it will compare the values, meaning, the names given to the fields will not matter.<br/>

        We could also have this code:<br/>
        <pre>
            <code>
                public (int, string) GiveATuple() //return the tuple (int, string)
                &lbrace;
                return (1, "one");
                &rbrace;
                ...
                (int, string) t = GiveATuple();
                Console.WriteLine(t.Item1); //as before, we have Item1, Item2 etc		        
            </code>
        </pre>
        Or we can also name what gets returned.  Notice we name the return, but also the return of the method itself.
        <pre>
            <code>
                public (int <b>num</b>, string <b>str</b>) GiveATuple()	        
                &lbrace;
                    return (<b>num:</b> 1, <b>str:</b> "one");
                &rbrace;
                ...
                var t = GiveATuple();
                Console.WriteLine(t.<b>str</b>);	        
            </code>
        </pre>
        <b>Deconstructing Tuples</b><br/>
        Using the same GiveATuple() as above, we could also do:
        <pre>
            <code>
                (int numero, string <b>cadena</b>)= GiveATuple();
                Console.WriteLine(<b>cadena</b>);		
            </code>
        </pre>

        <br/>    
        <p class="HeadingSubTopic">Generics</p>

        <pre>
            <code>
                public static class Program &lbrace;   

                    public class <b>TestGen&lt;T&gt;</b>&lbrace;
                
                    public bool isItNull(<b>T theT</b>)&lbrace;
                        return theT == null;
                    &rbrace;
                    &rbrace;
                    
                    static void Main(string[] args) &lbrace;    
                    TestGen<b>&lt;string&gt;</b> t = new TestGen<b>&lt;string&gt;</b>();
                    TestGen&lt;Int32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                    Console.WriteLine(t.isItNull("hello"));//false
                    Console.WriteLine(t2.isItNull(3));//false
                    Console.WriteLine(t2.isItNull(null));//true
                    &rbrace;            
            </code>
        </pre>
        <pre>
            <code>
                public static class Program &lbrace;   

                    public class TestGen&lt;T&gt;&lbrace;
                
                    <b>public T Data &lbrace; get; set; &rbrace;</b>
                    &rbrace;
                    
                    static void Main(string[] args) &lbrace;     
                    TestGen&lt;string&gt; t = new TestGen&lt;string&gt;();
                    t.Data = "hello";
                    TestGen&lt;nt32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                    t2.Data = 48;
                    Console.WriteLine(t.Data);//false
                    Console.WriteLine(t2.Data);//false      
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        Trying this instead would have given an error because an Int32? is expected: <b>t2.Data = "48";</b><br/>
        A generic class can be a base class to other generic or non-generic classes or abstract classes.<br/>
        You can have more than one type for a generic class (T, U ...)<br/>
        You can also indicate what the T can be, with something like this<br/>
        <pre>
            <code>
                public class TestGen&lt;T&gt; where T: WhateverClassOrType&lbrace;
                public class TestGen&lt;T,U&gt; where T: WhateverClassOrType where U:WhateverClassOrType&lbrace;
            </code>
        </pre>
        Above, we could also be using a class and an interface for each where.<br/>
        <br/>
        
        

        
        <p class="HeadingSubTopic">Enums</p>

        Regular way to use an Enum<br/>
        <pre>
            <code>
                public enum SomeEnum&lbrace;
                    first,
                    second,
                    third
                &rbrace;
            </code>
        </pre>
        Could also do this.  Here not making much sense but just showing you can change the values for the items<br/>
        <pre>
            <code>
                public enum SomeEnum&lbrace;
                    first = 11,
                    second = 12,
                    third = 13
                &rbrace;
            </code>
        </pre>
        With the above code, if we were to use the enum, we could do this<br/>
        <pre>
            <code>
                SomeEnum e = SomeEnum.first;
                Console.WriteLine((int)e); // will print 11.
            </code>
        </pre>

        If we don't specify anything, the first element will start at zero.<br/>
        Usually the values are using int values, but we can also change it to use something else.  Like byte to use less memory.<br/>

        We can combine multiple values by using Flags.<br/>
        <pre>
            <code>
                [System.Flags]
                public enum SomeBinaryEnum:Byte&lbrace;
                    one = 0b0001,//1
                    two = 0b0010,//2
                    three = 0b0011//3
                &rbrace;
            </code>
        </pre>
        With the above enum:<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;
                    SomeBinaryEnum e = SomeBinaryEnum.one;
                    Console.WriteLine((Byte)e); //prints 1
                    Console.WriteLine(e);  //prints One
                &rbrace;
            </code>
        </pre>

        But on the above enum, one and two together will give the same as 3, so if we want to use flags, we should choose values that don't overlap:<br/>
        <pre>
            <code>
                [System.Flags]
                public enum SomeBinaryEnum:Byte&lbrace;
                    one = 0b0001,
                    two = 0b0010,
                    <b>four = 0b0100</b>
                &rbrace;
            </code>
        </pre>
        With the above code, we can now do this:<br/>
        <pre>
            <code>
                SomeBinaryEnum e = SomeBinaryEnum.one |   SomeBinaryEnum.two; //values 0b0001 and 0b0010 , or 0b0011 (3)
                Console.WriteLine((Byte)e); // prints 3
                Console.WriteLine(e); <b>//prints one, two.</b>
            </code>
        </pre>
        Keep in mind that the type you can use for the enum will depend on how many values you are going to need.<br/>


        <p class="HeadingSubTopic">Records</p>
        Beginning with C#9 for a reference type, then with C#10 we can have <b>record class</b> for reference and <b>record struct</b> for value type.  Not 
        indicating class or struct will make it by reference.<br/>
        Records can be mutable (get and set) but they are usually used for immutable models.<br/>
        Positional properties are immutable in a record class and a readonly record struct. They're mutable in a record struct.<br/>
        <pre>
            <code>
                //reference because we are not saying struct (class by default)
                //PersonA gets the values assigned with the contructor, based in the order.
                public record PersonA(string FirstName, string LastName);
                //PersonB, just create and then assign by name
                public record PersonB
                &lbrace;	
                    public string FirstName &lbrace; get; set; &rbrace; = default!;
                    public string LastName &lbrace; get; set; &rbrace; = default!;
                &rbrace;;

                public void SomeMethod()
                &lbrace;
                    PersonA persona = new("Nancy", "Davoli");
                    PersonB personb = new();
                    personb.FirstName = "Nancia";
                    personb.LastName = "Davolia";
                    Console.WriteLine(persona.ToString());
                    Console.WriteLine(personb.ToString());
                &rbrace;
            </code>
        </pre>
        You can also have it declared with the constructor but change the accessibility like this:
        <pre>
            <code>
                public record PersonC(string FirstName, string LastName, string Id)
                &lbrace;
                    internal string Id &lbrace; get; init; &rbrace; = Id
                &rbrace;
                ...
                PersonC personc = new PersonC("Mark", "Knight", "1212");
                Console.WriteLine(personc.ToString()); // prints Mark, Knight
                Console.WriteLine(personc.Id); //prints 1212
            </code>
        </pre>
        Regarding the printing of Mark and Knight above, but not 1212: Record types have a compiler-generated ToString method that displays 
        the names and values of <b>public</b> properties and fields. <br/>
        You could also just have a few properties with its constructor and other properties inside (not positional ones)<br/>
        A positional record and a positional readonly record struct declare init-only properties. A positional record struct declares read-write properties. 
        You can override either of those defaults<br/>
        After initialization, you can't change the value of value-type properties or the reference of reference-type properties. 
        However, the data that a reference-type property refers to can be changed.<br/>
        For class types, two objects are equal if they refer to the same object in memory.<br/>
        For struct types, two objects are equal if they are of the same type and store the same values.<br/>
        For record types, including record struct and readonly record struct, two objects are equal if they are of the same type and store the same values.<br/>
        <br/>
        If you need to copy an instance with some modifications, you can use a with expression to achieve nondestructive mutation. A with expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.
        <pre>
            <code>
                public record PersonA(string FirstName, string LastName);
                ...
                PersonA persona = new("Nancy", "Davoli");
                PersonA persona2 = persona with &lbrace; FirstName = "John" &rbrace;;

                //prints
                //PersonA &lbrace; FirstName = Nancy, LastName = Davoli &rbrace;
                //PersonA &lbrace; FirstName = John, LastName = Davoli &rbrace;
            </code>
        </pre>
        The result of a with expression is a shallow copy, which means that for a reference property, 
        only the reference to an instance is copied. Both the original record and the copy end up with a reference to the same instance.<br/>
        A record can inherit from another record. However, a record can't inherit from a class, and a class can't inherit from a record.<br/>
        <pre>
            <code>
                public record Teacher(string FirstName, string LastName, int Grade): Person(FirstName, LastName);
            </code>
        </pre>
        For two record variables to be equal, the run-time type must be equal (not just the values, also the type).
        
        <p class="HeadingSubTopic">Pattern Matches - Switch</p>
        This is a bit of pattern matches with a focus on switch but not just that.<br/>
        Imagine we have a class Fruit and a class Apple like this:
        <pre>
            <code>
                public class Fruit
                &lbrace;
                    public string? Name &lbrace; get; set; &rbrace;
                    public string? Color &lbrace; get; set; &rbrace;
                &rbrace;
                public class Apple:Fruit
                &lbrace;
                    public string? Type &lbrace; get; set; &rbrace;
                &rbrace;
                ...
                Fruit fruit = new Fruit();	
                Apple apple = new Apple();
                apple.Name = "Apple";
                apple.Color = "Green";
                apple.Type = "Fuji";
                ...
                fruit = apple;
                //to check before we can assume that the fruit is an apple
                <b>if (fruit.GetType() == typeof(Apple) && ((Apple)fruit).Type == "Fuji")</b>
                &lbrace;
                    Console.WriteLine("the fruit is an Apple and it's a Fuji Apple");
                &rbrace;

                //We could also have done.
                <b>if (fruit is Apple)</b>            
            </code>
        </pre>
        Something else we can do, starting with C#7.<br/>
        <pre>
            <code>
                Fruit fruit = new Fruit();	
                
                Apple apple = new Apple();
                apple.Name = "Apple";
                apple.Color = "Green";
                apple.Type = "Fuji";

                Apple apple2 = new Apple();
                apple2.Name = "Apple";
                apple2.Color = "Red";
                apple2.Type = "Awesome";

                fruit = apple;

                switch (fruit)
                &lbrace;
                    //theapple or whatever you want, just something so we can reference inside de code.
                    <b>case Apple theapple:</b>
                        Console.WriteLine(theapple.Name);
                        Console.WriteLine(theapple.Color);
                        Console.WriteLine(theapple.Type);
                        break;
                    default:
                        break;
                &rbrace;

                //the above will print Apple, Green, Fuji.
                //if the fruit above was not assigned an Apply type, it would go to the default.
            </code>
        </pre>

        Besides the type above, you can also match on some properties of the object<br/>
        <pre>
            <code>
                Fruit fruit = new Fruit();

                Apple apple = new Apple();
                apple.Name = "Apple";
                apple.Color = "Green";
                apple.Type = "Fuji";

                Apple apple2 = new Apple();
                apple2.Name = "Apple";
                apple2.Color = "Red";
                apple2.Type = "Awesome";

                fruit = apple;

                switch (fruit)
                &lbrace;
                    //theapple or wahtever you want, just something so we can reference inside de code.
                    //we are getting a warning because Color could be null, but just for what we are doing, we know it won't be.
                    //our fruit is set to the Green apple, so this will go to not the apple or not red.
                    <b>case Apple theapple when theapple.Color.Equals("Red"):</b>
                        Console.WriteLine(theapple.Name);
                        Console.WriteLine(theapple.Color);
                        Console.WriteLine(theapple.Type);
                        break;
                    default:
                        Console.WriteLine("not the apple or not read");
                        break;
                &rbrace;
            </code>
        </pre>
        With C#8 we also have a switch expression instead of the typical switch statement as above.  With the classes and assignments as above:<br/>
        <pre>
            <code>
                var <b>theFruit</b> = fruit switch
                &lbrace;
                    Apple <b>_ =></b> "This is an apple",
                    <b>_ =></b> "This is not an apple"
                &rbrace;
                Console.WriteLine(<b>theFruit</b>);
            </code>
        </pre>
        We can also do something like this <br/>
        <pre>
            <code>
                public class Fruit
                &lbrace;
                    public string? Name &lbrace; get; set; &rbrace;
                    public string? Color &lbrace; get; set; &rbrace;
                    public FruitType? FruitType &lbrace; get; set; &rbrace;

                    //need to have this here to be able to use the switch this way
                    public void <b>Deconstruct(out string? name, out string? color, out FruitType? ft)</b>
                    &lbrace;
                        name = Name;
                        color = Color;
                        ft = FruitType;
                    &rbrace;
                &rbrace;

                public class FruitType
                &lbrace;
                    public string? TheType &lbrace; get; set; &rbrace;
                &rbrace;

                Fruit fruit = new Fruit();
                fruit.Name = "Orange";
                fruit.Color = "Orange";
                <b>fruit.FruitType = new FruitType();</b>
                fruit.FruitType.TheType = "Citric";

                //need the Deconstruct method in the class to be able to do this.  Otherwise gets an error.
                <b>var result = fruit switch</b>
                &lbrace;
                    <b>Fruit("Orange", "Orange", null) => "Orange with no type",</b>
                    Fruit("Orange", "Orange", _) => "Orange",
                    _ => "Different"
                &rbrace;
                Console.WriteLine(result);//prints Orange
                //If we don't have a FruitType we will get  "orange with no type"
                //if the color was set to red, we would get Different.
            </code>
        </pre>
        We could also have something like this to check on the FruitType itself (note this doesn't cover all possible cases we can check for)
        <pre>
            <code>
                var result = fruit switch
                &lbrace;
                    <b>&lbrace; FruitType: &lbrace; TheType: "Citric" &rbrace;&rbrace; => "Citric",</b>
                    &lbrace; FruitType: null &rbrace; => "no type",		
                &rbrace;

                <b>//add this so we won't get an exception for a case that is not covered.
                _ => null,</b>
            </code>
        </pre>
        We can also use this on tuples, this example from the MS docs.
        <pre>
            <code>
                var newState = (state, operation, key.IsValid) switch
                &lbrace;
                  (State.Opened, Operation.Close, _)      => State.Closed,
                  (State.Opened, Operation.Open, _)       => throw new Exception(
                    "Can't open an opened door"),
                  (State.Opened, Operation.Lock, true)    => State.Locked,
                  (State.Locked, Operation.Open, true)    => State.Opened,
                  (State.Closed, Operation.Open, false)   => State.Locked,
                  (State.Closed, Operation.Lock, true)    => State.Locked,
                  (State.Closed, Operation.Close, _)      => throw new Exception(
                    "Can't close a closed door"),
                      _ => state
                &rbrace;;
            </code>
        </pre>
        With C#9, for a when in the switch were you have more than one condition, you could do this:
        <pre>
            <code>
                //from this
                Developer dev when dev.YearOfBirth >= 1980 && dev.YearOfBirth &lt;= 1989 

                //to this
                Developer dev when dev.YearOfBirth <b>is</b> &gt;= 1980 <b>and</b> &lt;= 1989

                //could also do
                Developer &lbrace; YearOfBirth: &gt;= 1980 and &lt;= 1989 &rbrace; dev
            </code>
        </pre>
    
        <br/>
        Another example with c#8<br/>
        <pre>
            <code>
                ...
                Fruit fruit2 = new Fruit();
                fruit2.Name = "Apple";
                fruit2.price = 200;
                
                var result = <b>fruit2</b> switch
                &lbrace;
                    <b>Fruit</b> f when f.price &lt;=100	<b>=&gt;</b> "Less than 100",
                    Fruit f when f.price &lt;= 200 =&gt; "Less than 200",
                    <b>Fruit =&gt;</b> "something else"
                &rbrace;;
                Console.WriteLine(result);// prints Less than 200
            </code>
        </pre>
        The same thing with C#9, in the switch itself<br/>
        <pre>
            <code>
                var result = fruit2 switch
                &lbrace;
                    <b>Fruit f => f.price switch</b>
                    &lbrace;
                        <b>&lt;= 100 =&gt; "Less than 100",</b>
                        &lt;= 200 =&gt; "Less than 200",
                        <b>_ =&gt;</b> "something else"
                    &rbrace;
                    //we could also have other types here checking for other things, inside of the same fruit2 switch (provided types are compatible)
                &rbrace;;
            </code>
        </pre>
        There is more than what is mentioned above, so check the documentation for more and for how to do it, or understand something you see.
    <!--</div>  -->
</div>