<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">C# notes - Basics</h2>  
    <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
    <h4 class="CenterMe">You can type the C# code  
      <a class="CenterMe" href="https://replit.com/languages/csharp" target="_new">on replit.com</a> 
      to see how it works <br/>
   
    </h4>
  
    <br/>
                    
  
    <code><strong><u>null coalescing operator</u></strong></code><br /><br/>
    <pre>
        <code >
            class Program &lbrace;
            &nbsp;static void Main(string[] args) &lbrace;
                &nbsp; &nbsp;    string theString = "hello";
                &nbsp; &nbsp;    string theOtherString = null;
                &nbsp; &nbsp;    Console.WriteLine(<b>theString ?? "Just Me"</b>); //hello
                &nbsp; &nbsp;    Console.WriteLine(theOtherString ?? "Just Me");//Just Me
                &nbsp; &rbrace;
             &rbrace;
        </code>
    </pre>
   

    <code><strong><u>operator overloading</u></strong></code><br /><br/>
    This example is silly but it's just to illustrate how this works.  We have a clas SomeObj, and it has a method for the + of objects of that class:<br/>
    <pre>
        <code >
            ...
            public static SomeObj operator +(SomeObj o1, SomeObj o2)
            &lbrace;
            &nbsp; SomeObj newO = new SomeObj("");
            &nbsp;  newO.TheThing = o1.TheThing + "-" + o2.TheThing;
            &nbsp;  return newO;
            &rbrace;
            //to use 
            SomeObj obj1 = new SomeObj("hey");
            SomeObj obj2 = new SomeObj("helloooo");
            Console.WriteLine( (obj1 + obj2).TheThing);
        </code>
    </pre>  
    <br/>
    <img width="100%" src="assets\images\csharp\opoverloading1.png" alt="operator overloading" /><br/><br/>

    <code><strong><u>keywords as variables</u></strong></code><br /><br/>
    <pre>
        <code>
            using System;

            &nbsp;class Program &lbrace;    

                &nbsp;&nbsp;   static void Main(string[] args) &lbrace;
                    &nbsp;&nbsp;  <b>string @if = "using if as a variable";</b>
                    &nbsp;&nbsp;  Console.WriteLine (@if);
                    &nbsp;  &rbrace;
            &rbrace;
        </code>
    </pre>

    <code><strong><u>Ignore special chars</u></strong></code><br /><br/>

    <pre>
        <code>
            Console.WriteLine(@"blah blah \n \\hey ");//will print that same string
        </code>
    </pre>
    <br/>

    <code><strong><u>format strings with variables</u></strong></code><br /><br/>
    <pre>
        <code>
            string fillIt = "Michael";
            <b>Console.WriteLine($"My name is &lbrace;fillIt&rbrace;");</b>
            //the one below uses C so it will print with currency format:
            decimal amount = 8.94m;
            <b>Console.WriteLine($"My amount is &lbrace;amount:C&rbrace;");</b>//My amount is $8.94
        </code>
    </pre>
    <br/>

    <code><strong><u>params argument</u></strong></code><br /><br/>
    the params argument has to be the last one <br/>
    <pre>
        <code>
            class Program &lbrace;    

            &nbsp;  public static void SomeMethod(Int32 i, string s, <b> params string[] words</b>)&lbrace;
            &nbsp;  &nbsp;   Console.WriteLine(i);
            &nbsp;  &nbsp;   Console.WriteLine(s);
            &nbsp;  &nbsp;   Console.WriteLine(words.Length);
                &rbrace;
                  
                static void Main(string[] args) &lbrace;
                &nbsp;      SomeMethod(2, "hello",   "I","am","your","father");                  
                &rbrace;
            &rbrace;
        </code>
    </pre>
    Prints <br/>
    <pre>
        <samp>
        2
        hello
        4
        </samp>
    </pre>


    <code><strong><u>Default params</u></strong></code><br /><br/>

    <pre>
        <code>
            public static void SomeMethod(Int32 i, string s, string def1 = "defaulted 1", string def2 = "defaulted 2")&lbrace;  
            &nbsp;  Console.WriteLine(def1);
            &nbsp;  Console.WriteLine(def2);
            &rbrace;
              
            static void Main(string[] args) &lbrace;
            &nbsp;   SomeMethod(2, "hello");
            &nbsp;   SomeMethod(2, "hello", "for 1");
              
            &rbrace;
        </code>
    </pre>
    Prints:<br/>
    <pre>
        <samp>
            defaulted 1
            defaulted 2
            for 1
            defaulted 2
        </samp>
    </pre>

    <br/>
    <code><strong><u>Extension Methods</u></strong></code><br /><br/>

    Extension methods have to be created, for a type, in a non-generic static class.  That is why I'm changing the class program to be static.  The 
    use of this indicates the one that will be the string that has the method.<br/>

    <pre>
        <code>
            using System;

            public static class Program &lbrace;   
            
                public static bool LenGreaterThan6 (<b>this</b> string s)&lbrace;
                &nbsp;return s.Length > 6;
                &rbrace;
                public static bool LenGreaterThanInput (<b>this</b> string   s, string input)&lbrace;
                &nbsp;return s.Length > input.Length;
                &rbrace;
            
                
                static void Main(string[] args) &lbrace;
                Console.WriteLine("IAm4".LenGreaterThan6());//false
                Console.WriteLine("IAmMuchMoreThan4Or6".LenGreaterThan6());//true
                Console.WriteLine("IAm4".LenGreaterThanInput("theInput"));//false
                Console.WriteLine("IAm4".LenGreaterThanInput("I"));//true
                &rbrace;
            &rbrace;
        </code>
    </pre>


    <br/>
    <code><strong><u>Tuples</u></strong></code><br /><br/>

    We have System.Tuple (reference, the data members are properties) and System.ValueTuple (value, the data members are fields).<br/>

    For the System.tupple:<br/>
    <pre>
        <code>
            using System;

            public static class Program &lbrace;   

                &nbsp;public class Test&lbrace;
                &nbsp;&nbsp;public Tuple&lt;Int32&gt; intT = new Tuple&lt;Int32&gt;(100);
                &nbsp;&nbsp;public Tuple&lt;Int32, string&gt; intStringT = new Tuple&lt;Int32, string&gt;(1,"hey");
                &nbsp;&rbrace;;
        
                &nbsp;static void Main(string[] args) 
                &nbsp;&nbsp;Test t = new Test();
                &nbsp;&nbsp;Console.WriteLine(t.intT.Item1);//100
                &nbsp;&nbsp;Console.WriteLine(t.intStringT.Item2);//hey
                &rbrace;
            &rbrace;
        </code>
    </pre>
    You could also create the tuple this way:<br/>
    <code>
        var intT = Tuple.Create&lt;Int32&gt;(101);
    </code>

    <br/><br/>
    For the System.ValueTuple<br/>
    <pre>
        <code>
            public (Int32, double) intT = (100, 4.5);//has to have more than 1 item.
            public (Int32, string) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.Item1);//100
            Console.WriteLine(t.intStringT.Item2);//hey
        </code>
    </pre>
    You could also name the items:<br/>
    <pre>
        <code>
            public (Int32 i , double d) intT = (100, 4.5);
            public (Int32 i , string s) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.d);//4.5
            Console.WriteLine(t.intStringT.s);//hey
        </code>
    </pre>
    You can use == and != to compare these tuples, but it will compare the values, meaning, the names given to the fields will not matter.<br/>

    <br/>
    <code><strong><u>Generics</u></strong></code><br /><br/>

    <pre>
        <code>
            public static class Program &lbrace;   

                public class <b>TestGen&lt;T&gt;</b>&lbrace;
            
                  public bool isItNull(<b>T theT</b>)&lbrace;
                    return theT == null;
                  &rbrace;
                &rbrace;
                  
                static void Main(string[] args) &lbrace;    
                  TestGen<b>&lt;string&gt;</b> t = new TestGen<b>&lt;string&gt;</b>();
                  TestGen&lt;Int32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                  Console.WriteLine(t.isItNull("hello"));//false
                  Console.WriteLine(t2.isItNull(3));//false
                  Console.WriteLine(t2.isItNull(null));//true
                &rbrace;            
        </code>
    </pre>
    <pre>
        <code>
            public static class Program &lbrace;   

                public class TestGen&lt;T&gt;&lbrace;
            
                 <b>public T Data &lbrace; get; set; &rbrace;</b>
                &rbrace;
                  
                static void Main(string[] args) &lbrace;     
                  TestGen&lt;string&gt; t = new TestGen&lt;string&gt;();
                  t.Data = "hello";
                  TestGen&lt;nt32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                  t2.Data = 48;
                  Console.WriteLine(t.Data);//false
                  Console.WriteLine(t2.Data);//false      
                &rbrace;
            &rbrace;
        </code>
    </pre>
    Trying this instead would have given an error because an Int32? is expected: <b>t2.Data = "48";</b><br/>
    A generic class can be a base class to other generic or non-generic classes or abstract classes.<br/>
    You can have more than one type for a generic class (T, U ...)<br/>

    <br/>
    <code><strong><u>InottifyPropertyChanged</u></strong></code><br /><br/>
    When you need to know that a property changed.<br/>

    <img width="100%" src="assets\images\csharp\INotifyPropertyChanged.png" alt="Notify property changed" /><br/><br/>

    A similar example for copy paste:<br/>
    <pre>
        <code>
            using System;
            <b>using System.ComponentModel;</b>

            public static class Program &lbrace;   

                public class WillChangeProperty:<b>INotifyPropertyChanged</b>&lbrace;
                
                    <b>public event PropertyChangedEventHandler PropertyChanged;</b>
                    private string _theData = "";
                    public string TheData &lbrace;
                        get&lbrace;
                        return this._theData ;
                        &rbrace;
                        set&lbrace;
                        this._theData = value;
                        <b>PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(this._theData));</b>
                        &rbrace;            
                    &rbrace;
                    <b>public void WhatToDoOnChange(object sender, PropertyChangedEventArgs e)&lbrace;</b>
                        Console.WriteLine("It changed!");
                    &rbrace;
                &rbrace;
                
                static void Main(string[] args) &rbrace;     
                    WillChangeProperty w = new WillChangeProperty();
                    <b>w.PropertyChanged += w.WhatToDoOnChange;</b>
                    w.TheData = "Hello";
                &rbrace;
            &rbrace;

        </code>
    </pre>

    <br/>
    <br/>
    <code><strong><u>IComparable</u></strong></code><br /><br/>

    Implement it when you want to provide a method to compare your classes.<br/>
    <img width="100%" src="assets\images\csharp\IComparable.png" alt="IComparable" /><br/><br/>

    <pre>
        <code>
            public static class Program &&lbrace;;  

                public class WillCompare:<b>IComparable</b>&lbrace;
                  
                  public string TheData &lbrace;get;set;&rbrace;
                  <b>public int CompareTo(object o)</b>&lbrace;
                    <b>//same=0, o&gt; ret &gt;0, o&lt; ret &lt;0</b>
                    if (((WillCompare)o).TheData.Length == this.TheData.Length)&lbrace;
                      return 0;
                    &rbrace;else if (((WillCompare)o).TheData.Length > this.TheData.Length)&lbrace;
                    return 1;
                    &rbrace;else return -1;
                  &rbrace;
                &rbrace;
                  
                static void Main(string[] args) &lbrace;     
                     WillCompare w1 = new WillCompare();
                     w1.TheData = "hello";
                     WillCompare w2 = new WillCompare();
                     w2.TheData = "helloooo";
                     Console.WriteLine(<b>w1.CompareTo(w2)</b>);//1
                &rbrace;
            &rbrace;
            
        </code>
    </pre>
    <br/>

    Once you have the above, you can sort a list of objects and it will be sorted based on the CompareTo.<br/>
    With the same code as above:<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;     
                WillCompare w1 = new WillCompare();
                 w1.TheData = "hello";
             WillCompare w2 = new WillCompare();
                 w2.TheData = "helloooo";
             WillCompare w3 = new WillCompare();
                 w3.TheData = "hey";
             List&lt;WillCompare&gt; l = new List&lt;WillCompare&gt;();
             l.Add(w1);
             l.Add(w2);
             l.Add(w3);
             l.Sort();
             Console.WriteLine(l[0].TheData);//
             Console.WriteLine(l[1].TheData);//
             Console.WriteLine(l[2].TheData);//
           &rbrace;
        </code>
    </pre>
    <pre>
        <samp>
            helloooo
            hello
            hey
        </samp>
    </pre>
    Change the way you do the CompareTo if you want the sorting to be this way:<br/>
    <pre>
        <samp>
            hey
            hello
            helloooo
        </samp>
    </pre>

</div>