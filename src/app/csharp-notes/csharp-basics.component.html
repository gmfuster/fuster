<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">C# notes - Basics</h2>  
    <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
    <h4 class="CenterMe">You can type the C# code  
      <a class="CenterMe" href="https://replit.com/languages/csharp" target="_new">on replit.com</a> 
      to see how it works <br/>
   
    </h4>
  
    <br/>
                    
  
    <code><strong><u>null coalescing operator</u></strong></code><br /><br/>
    <pre>
        <code >
            class Program &lbrace;
            &nbsp;static void Main(string[] args) &lbrace;
                &nbsp; &nbsp;    string theString = "hello";
                &nbsp; &nbsp;    string theOtherString = null;
                &nbsp; &nbsp;    Console.WriteLine(<b>theString ?? "Just Me"</b>); //hello
                &nbsp; &nbsp;    Console.WriteLine(theOtherString ?? "Just Me");//Just Me
                &nbsp; &rbrace;
             &rbrace;
        </code>
    </pre>
   

    <code><strong><u>operator overloading</u></strong></code><br /><br/>
    This example is silly but it's just to illustrate how this works.  We have a clas SomeObj, and it has a method for the + of objects of that class:<br/>
    <pre>
        <code >
            ...
            public static SomeObj operator +(SomeObj o1, SomeObj o2)
            &lbrace;
            &nbsp; SomeObj newO = new SomeObj("");
            &nbsp;  newO.TheThing = o1.TheThing + "-" + o2.TheThing;
            &nbsp;  return newO;
            &rbrace;
            //to use 
            SomeObj obj1 = new SomeObj("hey");
            SomeObj obj2 = new SomeObj("helloooo");
            Console.WriteLine( (obj1 + obj2).TheThing);
        </code>
    </pre>  
    <br/>
    <img width="100%" src="assets\images\csharp\opoverloading1.png" alt="operator overloading" /><br/><br/>

    <code><strong><u>keywords as variables</u></strong></code><br /><br/>
    <pre>
        <code>
            using System;

            &nbsp;class Program &lbrace;    

                &nbsp;&nbsp;   static void Main(string[] args) &lbrace;
                    &nbsp;&nbsp;  <b>string @if = "using if as a variable";</b>
                    &nbsp;&nbsp;  Console.WriteLine (@if);
                    &nbsp;  &rbrace;
            &rbrace;
        </code>
    </pre>

    <code><strong><u>Ignore special chars</u></strong></code><br /><br/>

    <pre>
        <code>
            Console.WriteLine(@"blah blah \n \\hey ");//will print that same string
        </code>
    </pre>
    <br/>

    <code><strong><u>format strings with variables</u></strong></code><br /><br/>
    <pre>
        <code>
            string fillIt = "Michael";
            <b>Console.WriteLine($"My name is &lbrace;fillIt&rbrace;");</b>
            //the one below uses C so it will print with currency format:
            decimal amount = 8.94m;
            <b>Console.WriteLine($"My amount is &lbrace;amount:C&rbrace;");</b>//My amount is $8.94
        </code>
    </pre>
    <br/>

    <code><strong><u>params argument</u></strong></code><br /><br/>
    the params argument has to be the last one <br/>
    <pre>
        <code>
            class Program &lbrace;    

            &nbsp;  public static void SomeMethod(Int32 i, string s, <b> params string[] words</b>)&lbrace;
            &nbsp;  &nbsp;   Console.WriteLine(i);
            &nbsp;  &nbsp;   Console.WriteLine(s);
            &nbsp;  &nbsp;   Console.WriteLine(words.Length);
                &rbrace;
                  
                static void Main(string[] args) &lbrace;
                &nbsp;      SomeMethod(2, "hello",   "I","am","your","father");                  
                &rbrace;
            &rbrace;
        </code>
    </pre>
    Prints <br/>
    <pre>
        <samp>
        2
        hello
        4
        </samp>
    </pre>


    <code><strong><u>Default params</u></strong></code><br /><br/>

    <pre>
        <code>
            public static void SomeMethod(Int32 i, string s, string def1 = "defaulted 1", string def2 = "defaulted 2")&lbrace;  
            &nbsp;  Console.WriteLine(def1);
            &nbsp;  Console.WriteLine(def2);
            &rbrace;
              
            static void Main(string[] args) &lbrace;
            &nbsp;   SomeMethod(2, "hello");
            &nbsp;   SomeMethod(2, "hello", "for 1");
              
            &rbrace;
        </code>
    </pre>
    Prints:<br/>
    <pre>
        <samp>
            defaulted 1
            defaulted 2
            for 1
            defaulted 2
        </samp>
    </pre>

    <br/>
    <code><strong><u>Extension Methods</u></strong></code><br /><br/>

    Extension methods have to be created, for a type, in a non-generic static class.  That is why I'm changing the class program to be static.  The 
    use of this indicates the one that will be the string that has the method.<br/>

    <pre>
        <code>
            using System;

            public static class Program &lbrace;   
            
                public static bool LenGreaterThan6 (<b>this</b> string s)&lbrace;
                &nbsp;return s.Length > 6;
                &rbrace;
                public static bool LenGreaterThanInput (<b>this</b> string   s, string input)&lbrace;
                &nbsp;return s.Length > input.Length;
                &rbrace;
            
                
                static void Main(string[] args) &lbrace;
                Console.WriteLine("IAm4".LenGreaterThan6());//false
                Console.WriteLine("IAmMuchMoreThan4Or6".LenGreaterThan6());//true
                Console.WriteLine("IAm4".LenGreaterThanInput("theInput"));//false
                Console.WriteLine("IAm4".LenGreaterThanInput("I"));//true
                &rbrace;
            &rbrace;
        </code>
    </pre>


    <br/>
    <code><strong><u>Tuples</u></strong></code><br /><br/>

    We have System.Tuple (reference, the data members are properties) and System.ValueTuple (value, the data members are fields).<br/>

    For the System.tupple:<br/>
    <pre>
        <code>
            using System;

            public static class Program &lbrace;   

                &nbsp;public class Test&lbrace;
                &nbsp;&nbsp;public Tuple&lt;Int32&gt; intT = new Tuple&lt;Int32&gt;(100);
                &nbsp;&nbsp;public Tuple&lt;Int32, string&gt; intStringT = new Tuple&lt;Int32, string&gt;(1,"hey");
                &nbsp;&rbrace;;
        
                &nbsp;static void Main(string[] args) 
                &nbsp;&nbsp;Test t = new Test();
                &nbsp;&nbsp;Console.WriteLine(t.intT.Item1);//100
                &nbsp;&nbsp;Console.WriteLine(t.intStringT.Item2);//hey
                &rbrace;
            &rbrace;
        </code>
    </pre>
    You could also create the tuple this way:<br/>
    <code>
        var intT = Tuple.Create&lt;Int32&gt;(101);
    </code>

    <br/><br/>
    For the System.ValueTuple<br/>
    <pre>
        <code>
            public (Int32, double) intT = (100, 4.5);//has to have more than 1 item.
            public (Int32, string) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.Item1);//100
            Console.WriteLine(t.intStringT.Item2);//hey
        </code>
    </pre>
    You could also name the items:<br/>
    <pre>
        <code>
            public (Int32 i , double d) intT = (100, 4.5);
            public (Int32 i , string s) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.d);//4.5
            Console.WriteLine(t.intStringT.s);//hey
        </code>
    </pre>
    You can use == and != to compare these tuples, but it will compare the values, meaning, the names given to the fields will not matter.<br/>

    <br/>
    <code><strong><u>Generics</u></strong></code><br /><br/>

    <pre>
        <code>
            public static class Program &lbrace;   

                public class <b>TestGen&lt;T&gt;</b>&lbrace;
            
                  public bool isItNull(<b>T theT</b>)&lbrace;
                    return theT == null;
                  &rbrace;
                &rbrace;
                  
                static void Main(string[] args) &lbrace;    
                  TestGen<b>&lt;string&gt;</b> t = new TestGen<b>&lt;string&gt;</b>();
                  TestGen&lt;Int32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                  Console.WriteLine(t.isItNull("hello"));//false
                  Console.WriteLine(t2.isItNull(3));//false
                  Console.WriteLine(t2.isItNull(null));//true
                &rbrace;            
        </code>
    </pre>
    <pre>
        <code>
            public static class Program &lbrace;   

                public class TestGen&lt;T&gt;&lbrace;
            
                 <b>public T Data &lbrace; get; set; &rbrace;</b>
                &rbrace;
                  
                static void Main(string[] args) &lbrace;     
                  TestGen&lt;string&gt; t = new TestGen&lt;string&gt;();
                  t.Data = "hello";
                  TestGen&lt;nt32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                  t2.Data = 48;
                  Console.WriteLine(t.Data);//false
                  Console.WriteLine(t2.Data);//false      
                &rbrace;
            &rbrace;
        </code>
    </pre>
    Trying this instead would have given an error because an Int32? is expected: <b>t2.Data = "48";</b><br/>
    A generic class can be a base class to other generic or non-generic classes or abstract classes.<br/>
    You can have more than one type for a generic class (T, U ...)<br/>

    <br/>
    <code><strong><u>InottifyPropertyChanged</u></strong></code><br /><br/>
    When you need to know that a property changed.<br/>

    <img width="100%" src="assets\images\csharp\INotifyPropertyChanged.png" alt="Notify property changed" /><br/><br/>

    A similar example for copy paste:<br/>
    <pre>
        <code>
            using System;
            <b>using System.ComponentModel;</b>

            public static class Program &lbrace;   

                public class WillChangeProperty:<b>INotifyPropertyChanged</b>&lbrace;
                
                    <b>public event PropertyChangedEventHandler PropertyChanged;</b>
                    private string _theData = "";
                    public string TheData &lbrace;
                        get&lbrace;
                        return this._theData ;
                        &rbrace;
                        set&lbrace;
                        this._theData = value;
                        <b>PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(this._theData));</b>
                        &rbrace;            
                    &rbrace;
                    <b>public void WhatToDoOnChange(object sender, PropertyChangedEventArgs e)&lbrace;</b>
                        Console.WriteLine("It changed!");
                    &rbrace;
                &rbrace;
                
                static void Main(string[] args) &rbrace;     
                    WillChangeProperty w = new WillChangeProperty();
                    <b>w.PropertyChanged += w.WhatToDoOnChange;</b>
                    w.TheData = "Hello";
                &rbrace;
            &rbrace;

        </code>
    </pre>

    <br/>
    <br/>
    <code><strong><u>IComparable</u></strong></code><br /><br/>

    Implement it when you want to provide a method to compare your classes.<br/>
    <img width="100%" src="assets\images\csharp\IComparable.png" alt="IComparable" /><br/><br/>

    <pre>
        <code>
            public static class Program &&lbrace;;  

                public class WillCompare:<b>IComparable</b>&lbrace;
                  
                  public string TheData &lbrace;get;set;&rbrace;
                  <b>public int CompareTo(object o)</b>&lbrace;
                    <b>//same=0, o&gt; ret &gt;0, o&lt; ret &lt;0</b>
                    if (((WillCompare)o).TheData.Length == this.TheData.Length)&lbrace;
                      return 0;
                    &rbrace;else if (((WillCompare)o).TheData.Length > this.TheData.Length)&lbrace;
                    return 1;
                    &rbrace;else return -1;
                  &rbrace;
                &rbrace;
                  
                static void Main(string[] args) &lbrace;     
                     WillCompare w1 = new WillCompare();
                     w1.TheData = "hello";
                     WillCompare w2 = new WillCompare();
                     w2.TheData = "helloooo";
                     Console.WriteLine(<b>w1.CompareTo(w2)</b>);//1
                &rbrace;
            &rbrace;
            
        </code>
    </pre>
    <br/>

    Once you have the above, you can sort a list of objects and it will be sorted based on the CompareTo.<br/>
    With the same code as above:<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;     
                WillCompare w1 = new WillCompare();
                 w1.TheData = "hello";
             WillCompare w2 = new WillCompare();
                 w2.TheData = "helloooo";
             WillCompare w3 = new WillCompare();
                 w3.TheData = "hey";
             List&lt;WillCompare&gt; l = new List&lt;WillCompare&gt;();
             l.Add(w1);
             l.Add(w2);
             l.Add(w3);
             l.Sort();
             Console.WriteLine(l[0].TheData);//
             Console.WriteLine(l[1].TheData);//
             Console.WriteLine(l[2].TheData);//
           &rbrace;
        </code>
    </pre>
    <pre>
        <samp>
            helloooo
            hello
            hey
        </samp>
    </pre>
    Change the way you do the CompareTo if you want the sorting to be this way:<br/>
    <pre>
        <samp>
            hey
            hello
            helloooo
        </samp>
    </pre>


    <code><strong><u>IComparer</u></strong></code><br /><br/>

    
    IComparable will help you in your sorting when you have control over the class you are sorting, 
    so you can have the CompareTo the way you like it. However, it is possible that you have the ObjectForComparing objects, 
    but instead of wanting the CompareTo in that class for your sort, now you want them sorting by some other way<br/>

    You still have this class as before, but I have added TheNumber<br/>
    <pre>
        <code>
            public class WillCompare:IComparable&lbrace;
      
                public string TheData &lbrace;get;set;&rbrace;
                <b>public Int32 TheNumber &lbrace;get;set;&rbrace;</b>
                public int CompareTo(object o)&lbrace;
                  //same=0, o&gt; ret &gt;0, o&lt; ret &lt;0
                  if (((WillCompare)o).TheData.Length == this.TheData.Length)&lbrace;
                    return 0;
                  &rbrace;else if (((WillCompare)o).TheData.Length &lt; this.TheData.Length)&lbrace;
                  return 1;
                  &rbrace;else return -1;
                &rbrace;
              &rbrace;
        </code>
    </pre>
    We add another class, implementing IComparer, which we will use to compare the WillCompare objects, instead of using the objects own CompareTo.
    We have to indicate what type of objects we will be using with this new class.  The Compare method here will just use the CompareTo of the Int32.<br/>
    <pre>
        <code>
            public class WillCompare2:<b>IComparer&lt;WillCompare&gt;</b>&lbrace;
                public int <b>Compare(WillCompare o1, WillCompare o2)</b>&lbrace;
                  return o1.TheNumber.CompareTo(o2.TheNumber)  ;
                &rbrace;
              &rbrace;
        </code>
    </pre>
    Now, to compare 2 WillCompare objects using this new Compare, and use it to sort the list, we would do this (I have changed all the strings 
    to hello so they are all the same):<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;     
                WillCompare w1 = new WillCompare();
                w1.TheData = "hello";
                w1.TheNumber = 100;
                WillCompare w2 = new WillCompare();
                w2.TheData = "hello";
                w2.TheNumber = 50;
                WillCompare w3 = new WillCompare();
                w3.TheData = "hello";
                w3.TheNumber = 200;
                
                List&lt;WillCompare&gt; l = new List&lt;WillCompare&gt;();
                l.Add(w1);
                l.Add(w2);
                l.Add(w3);

                WillCompare2 c2 = new WillCompare2();
                l.Sort(<b>c2</b>);
             
                Console.WriteLine(l[0].TheNumber);//50
                Console.WriteLine(l[1].TheNumber);//100
                Console.WriteLine(l[2].TheNumber);//200
           }
        </code>
    </pre>
    <code><strong><u>IEquitable</u></strong></code><br /><br/>

    You know you can use equals to compare strings, and you want to have something similar for your class, with whatever criteria you want to use.<br/>
    The class that will have the Equals is this one, and notice that we are indicating the object have to be equaled to a string (could have been the object type or 
    anything else). Notice we consider the object equal to the string if the lengths match.<br/>
    <pre>
        <code>
            public class WillEquate:<b>IEquatable&lt;string&gt;&lbrace;</b>
      
                public string TheData &lbrace;get;set;&rbrace; 
                <b>public bool Equals(string s)&lbrace;</b>
                  if (this.TheData.Length == s.Length)&lbrace;
                    return true;
                  &rbrace;
                  return false;
                &rbrace;
              &rbrace;
        </code>
    </pre>
    And this is how we would use it<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;    
                WillEquate w1 = new WillEquate();
                w1.TheData = "five5";
                string s = "hello";
                string s2 = "hey";
                Console.WriteLine(<b>w1.Equals(s)</b>);//true
                Console.WriteLine(<b>w1.Equals(s2)</b>);//false
            &rbrace;
        </code>
    </pre>

    <code><strong><u>IEqualityComparer</u></strong></code><br /><br/>

    Similar to the IEquatable, but you create it in another class and the method will take 2 arguments to compare.<br/>
    You create the class you will use to compare, and implement IEqualityComparer with whatever type you want to compare.  In the Equals, 
    take as arguments the object types and choose how you want to check if they are equal.<br/>
    To use it just create the objects you want to compare and the object for the class that will compare them.<br/>

    <img width="100%" src="assets\images\csharp\IEqualityComparer1.png" alt="IEquialityComparer" /><br/><br/>

    The above code is OK, but if you want the GetHashCode to work in accordance with the Equals, 
    so for instance you don’t get duplicate keys in a Dictionary, it should look more like this (notice the new Equals):<br/>

    <img width="100%" src="assets\images\csharp\IEqualityComparer2.png" alt="IEquialityComparer" /><br/><br/>


    <code><strong><u>IEnumerable</u></strong></code><br /><br/>

    

</div>