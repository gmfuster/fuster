<div class="PaddedContents ">    

<div >

    <br/>
    <h2 class="CenterMe">C# notes - Basics</h2>      
    <div class="TopLinks" #HeadingsContainer>      
        <top-links ></top-links>      
      </div>  
      <br/>
            
        <p class="HeadingSubTopic" id="AccessModifiers" HeadingSubTopicDir>Access Modifiers</p>

        <b>private: </b> Member is accessible only inside its type.<br/>
        <b>internal: </b> Accessible inside the type and any type in the same assembly.<br/>
        <b>protected: </b>Accessible inside the type, and types that inherit from it.<br/>
        <b>public: </b>Accessible everywhere.<br/>
        <b>internal protected: </b>Accessible inside the type, same assembly, and types that inherit from it. <br/>
        <b>private protected: </b>Accesible inside the type, and any inherited type that is IN the same assembly.<br/>
        
        <p class="HeadingSubTopic" id="NullCoalescing" HeadingSubTopicDir>null coalescing operator</p>
        <pre>
            <code >
                class Program &lbrace;
                &nbsp;static void Main(string[] args) &lbrace;
                    &nbsp; &nbsp;    string theString = "hello";
                    &nbsp; &nbsp;    string theOtherString = null;
                    &nbsp; &nbsp;    Console.WriteLine(<b>theString ?? "Just Me"</b>); //hello
                    &nbsp; &nbsp;    Console.WriteLine(theOtherString ?? "Just Me");//Just Me
                    &nbsp; &rbrace;
                &rbrace;
            </code>
        </pre>
            
        <p class="HeadingSubTopic" id="Overloading" HeadingSubTopicDir>operator overloading</p>
        This example is silly but it's just to illustrate how this works.  We have a clas SomeObj, and it has a method for the + of objects of that class:<br/>
        <pre>
            <code >
                ...
                <b>public static SomeObj operator +(SomeObj o1, SomeObj o2)</b>
                &lbrace;
                &nbsp; SomeObj newO = new SomeObj("");
                &nbsp;  newO.TheThing = o1.TheThing + "-" + o2.TheThing;
                &nbsp;  return newO;
                &rbrace;
                //to use 
                SomeObj obj1 = new SomeObj("hey");
                SomeObj obj2 = new SomeObj("helloooo");
                Console.WriteLine( <b>(obj1 + obj2).TheThing</b>);
            </code>
        </pre>  
        <br/>
        <img width="100%" src="assets\images\csharp\opoverloading1.png" alt="operator overloading" /><br/><br/>
        
        <p class="HeadingSubTopic" id="Keywords" HeadingSubTopicDir>keywords as variables</p>
        <pre>
            <code>
                using System;

                &nbsp;class Program &lbrace;    

                    &nbsp;&nbsp;   static void Main(string[] args) &lbrace;
                        &nbsp;&nbsp;  <b>string @if = "using if as a variable";</b>
                        &nbsp;&nbsp;  Console.WriteLine (@if);
                        &nbsp;  &rbrace;
                &rbrace;
            </code>
        </pre>
        
        <p class="HeadingSubTopic" id="SpecialChars" HeadingSubTopicDir>Ignore/use special chars</p>

        <pre>
            <code>
                Console.WriteLine(@"blah blah \n \\hey ");//will print that same string

                Console.WriteLine("Hello tab coming up \t see?"); //will print a tab after up

                Console.WriteLine("c:\totals"); // prints c:      otals

                Console.WriteLine("c:\\totals"); // prints c:\totals
                
            </code>
        </pre>
        <br/>
        
        <p class="HeadingSubTopic" id="FormatStrings" HeadingSubTopicDir>format strings with variables</p>
        <pre>
            <code>
                string fillIt = "Michael";
                <b>Console.WriteLine($"My name is &lbrace;fillIt&rbrace;");</b>
                //the one below uses C so it will print with currency format:
                decimal amount = 8.94m;
                <b>Console.WriteLine($"My amount is &lbrace;amount:C&rbrace;");</b>//My amount is $8.94

                int i = 10;
                int j = 20;

                Console.WriteLine( <b>format: "Number i is &lbrace;0&rbrace; and number 2 is &lbrace;1&rbrace;", 	i,j)</b>;
                //prints Number i is 10 and number 2 is 20

                private const string _name = "Michael";
                private const string _lname = "Jackson";
                private const string _fullName =  $"&lbrace;_name&rbrace;&lbrace;_lname&rbrace;"; // in console it would be Michael Jackson.

                Console.WriteLine(<b>String.Format("The current price is &lbrace;0&rbrace; per ounce.", 100));</b>

                //the -10 and the 6 indicate the <b>alignment of the argument.</b>
                //hardcoding the values here, instead of using variables for simplicity
                Console.WriteLine(   format: "&lbrace;0,-10&rbrace; &lbrace;1,6&rbrace;",   arg0: "Name",   arg1: "Count");
                Console.WriteLine(  format: "&lbrace;0, -10&rbrace; &lbrace;1, 6:N0&rbrace;",    arg0: "Bananas",    arg1: 5);
                Console.WriteLine(  format: "&lbrace;0, -10&rbrace; &lbrace;1, 6:N0&rbrace;",   arg0: "Apples",   arg1: 12);
            </code>
        </pre>
        <br/>
        Use double instead of decimal when accuracy is not important, especially when comparing numbers.<br/>
        
        <p class="HeadingSubTopic" id="LittleThings" HeadingSubTopicDir>Some little things</p>
        <pre>
            <code>
                int i = <b>10_123;</b>
                Console.WriteLine(i); //prints number 10123
                Console.WriteLine<b>( $"Number is &lbrace;i:C&rbrace;")</b>;//prints $10,123.00

                checked&lbrace;
                    //code that may result in an overflow, use the checked so we know if this happens, instead of it being ignored.
                &rbrace;
                //Also have the checked code inside a try catch so we can do something if the exception happens
            </code>
        </pre>
                <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/criEG9" frameborder="0"></iframe>

        <pre>
            <code>                
                static string Method2(int i) =>
                    i switch
                    &lbrace;
                        1 => "One", // what it will return
                        2 =>"Two",
                        _ => "Something Else"
                    &rbrace;;
            </code>
        </pre>
        C# has const and read only fields.  <b>Const values have to be known at compile time, while read only fields can be set in the constructor.  Declare in the class, 
        set it in the constructor.</b><br/>
        With c#11 we have a <b>required</b> keyword: <b>public required string Email &lbrace; get; set; &rbrace;</b>.  If we do this, when we instantiate the class with the fields 
        marked as required, we will have to give values for them or we will get a compiler error.<br/><br/>
        <pre>
            <code>
                var person = new Person &lbrace; FirstName = "Ada" &rbrace;// FirstName has been marked required in Person.
            </code>
        </pre>
        We can have properties that can be instatiated once but not afterwards, for that we use the <b>init</b> keyword:<br/>
        <pre>
            <code>
                //have this property in class SomeClass.
                public string someS &lbrace; get; <b>init;</b> &rbrace;
                ...
                //the 2 lines below will <b>not compile</b>
                SomeClass theClass = new SomeClass();
                theClass.someS = "hey";
                ...
                //but the below <b>will compile</b> and print hey, but it cannot be set again
                SomeClass theClass = new()
                &lbrace;
                    someS = "hey" //separate more with commas
                &rbrace;;
            </code>
        </pre>
        
        <p class="HeadingSubTopic" id="Params" HeadingSubTopicDir>params argument</p>
        the params argument has to be the last one <br/>
        <pre>
            <code>
                class Program &lbrace;    

                &nbsp;  public static void SomeMethod(Int32 i, string s, <b> params string[] words</b>)&lbrace;
                &nbsp;  &nbsp;   Console.WriteLine(i);
                &nbsp;  &nbsp;   Console.WriteLine(s);
                &nbsp;  &nbsp;   Console.WriteLine(words.Length);
                    &rbrace;
                    
                    static void Main(string[] args) &lbrace;
                    &nbsp;      SomeMethod(2, "hello",   "I","am","your","father");                  
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        Prints <br/>
        <pre>
            <samp>
            2
            hello
            4
            </samp>
        </pre>
        
        <p class="HeadingSubTopic" id="DefaultParams" HeadingSubTopicDir>Default params</p>

        <pre>
            <code>
                public static void SomeMethod(Int32 i, string s, string def1 = "defaulted 1", string def2 = "defaulted 2")&lbrace;  
                &nbsp;  Console.WriteLine(def1);
                &nbsp;  Console.WriteLine(def2);
                &rbrace;
                
                static void Main(string[] args) &lbrace;
                &nbsp;   SomeMethod(2, "hello");
                &nbsp;   SomeMethod(2, "hello", "for 1");
                
                &rbrace;
            </code>
        </pre>
        Prints:<br/>
        <pre>
            <samp>
                defaulted 1
                defaulted 2
                for 1
                defaulted 2
            </samp>
        </pre>
        
        Parameters can be passed by value (default), by reference (<b>ref</b>), and as an <b>out</b> parameter.
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/KhD26f" frameborder="0"></iframe>

        <br/>    
        <p class="HeadingSubTopic" id="ExtensionMethods" HeadingSubTopicDir>Extension Methods</p>

        Extension methods have to be created, for a type, in a non-generic static class.  The 
        use of this indicates the one that will be the string that has the method.<br/>

        <pre>
            <code>
                using System;

                public static class Program &lbrace;   
                
                    public static bool LenGreaterThan6 (<b>this</b> string s)&lbrace;
                    &nbsp;return s.Length > 6;
                    &rbrace;
                    public static bool LenGreaterThanInput (<b>this</b> string   s, string input)&lbrace;
                    &nbsp;return s.Length > input.Length;
                    &rbrace;
                
                    
                    static void Main(string[] args) &lbrace;
                    Console.WriteLine("IAm4".LenGreaterThan6());//false
                    Console.WriteLine("IAmMuchMoreThan4Or6".LenGreaterThan6());//true
                    Console.WriteLine("IAm4".LenGreaterThanInput("theInput"));//false
                    Console.WriteLine("IAm4".LenGreaterThanInput("I"));//true
                    &rbrace;
                &rbrace;
            </code>
        </pre>

        <br/>    
        <p class="HeadingSubTopic" id="Tuples" HeadingSubTopicDir>Tuples</p>

        We have System.Tuple (reference, the data members are properties) and System.ValueTuple (value, the data members are fields).<br/>

        For the <b>System.Tuple:</b><br/>
        <pre>
            <code>
                using System;

                public static class Program &lbrace;   

                    public class Test&lbrace;
                        public Tuple&lt;Int32&gt; intT = new Tuple&lt;Int32&gt;(100);
                        public Tuple&lt;Int32, string&gt; intStringT = new Tuple&lt;Int32, string&gt;(1,"hey");
                    &rbrace;;
            
                    static void Main(string[] args) 
                    &lbrace;
                        Test t = new Test();
                        Console.WriteLine(t.intT.Item1);//100
                        Console.WriteLine(t.intStringT.Item2);//hey
                    &rbrace;
                &rbrace;                
            </code>
        </pre>
        You could also create the tuple this way:<br/>
        <code>
            var intT = Tuple.Create&lt;Int32&gt;(101);
        </code>

        <br/><br/>
        For the <b>System.ValueTuple</b><br/>
        <pre>
            <code>
                var intTupVal = System.ValueTuple.Create&lt;Int32&gt;(200);

                System.ValueTuple&lt;Int32&gt; intTupVal = new ValueTuple&lt;Int32&gt;(100);
                Console.WriteLine (intTupVal); //(100)
                Console.WriteLine (intTupVal.Item1); //100

                public (Int32, double) intT = (100, 4.5);
                public (Int32, string) intStringT = (1,"hey");
                ...
                Console.WriteLine(t.intT.Item1);//100
                Console.WriteLine(t.intStringT.Item2);//hey


            </code>
        </pre>
        You could also name the items:<br/>
        <pre>
            <code>
                public (Int32 i , double d) intT = (100, 4.5);
                public (Int32 i , string s) intStringT = (1,"hey");
                ...
                Console.WriteLine(t.intT.d);//4.5
                Console.WriteLine(t.intStringT.s);//hey

                (int first, int second , int third) tup1 = (100,200, 300);
                Console.WriteLine(tup1.first);//100

                var tup2 = (first:100, second:200, third:300);
                Console.WriteLine(tup2.second); //200
            </code>
        </pre>
        You can use == and != to compare these tuples, but it will compare the values for the valueTuples, meaning, the names given to the fields will not matter.<br/>
        For the reference tuples, the memory allocation is compared, not the values.<br/>

        We could also have this code:<br/>
        <pre>
            <code>
                public (int, string) GiveATuple() //return the tuple (int, string)
                &lbrace;
                return (1, "one");
                &rbrace;
                ...
                (int, string) t = GiveATuple();
                Console.WriteLine(t.Item1); //as before, we have Item1, Item2 etc		        
            </code>
        </pre>
        Or we can also name what gets returned.  Notice we name the return, but also the return of the method itself.
        <pre>
            <code>
                public (int <b>num</b>, string <b>str</b>) GiveATuple()	        
                &lbrace;
                    return (<b>num:</b> 1, <b>str:</b> "one");
                &rbrace;
                ...
                var t = GiveATuple();
                Console.WriteLine(t.<b>str</b>);	        
            </code>
        </pre>

        <b>Destructuring Tuples</b><br/>
        Using the same GiveATuple() as above, we could also do:
        <pre>
            <code>
                (int numero, string <b>cadena</b>)= GiveATuple(); //could just assign the values as (1, "sssss")
                Console.WriteLine(<b>cadena</b>);		
            </code>
        </pre>

        ValueTuple types can hold more elements than Tuple types. If you have a Tuple, you can convert it to ValueTuple with ToValueTuple.
        <br/>
        Because Tuple types are limited as far as number of elements, we may need to have a Tuple instead of another Tuple so we can pass everything we need.
        <br/>
        <pre>
            <code>
                var numbers = Tuple.Create(1, 2, 3, 4, 5, 6, 7, Tuple.Create(8, 9, 10, 11, 12));
                Console.WriteLine(numbers.Item1); //1
                Console.WriteLine(numbers.Rest.Item1); //(8, 9, 10, 11, 12)
                Console.WriteLine(numbers.Rest.Item1.Item1);   //8
            </code>
        </pre>

        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/PN0RDV" frameborder="0"></iframe>

        <br/>    
        <p class="HeadingSubTopic" id="Generics" HeadingSubTopicDir>Generics</p>

        <pre>
            <code>
                public static class Program &lbrace;   

                    public class <b>TestGen&lt;T&gt;</b>&lbrace;
                
                        public bool isItNull(<b>T theT</b>)&lbrace;
                            return theT == null;
                        &rbrace;
                    &rbrace;
                    
                    static void Main(string[] args) &lbrace;    
                        TestGen<b>&lt;string&gt;</b> t = new TestGen<b>&lt;string&gt;</b>();
                        TestGen&lt;Int32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                        Console.WriteLine(t.isItNull("hello"));//false
                        Console.WriteLine(t2.isItNull(3));//false
                        Console.WriteLine(t2.isItNull(null));//true
                    &rbrace;            
            </code>
        </pre>
        <pre>
            <code>
                public static class Program &lbrace;   

                    public class TestGen&lt;T&gt;&lbrace;
                
                        <b>public T Data &lbrace; get; set; &rbrace;</b>
                    &rbrace;
                    
                    static void Main(string[] args) &lbrace;     
                        TestGen&lt;string&gt; t = new TestGen&lt;string&gt;();
                        t.Data = "hello";
                        TestGen&lt;Int32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                        t2.Data = 48;
                        Console.WriteLine(t.Data);//hello
                        Console.WriteLine(t2.Data);//48
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        Trying this instead would have given an error because an Int32? is expected: <b>t2.Data = "48";</b><br/>
        A generic class can be a base class to other generic or non-generic classes or abstract classes.<br/>
        You can have more than one type for a generic class (T, U ...)<br/>
        You can also indicate what the T can be, with something like this<br/>
        <pre>
            <code>
                public class TestGen&lt;T&gt; where T: WhateverClassOrType&lbrace;
                public class TestGen&lt;T,U&gt; where T: WhateverClassOrType where U:WhateverClassOrType&lbrace;
            </code>
        </pre>
        Above, we could also be using a class and an interface for each where.<br/>
        <br/>      
      
        <p class="HeadingSubTopic" id="Enums" HeadingSubTopicDir>Enums</p>

        Regular way to use an Enum<br/>
        <pre>
            <code>
                public enum SomeEnum&lbrace;
                    first,
                    second,
                    third
                &rbrace;
            </code>
        </pre>
        Could also do this.  Here not making much sense but just showing you can change the values for the items<br/>
        <pre>
            <code>
                public enum SomeEnum&lbrace;
                    first = 11,
                    second = 12,
                    third = 13
                &rbrace;
            </code>
        </pre>
        With the above code, if we were to use the enum, we could do this<br/>
        <pre>
            <code>
                SomeEnum e = SomeEnum.first;
                Console.WriteLine((int)e); // will print 11.
            </code>
        </pre>

        If we don't specify anything, the first element will start at zero.<br/>
        Usually the values are using int values, but we can also change it to use something else.  Like byte to use less memory.<br/>

        We can combine multiple values by using Flags.<br/>
        <pre>
            <code>
                [System.Flags]
                public enum SomeBinaryEnum:Byte&lbrace;
                    one = 0b0001,//1
                    two = 0b0010,//2
                    three = 0b0011//3
                &rbrace;
            </code>
        </pre>
        With the above enum:<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;
                    SomeBinaryEnum e = SomeBinaryEnum.one;
                    Console.WriteLine((Byte)e); //prints 1
                    Console.WriteLine(e);  //prints One
                &rbrace;
            </code>
        </pre>

        But on the above enum, one and two together will give the same as 3, so if we want to use flags, we should choose values that don't overlap:<br/>
        <pre>
            <code>
                [System.Flags]
                public enum SomeBinaryEnum:Byte&lbrace;
                    one = 0b0001,
                    two = 0b0010,
                    <b>four = 0b0100</b>
                &rbrace;
            </code>
        </pre>
        With the above code, we can now do this:<br/>
        <pre>
            <code>
                SomeBinaryEnum e = SomeBinaryEnum.one |   SomeBinaryEnum.two; //values 0b0001 and 0b0010 , or 0b0011 (3)
                Console.WriteLine((Byte)e); // prints 3
                Console.WriteLine(e); <b>//prints one, two.</b>
            </code>
        </pre>
        Keep in mind that the type you can use for the enum will depend on how many values you are going to need.<br/>

        <p class="HeadingSubTopic" id="RecordsClassStruct" HeadingSubTopicDir>Records, Classes, Struct</p>
        Medium Article - <a href="https://gmfuster.medium.com/c-class-struct-record-record-struct-d3b21c57d9bb"
        target="_new">C# — Class, Struct, Record, Record Struct</a><br/><br/>

        Before I get into records, just a little refresher about structures and classes.<br/>
        A structure struc cannot have a parameterless constructor (at least before C#10).  In a constructor, we can assign a property through the constructor, or, 
        if the property has the set we can also change it later.<br/>
        Structures are by value, and classes are by reference.<br/>
        Typically, you use structure types to design small data-centric types that provide little or no behavior. 
        Because structure types have value semantics, MS recommends to define immutable structure types (you can use readonly for the struct, 
        and remove the set from the properties))<br/>
        Once we do that, we can set the value for the readonly fields/properties of the structure in the 
        constructor but that’s it. This means, even members of the struct cannot change those fields/properties<br/>
        Starting with C#10 you can also have a structure and create a copy of it with just some of the fields changed:
        <pre>
            <code>
                Name name1 = new Name &lbrace; F= "Michael", L= "Jackson"&rbrace;;
                Name name2 = name1 with &lbrace; L = "Jordan" &rbrace;;
            </code>
        </pre>
        A structure type can’t inherit from other class or structure type and it can’t be the base of a class. However, a structure type can implement interfaces.<br/>
        You can’t declare a finalizer within a structure type.<br/>
        Prior to C# 10, you can’t initialize an instance field or property at its declaration.<br/>

        Structures are passed by value, though you can use ref to indicate that it should be passed by reference.<br/>

        Starting with 7.2 you can also declare structures as reference type with the ref keyword<br/>
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/lNIQK7" frameborder="0"></iframe>

        As opposed to the code above (in dotnetfiddle), if what we had assigned were classes and then we changed the property in one of the instances,
        the value would be changed in both instances.

        <br/><br/>
        Beginning with C#9 for a reference type, then with C#10 for also value type, 
        we can have <b>record class</b> for reference and <b>record struct</b> for value type.  Not 
        indicating class or struct will make it by reference.<br/>
        Records can be mutable (get and set) but they are usually used for immutable models.<br/>
        <!--Positional properties are immutable in a record class and a readonly record struct. They're mutable in a record struct.<br/>-->
        <pre>
            <code>
                //reference because we are not saying struct (class by default)
                //PersonA gets the values assigned with the contructor, based in the order.
                public record PersonA(string FirstName, string LastName);
                PersonA name = new PersonA("Michael", "Jackson");//create like this
                //PersonB, just create and then assign by name
                public record PersonB
                &lbrace;	
                    public string FirstName &lbrace; get; set; &rbrace; = default!;
                    public string LastName &lbrace; get; set; &rbrace; = default!;
                &rbrace;;

                public void SomeMethod()
                &lbrace;
                    PersonA persona = new("Nancy", "Davoli");
                    PersonB personb = new();
                    personb.FirstName = "Nancia";
                    personb.LastName = "Davolia";
                    Console.WriteLine(persona.ToString());
                    Console.WriteLine(personb.ToString());
                &rbrace;
            </code>
        </pre>
        You can also have it declared with the constructor but change the accessibility like this:
        <pre>
            <code>
                public record PersonC(string FirstName, string LastName, string Id)
                &lbrace;
                    internal string Id &lbrace; get; init; &rbrace; = Id
                &rbrace;
                ...
                PersonC personc = new PersonC("Mark", "Knight", "1212");
                Console.WriteLine(personc.ToString()); // prints Mark, Knight
                Console.WriteLine(personc.Id); //prints 1212
            </code>
        </pre>
        When comparing (==) records are compared by value, meaning if the properties match, they will be equal.  Not the case for comparing classes.<br/>
        Like for structures, you can use the WITH expression for records.<br/>

        Regarding the printing of Mark and Knight above, but not 1212: Record types have a compiler-generated ToString method that displays 
        the names and values of <b>public</b> properties and fields. A record’s ToString method creates a formatted string that 
        shows an object's type name and the names and values of all its public properties. <br/>

        You could also just have a few properties with its constructor and other properties inside (not positional ones)<br/>
        A positional record and a positional readonly record struct declare init-only properties. A positional record struct declares read-write properties. 
        You can override either of those defaults<br/>

        After initialization, you can't change the value of value-type properties or the reference of reference-type properties. 
        However, the data that a reference-type property refers to can be changed.<br/>
        For class types, two objects are equal if they refer to the same object in memory.<br/>
        For struct types, two objects are equal if they are of the same type and store the same values.<br/>
        For record types, including record struct and readonly record struct, two objects are equal if they are <b>of the same type and store the same values.</b><br/>
        <br/>

        If you need to copy an instance with some modifications, you can use a with expression to achieve nondestructive mutation. A with expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.
        <pre>
            <code>
                public record PersonA(string FirstName, string LastName);
                ...
                PersonA persona = new("Nancy", "Davoli");
                PersonA persona2 = persona with &lbrace; FirstName = "John" &rbrace;;

                //prints
                //PersonA &lbrace; FirstName = Nancy, LastName = Davoli &rbrace;
                //PersonA &lbrace; FirstName = John, LastName = Davoli &rbrace;
            </code>
        </pre>
        The result of a with expression is a shallow copy, which means that for a reference property, 
        only the reference to an instance is copied. Both the original record and the copy end up with a reference to the same instance.<br/>
        A record can inherit from another record. However, a record can't inherit from a class, and a class can't inherit from a record.<br/>
        <pre>
            <code>
                public record Teacher(string FirstName, string LastName, int Grade): Person(FirstName, LastName);
            </code>
        </pre>
        For two record variables to be equal, the run-time type must be equal (not just the values, also the type).<br/>
        You can have abstract records.
        <pre>
            <code>
                public abstract record RecordName
                &lbrace;
                    public string First &lbrace; get; set; &rbrace;
                    public string Last &lbrace; get; set; &rbrace;
                &rbrace;
                public record RecordNameDer : RecordName
                &lbrace;
                    public string Middle &lbrace; get; set; &rbrace;
                &rbrace;
                ...
                RecordNameDer name = new RecordNameDer  &lbrace; First = "Michael", Last = "Jackson", Middle = "Joseph" &rbrace;;//or could have also done
                public abstract record RecordName(string First,string Last);
                public record RecordNameDer(string First, string Last, string Middle) : RecordName(First, Last);
                ...
                RecordNameDer name = new RecordNameDer ("Michael", "Jackson","Joseph" );
            </code>
        </pre>
        Records are good for when your data should not change. Records can be inherited from other records so it’s good to have that when you don’t 
        really need to have a whole class for what you need.

        Records are also convenient when you want your comparisons on the instances to be based on value.
        
        <p class="HeadingSubTopic" id="PatternMatching" HeadingSubTopicDir>Pattern Matches - Switch - Comparing - checking type</p>

        The info in this article is the same but may be better explained:<br/>
        <a href="https://gmfuster.medium.com/c-summary-of-patter-matching-1a1efec983cd"
        target="_new">C# — Summary of Patter Matching</a><br/><br/>

        This is a bit of pattern matches with a focus on switch but not just that.<br/>
        Imagine we have a class Fruit and a class Apple like this:
        <pre>
            <code>
                public class Fruit
                &lbrace;
                    public string? Name &lbrace; get; set; &rbrace;
                    public string? Color &lbrace; get; set; &rbrace;
                &rbrace;
                public class Apple:Fruit
                &lbrace;
                    public string? Type &lbrace; get; set; &rbrace;
                &rbrace;
                ...
                Fruit fruit = new Fruit();	
                Apple apple = new Apple();
                apple.Name = "Apple";
                apple.Color = "Green";
                apple.Type = "Fuji";
                ...
                fruit = apple;
                //to check before we can assume that the fruit is an apple
                <b>if (fruit.GetType() == typeof(Apple) && ((Apple)fruit).Type == "Fuji")</b>
                &lbrace;
                    Console.WriteLine("the fruit is an Apple and it's a Fuji Apple");
                &rbrace;

                //We could also have done.
                <b>if (fruit is Apple)</b>            
            </code>
        </pre>
        Something else we can do, starting with C#7.<br/>
        <pre>
            <code>
                Fruit fruit = new Fruit();	
                
                Apple apple = new Apple();
                apple.Name = "Apple";
                apple.Color = "Green";
                apple.Type = "Fuji";

                Apple apple2 = new Apple();
                apple2.Name = "Apple";
                apple2.Color = "Red";
                apple2.Type = "Awesome";

                fruit = apple;

                switch (fruit)
                &lbrace;
                    //theapple or whatever you want, just something so we can reference inside de code.
                    <b>case Apple theapple:</b>
                        Console.WriteLine(theapple.Name);
                        Console.WriteLine(theapple.Color);
                        Console.WriteLine(theapple.Type);
                        break;
                    default:
                        break;
                &rbrace;

                //the above will print Apple, Green, Fuji.
                //if the fruit above was not assigned an Apply type, it would go to the default.
            </code>
        </pre>

        Besides the type above, you can also match on some properties of the object<br/>
        <pre>
            <code>
                Fruit fruit = new Fruit();

                Apple apple = new Apple();
                apple.Name = "Apple";
                apple.Color = "Green";
                apple.Type = "Fuji";

                Apple apple2 = new Apple();
                apple2.Name = "Apple";
                apple2.Color = "Red";
                apple2.Type = "Awesome";

                fruit = apple;

                switch (fruit)
                &lbrace;
                    //theapple or wahtever you want, just something so we can reference inside de code.
                    //we are getting a warning because Color could be null, but just for what we are doing, we know it won't be.
                    //our fruit is set to the Green apple, so this will go to not the apple or not red.
                    <b>case Apple theapple when theapple.Color.Equals("Red"):</b>
                        Console.WriteLine(theapple.Name);
                        Console.WriteLine(theapple.Color);
                        Console.WriteLine(theapple.Type);
                        break;
                    default:
                        Console.WriteLine("not the apple or not read");
                        break;
                &rbrace;
            </code>
        </pre>
        With C#8 we also have a switch expression instead of the typical switch statement as above.  With the classes and assignments as above (
            this is matching on the class itself):<br/>
        <pre>
            <code>
                var <b>theFruit</b> = fruit switch
                &lbrace;
                    Apple <b>_ =></b> "This is an apple",
                    <b>_ =></b> "This is not an apple"
                &rbrace;
                Console.WriteLine(<b>theFruit</b>);
            </code>
        </pre>
        We can also do something like this <br/>
        <pre>
            <code>
                public class Fruit
                &lbrace;
                    public string? Name &lbrace; get; set; &rbrace;
                    public string? Color &lbrace; get; set; &rbrace;
                    public FruitType? FruitType &lbrace; get; set; &rbrace;

                    //need to have this here to be able to use the switch this way
                    public void <b>Deconstruct(out string? name, out string? color, out FruitType? ft)</b>
                    &lbrace;
                        name = Name;
                        color = Color;
                        ft = FruitType;
                    &rbrace;
                &rbrace;

                public class FruitType
                &lbrace;
                    public string? TheType &lbrace; get; set; &rbrace;
                &rbrace;

                Fruit fruit = new Fruit();
                fruit.Name = "Orange";
                fruit.Color = "Orange";
                <b>fruit.FruitType = new FruitType();</b>
                fruit.FruitType.TheType = "Citric";

                //need the Deconstruct method in the class to be able to do this.  Otherwise gets an error.
                <b>var result = fruit switch</b>
                &lbrace;
                    <b>Fruit("Orange", "Orange", null) => "Orange with no type",</b>
                    Fruit("Orange", "Orange", _) => "Orange",
                    _ => "Different"
                &rbrace;
                Console.WriteLine(result);//prints Orange
                //If we don't have a FruitType we will get  "orange with no type"
                //if the color was set to red, we would get Different.
            </code>
        </pre>
        We could also have something like this to check on the FruitType itself (note this doesn't cover all possible cases we can check for)
        <pre>
            <code>
                var result = fruit switch
                &lbrace;
                    <b>&lbrace; FruitType: &lbrace; TheType: "Citric" &rbrace;&rbrace; => "Citric",</b>
                    &lbrace; FruitType: null &rbrace; => "no type",		
                &rbrace;

                <b>//add this so we won't get an exception for a case that is not covered.
                _ => null,</b>
            </code>
        </pre>
        We can also use this on tuples, this example from the MS docs.
        <pre>
            <code>
                var newState = (state, operation, key.IsValid) switch
                &lbrace;
                  (State.Opened, Operation.Close, _)      => State.Closed,
                  (State.Opened, Operation.Open, _)       => throw new Exception(
                    "Can't open an opened door"),
                  (State.Opened, Operation.Lock, true)    => State.Locked,
                  (State.Locked, Operation.Open, true)    => State.Opened,
                  (State.Closed, Operation.Open, false)   => State.Locked,
                  (State.Closed, Operation.Lock, true)    => State.Locked,
                  (State.Closed, Operation.Close, _)      => throw new Exception(
                    "Can't close a closed door"),
                      _ => state
                &rbrace;;
            </code>
        </pre>
        With C#9, for a when in the switch were you have more than one condition, you could do this:
        <pre>
            <code>
                //from this
                Developer dev when dev.YearOfBirth >= 1980 && dev.YearOfBirth &lt;= 1989 

                //to this
                Developer dev when dev.YearOfBirth <b>is</b> &gt;= 1980 <b>and</b> &lt;= 1989

                //could also do
                Developer &lbrace; YearOfBirth: &gt;= 1980 and &lt;= 1989 &rbrace; dev
            </code>
        </pre>
    
        <br/>
        Another example with c#8<br/>
        <pre>
            <code>
                ...
                Fruit fruit2 = new Fruit();
                fruit2.Name = "Apple";
                fruit2.price = 200;
                
                var result = <b>fruit2</b> switch
                &lbrace;
                    <b>Fruit</b> f when f.price &lt;=100	<b>=&gt;</b> "Less than 100",
                    Fruit f when f.price &lt;= 200 =&gt; "Less than 200",
                    <b>Fruit =&gt;</b> "something else"
                &rbrace;;
                Console.WriteLine(result);// prints Less than 200
            </code>
        </pre>
        The same thing with C#9, in the switch itself<br/>
        <pre>
            <code>
                var result = fruit2 switch
                &lbrace;
                    <b>Fruit f => f.price switch</b>
                    &lbrace;
                        <b>&lt;= 100 =&gt; "Less than 100",</b>
                        &lt;= 200 =&gt; "Less than 200",
                        <b>_ =&gt;</b> "something else"
                    &rbrace;
                    //we could also have other types here checking for other things, inside of the same fruit2 switch (provided types are compatible)
                &rbrace;;
            </code>
        </pre>
        There is more than what is mentioned above, so check the documentation for more and for how to do it, or understand something you see.

        <br/> 
        You can also do this, notice you can check and do an assignment if condition met at the same time in the if()
        <pre>
            <code>
                object i = 12; //object assigned an int
                object s = "hello"; //object assigned a stringif (i is int x)//if the object i is int, it will be assigned to x
                &lbrace;
                    Console.WriteLine(x);//will happen
                &rbrace;   if (s is int xx)
                &lbrace;
                   Console.WriteLine(xx);//will not happen since s is not an int
                &rbrace;
                if (s is string  xxx)
                &lbrace;
                    Console.WriteLine("string " + xxx);//will happen
                &rbrace;
            </code>
        </pre>
        <br/>
        With C# 11 we also have <b>List Patterns</b>. Some examples (copy pasting this code as is will not work, see dotnetfiddle following this instead):
        <pre>
            <code>
                //int[] lists = &lbrace; 1, 2, 3, 4&rbrace;;
                Console.WriteLine(lists is [ &gt;1, &gt;2, &lt;=3, 0]); //false
                Console.WriteLine(lists is [ 1, 2, &lt;=3, &gt;3]);//true


                //int[] list2 =  &lbrace; 5, 6, 7, 8&rbrace;;
                if (list2 is [var first, _, .. var others])
                &lbrace;
                    Console.WriteLine(first); // 5
                    //skip the second one with _
                    string concatenated = string.Join(",", others);
                    Console.WriteLine(concatenated); //7,8
                &rbrace;


                string[] s = &lbrace; "hello how are you" &rbrace;;
                var text = s switch
                &lbrace;
                    [] =&gt; "Name was empty",
                    [var nocommasstring] =&gt; $"I have 1 el: &lbrace;nocommasstring&rbrace;",//prints this one
                    [var first, var second, _] =&gt; $"I have with commas: &lbrace;first&rbrace; &lbrace;second&rbrace;",
                &rbrace;
                Console.WriteLine(text);

                string[] s2 = &lbrace; "hello, how are you" &rbrace;;
                var text2 = s2 switch
                &lbrace;
                    [] =&gt; "Name was empty",
                    [var oneel] =&gt; $"I have 1 el: &lbrace;oneel&rbrace;", //prints this one
                    [var first, var second, _] =&gt; $"I have with commas: &lbrace;first&rbrace; &lbrace;second&rbrace;",
                &rbrace;
                Console.WriteLine(text2);

                string[] s3 =  &lbrace; "hello" , "how are you" &rbrace;;
                var text3 = s3 switch
                &lbrace;
                    [] =&gt; "Name was empty", //will print if empty array
                    [var oneel] =&gt; $"I have 1 el: &lbrace;oneel&rbrace;",
                    [var first, var second] =&gt; $"I have with commas: &lbrace;first&rbrace; AND &lbrace;second&rbrace;",//prints this one
                &rbrace;;
                Console.WriteLine(text3);

                string[] s4 =  &lbrace; "hello" , "how are you" &rbrace;;
                var text4 = s4 switch
                &lbrace;     //will give exception
                    [var first, var second, var third] =&gt; $"I have with commas: &lbrace;first&rbrace; AND &lbrace;second&rbrace;",
                &rbrace;;
                Console.WriteLine(text4);


                string[] s5 =  &lbrace; "hello" , "how are you" , "I ask"&rbrace;;
                var text5 = s5 switch
                &lbrace;     //will give exception
                    [var first, var second] =&gt; $"I have with commas: &lbrace;first&rbrace; AND &lbrace;second&rbrace;",
                    &rbrace;;
                Console.WriteLine(text5);

                string[] s6 =  &lbrace; "hello" , "how are you" , "I ask"&rbrace;;
                var text6 = s6 switch
                &lbrace;     //use ..var second to avoid exception
                    //prints I have with commas: hello AND how are you I ask
                    [var first, ..var second] =&gt; $"I have with commas: &lbrace;first&rbrace; AND &lbrace; string.Join(" ", second)&rbrace;",
                    &rbrace;;
                    Console.WriteLine(text6);
                &rbrace;
            </code>
        </pre>
        Note: I think something is happening in this frame, if you take it and compile it in dotnetfiddle.net with the latest compiler it works.<br/>
        <iframe width="100%" height="475" src="https://dotnetfiddle.net/Widget/OBBNcr" frameborder="0"></iframe>

        
        <p class="HeadingSubTopic" id="InterfacesVSAbstract" HeadingSubTopicDir>Interfaces vs Abstract classes</p>

        An interface contains definitions for a group of related functionalities that a non-abstract class or a struct must implement. 
        Beginning with C# 8.0, an interface may define a default implementation for members. 
        An interface may not declare instance data such as fields, auto-implemented properties, or property-like events.<br/>
        below, the class implements MyInterface and implements the 2 methods the interface has.
        <pre>
            <code>
                public class MyClass : MyInterface
                &lbrace;
                    public void SayGoodBye()
                    &lbrace;
                        Console.WriteLine("Bye!");
                    &rbrace;
                    public void SayHello()
                    &lbrace;
                        Console.WriteLine("Hello!");
                    &rbrace;
                &rbrace;
                public static void UseMyInterface()
                &lbrace;
                    MyClass myc = new MyClass();
                    myc.SayGoodBye();
                &rbrace;
            </code>
        </pre>
        Abstract classes cannot be implemented. Abstract classes can contain abstract methods. They can be used as a base class for other classes.
        <br/>
        Notice the difference with the abstract class.
        <pre>
            <code>
                public abstract class MyAbstract
                &lbrace;
                    public abstract void SayHello();
                    public abstract void SayBye();
                &rbrace;

                public class MyClassWithAbstract : MyAbstract
                &lbrace;
                    public <b>override</b> void SayHello()
                    &lbrace;
                        Console.WriteLine("hello");
                    &rbrace;
                    public override void SayBye()
                    &lbrace;
                        Console.WriteLine("bye");
                    &rbrace;
                &rbrace;

                public static void UseMyClassAbstract()
                &lbrace;
                    MyClassWithAbstract abs = new MyClassWithAbstract();
                    abs.SayHello();
                &rbrace;
            </code>
        </pre>
        Not all the methods in the abstract class have to be abstract.  For the ones that are not abstract, you can call them like you would any base class.<br/>
        For a regular base class, your base class can have methods that can be overriden (marked with virtual) and methods that cannot be overriden.
        You cannot override the methods of your base class that are not marked virtual.

        <p class="HeadingSubTopic" id="Other" HeadingSubTopicDir>Other</p>

        <p class="HeadingSubTopic2">function inside function</p>
        You can have a method and have a local function inside that method (starting with C#7). That local function can be accessed only from within that method.
        It could be something like <b>int whateverMethod() function &lbrace;... &rbrace;</b>

        <p class="HeadingSubTopic2">Index Type</p>
        We can use this type to use as an index for arrays or whatever.  The cool thing is that you can use it to start counting from the end.  But, in that case 
        it skips zero.
        <pre>
            <code>
                string[] arrays = new string[] &lbrace;"zero", "one", "two", "three", "four", "five", "six"&rbrace;;

                Console.WriteLine(arrays[4]); //prints four

                <b>Index</b> i1 = new Index(3);
                Console.WriteLine(arrays[i1]); // prints three

                Index i2 = 1;
                Console.WriteLine(arrays[i2]); // prints one

                Index i3 = new <b>Index(value:4, fromEnd:true);</b>
                Console.WriteLine(arrays[i3]); // prints three!!!!!!!!
                Index i4 = new Index(value: 2, fromEnd: true);
                Console.WriteLine(arrays[i4]); // prints five!!!!!!!!!!
                Index i5 = <b>^2;</b> //another way to say from the end.
                Console.WriteLine(arrays[i5]); // prints five!!!!!!!!!!
            </code>
        </pre>
        <p class="HeadingSubTopic2" HeadingSubTopicDir>Ranges</p>
        The Range type uses indexes to indicate its range.  We can use the ranges with spans to get parts of them.
        <pre>
            <code>
                Range r1 = new <b>Range(start: new Index(2), end: new Index(4));</b>
                Range r2 = <b>1..3;</b>
                Range r3 = <b>Range.StartAt(4);</b>
                Range r4 = <b>5..;</b>
                Range r5 = <b>Range.EndAt(3);</b>
                Range r6 = <b>..3;</b>

                <b>ReadOnlySpan&lt;char&gt;</b> sp1 = "hello how are you?".<b>AsSpan();</b>
                <b>//start at zero but exclude the char at the end of the range</b>
                Console.WriteLine(<b>sp1[1..2]</b>.ToString()); //e
                Console.WriteLine(sp1<b>[r1]</b>.ToString()); //ll
                Console.WriteLine(sp1[r2].ToString());  //el
                Console.WriteLine(sp1[r3].ToString()); //o how are you?
                Console.WriteLine(sp1[r4].ToString()); // how are you?
                Console.WriteLine(sp1[r5].ToString()); //hel
                Console.WriteLine(sp1[r6].ToString());//hel
            </code>
        </pre>
        <br/>   
        
        <p class="HeadingSubTopic2" HeadingSubTopicDir>Instantiate Structure</p>

        <pre>
            <code>
                Test t1 = new();
		        Console.WriteLine(t1); //Test &lbrace; defTrue = False, defFalse = False &rbrace;

                Test t2 = new Test(false);
                Console.WriteLine(t2); //Test &lbrace; defTrue = False, defFalse = False &rbrace;

                Test t3 = new Test(true);
                Console.WriteLine(t3); //Test &lbrace; defTrue = True, defFalse = False &rbrace;

                Test? t4 = null;
                var t5 = t4.GetValueOrDefault(default);
                Console.WriteLine(t5); //Test &lbrace; defTrue = False, defFalse = False &rbrace;

                Test t6 = new Test(false, true);
                Console.WriteLine(t6); //Test &lbrace; defTrue = False, defFalse = True &rbrace;
            </code>
        </pre>


        <p class="HeadingSubTopic2" HeadingSubTopicDir>UT8 and other string changes</p>
        By default C# strings are hardcoded to UTF-16, whereas the prevailing string encoding on the internet is UTF-8.  With C#11 we can 
        do <b>var u8 = "This is a UTF-8 string!"u8;</b>  Also, if we what to print exactly the string, we can do this:
        <b>var raw1 = """This\is\all "content"!""";</b> or if you need more than just "" inside the string, just add more "" at the beginning. You could 
        also do 
        <pre>
            <code>
                ar raw3 = """                    
                &lt;body&gt;
                        This line is indented.
                &lt;/body&gt;
                """;
            </code>
        </pre>

        <p class="HeadingSubTopic2" HeadingSubTopicDir>Instantiate Structure</p>

        Also with C# 11 you can mark properties as required: <b>public required string FirstName &lbrace; get; init; &rbrace;</b> Not doing it will throw 
        a compiler error now.

        <p class="HeadingSubTopic2" HeadingSubTopicDir>Discard</p>
        You can use _ to discard things returned from a lambda expression or a method.
        <pre>
            <code>
                using System;

                Test t = new Test();
                Tuple&lt;string,string&gt; tp1 = t.SomeMethod();
                Console.WriteLine(tp1.Item1 +  "-" +  tp1.Item2);
                (_, string i2) = t.SomeMethod(); //disregard item1 and take only item2
                Console.WriteLine(i2); 

                public class Test&lbrace;;
                    public Tuple&lt;string, string&gt; SomeMethod()
                    &lbrace;   
                        System.Tuple&lt;string, string&gt; t1 = new Tuple&lt;string, string&gt;("First", "Second"); 
                        return t1; 
                    &rbrace; 
                &rbrace;
            </code>
        </pre>


    </div>
</div>