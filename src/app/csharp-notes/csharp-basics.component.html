<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">C# notes - Basics</h2>  
    <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
    <h4 class="CenterMe">You can type the C# code  
      <a class="CenterMe" href="https://replit.com/languages/csharp" target="_new">on replit.com</a> 
      to see how it works <br/>
   
    </h4>
  
    <br/>
                    
      
    <p class="HeadingSubTopic">Access Modifiers</p>

    <b>private: </b> Member is accessible only inside its type.<br/>
    <b>internal: </b> Accessible inside the type and any type in the same assembly.<br/>
    <b>protected: </b>Accessible inside the type, and types that inherit from it.<br/>
    <b>public: </b>Accessible everywhere.<br/>
    <b>internal protected: </b>Accessible inside the type, same assembly, and types that inherit from it. <br/>
    <b>private protected: </b>Accesible inside the type, and any inherited type that is IN the same assembly.<br/>
    
    <p class="HeadingSubTopic">null coalescing operator</p>
    <pre>
        <code >
            class Program &lbrace;
            &nbsp;static void Main(string[] args) &lbrace;
                &nbsp; &nbsp;    string theString = "hello";
                &nbsp; &nbsp;    string theOtherString = null;
                &nbsp; &nbsp;    Console.WriteLine(<b>theString ?? "Just Me"</b>); //hello
                &nbsp; &nbsp;    Console.WriteLine(theOtherString ?? "Just Me");//Just Me
                &nbsp; &rbrace;
             &rbrace;
        </code>
    </pre>
   
    
    <p class="HeadingSubTopic">operator overloading</p>
    This example is silly but it's just to illustrate how this works.  We have a clas SomeObj, and it has a method for the + of objects of that class:<br/>
    <pre>
        <code >
            ...
            public static SomeObj operator +(SomeObj o1, SomeObj o2)
            &lbrace;
            &nbsp; SomeObj newO = new SomeObj("");
            &nbsp;  newO.TheThing = o1.TheThing + "-" + o2.TheThing;
            &nbsp;  return newO;
            &rbrace;
            //to use 
            SomeObj obj1 = new SomeObj("hey");
            SomeObj obj2 = new SomeObj("helloooo");
            Console.WriteLine( (obj1 + obj2).TheThing);
        </code>
    </pre>  
    <br/>
    <img width="100%" src="assets\images\csharp\opoverloading1.png" alt="operator overloading" /><br/><br/>
    
    <p class="HeadingSubTopic">keywords as variables</p>
    <pre>
        <code>
            using System;

            &nbsp;class Program &lbrace;    

                &nbsp;&nbsp;   static void Main(string[] args) &lbrace;
                    &nbsp;&nbsp;  <b>string @if = "using if as a variable";</b>
                    &nbsp;&nbsp;  Console.WriteLine (@if);
                    &nbsp;  &rbrace;
            &rbrace;
        </code>
    </pre>
    
    <p class="HeadingSubTopic">Ignore/use special chars</p>

    <pre>
        <code>
            Console.WriteLine(@"blah blah \n \\hey ");//will print that same string

            Console.WriteLine("Hello tab coming up \t see?"); //will print a tab after up

            Console.WriteLine("c:\totals"); // prints c:      otals

            Console.WriteLine("c:\\totals"); // prints c:\totals
            
        </code>
    </pre>
    <br/>
    
    <p class="HeadingSubTopic">format strings with variables</p>
    <pre>
        <code>
            string fillIt = "Michael";
            <b>Console.WriteLine($"My name is &lbrace;fillIt&rbrace;");</b>
            //the one below uses C so it will print with currency format:
            decimal amount = 8.94m;
            <b>Console.WriteLine($"My amount is &lbrace;amount:C&rbrace;");</b>//My amount is $8.94

            int i = 10;
            int j = 20;

            Console.WriteLine( format: "Number i is &lbrace;0&rbrace; and number 2 is &lbrace;1&rbrace;", 	arg0:i, arg1:j);
            //prints Number i is 10 and number 2 is 20

            private const string _name = "Michael";
	        private const string _lname = "Jackson";
	        private const string _fullName =  $"&lbrace;_name&rbrace;&lbrace;_lname&rbrace;"; // in console it would be Michael Jackson.

            Console.WriteLine(String.Format("The current price is &lbrace;0&rbrace; per ounce.", 100));

            //the -10 and the 6 indicate the alignment of the argument.
		    //hardcoding the values here, instead of using variables for simplicity
		    Console.WriteLine(   format: "&lbrace;0,-10&rbrace; &lbrace;1,6&rbrace;",   arg0: "Name",   arg1: "Count");
		    Console.WriteLine(  format: "&lbrace;0, -10&rbrace; &lbrace;1, 6:N0&rbrace;",    arg0: "Bananas",    arg1: 5);
		    Console.WriteLine(  format: "&lbrace;0, -10&rbrace; &lbrace;1, 6:N0&rbrace;",   arg0: "Apples",   arg1: 12);
        </code>
    </pre>
    <br/>
    Use double instead of decimal when accuracy is not important, especially when comparing numbers.<br/>

    
    <p class="HeadingSubTopic">Some little things</p>
    <pre>
        <code>
            int i = 10_123;
            Console.WriteLine(i); //prints number 10123
            Console.WriteLine( $"Number is &lbrace;i:C&rbrace;");//prints $10,123.00

            checked&lbrace;
                //code that may result in an overflow, use the checked so we know if this happens, instead of it being ignored.
            &rbrace;
            //Also have the checked code inside a try catch so we can do something if the exception happens

            string  Method1(int i)
            &lbrace;
                if (i == 1)
                &lbrace;
                    return "One";
                &rbrace;else if (i == 2)
                &lbrace;
                    return "Two";
                    &rbrace;
                else
                &lbrace;
                    return "Something Else";
                    &rbrace;
                    &rbrace;

            static string Method2(int i) =>
                i switch
                &lbrace;
                    1 => "One", // what it will return
                    2 =>"Two",
                    _ => "Something Else"
                    &rbrace;;
        </code>
    </pre>
    C# has const and read only fields.  Const values have to be known at compile time, while read only fields can be set in the constructor.  Declare in the class, 
    set it in the constructor.<br/>
    With c#11 we have a <b>required</b> keyword: public required string Email &lbrace; get; set; &rbrace;.  If we do this, when we instantiate the class with the fields 
    marked as required, we will have to give values for them or we will get a compiler error.<br/><br/>
    We can have properties that can be instatiated once but not afterwards, for that we use the <b>init</b> keyword:<br/>
    <pre>
        <code>
            //have this property in class SomeClass.
            public string someS &lbrace; get; <b>init;</b> &rbrace;
            ...
            //the 2 lines below will <b>not compile</b>
            SomeClass theClass = new SomeClass();
            theClass.someS = "hey";
            ...
            //but the below <b>will compile</b> and print hey, but it cannot be set again
            SomeClass theClass = new()
            &lbrace;
                someS = "hey" //separate more with commas
            &rbrace;;
        </code>
    </pre>


    
    <p class="HeadingSubTopic">params argument</p>
    the params argument has to be the last one <br/>
    <pre>
        <code>
            class Program &lbrace;    

            &nbsp;  public static void SomeMethod(Int32 i, string s, <b> params string[] words</b>)&lbrace;
            &nbsp;  &nbsp;   Console.WriteLine(i);
            &nbsp;  &nbsp;   Console.WriteLine(s);
            &nbsp;  &nbsp;   Console.WriteLine(words.Length);
                &rbrace;
                  
                static void Main(string[] args) &lbrace;
                &nbsp;      SomeMethod(2, "hello",   "I","am","your","father");                  
                &rbrace;
            &rbrace;
        </code>
    </pre>
    Prints <br/>
    <pre>
        <samp>
        2
        hello
        4
        </samp>
    </pre>

    
    <p class="HeadingSubTopic">Default params</p>

    <pre>
        <code>
            public static void SomeMethod(Int32 i, string s, string def1 = "defaulted 1", string def2 = "defaulted 2")&lbrace;  
            &nbsp;  Console.WriteLine(def1);
            &nbsp;  Console.WriteLine(def2);
            &rbrace;
              
            static void Main(string[] args) &lbrace;
            &nbsp;   SomeMethod(2, "hello");
            &nbsp;   SomeMethod(2, "hello", "for 1");
              
            &rbrace;
        </code>
    </pre>
    Prints:<br/>
    <pre>
        <samp>
            defaulted 1
            defaulted 2
            for 1
            defaulted 2
        </samp>
    </pre>

    <p class="HeadingSubTopic">Default params</p>
    Parameters can be passed by value (default), by reference (<b>ref</b>), and as an <b>out</b> parameter.
    <br/>    
    <p class="HeadingSubTopic">Extension Methods</p>

    Extension methods have to be created, for a type, in a non-generic static class.  That is why I'm changing the class program to be static.  The 
    use of this indicates the one that will be the string that has the method.<br/>

    <pre>
        <code>
            using System;

            public static class Program &lbrace;   
            
                public static bool LenGreaterThan6 (<b>this</b> string s)&lbrace;
                &nbsp;return s.Length > 6;
                &rbrace;
                public static bool LenGreaterThanInput (<b>this</b> string   s, string input)&lbrace;
                &nbsp;return s.Length > input.Length;
                &rbrace;
            
                
                static void Main(string[] args) &lbrace;
                Console.WriteLine("IAm4".LenGreaterThan6());//false
                Console.WriteLine("IAmMuchMoreThan4Or6".LenGreaterThan6());//true
                Console.WriteLine("IAm4".LenGreaterThanInput("theInput"));//false
                Console.WriteLine("IAm4".LenGreaterThanInput("I"));//true
                &rbrace;
            &rbrace;
        </code>
    </pre>


    <br/>    
    <p class="HeadingSubTopic">Tuples</p>

    We have System.Tuple (reference, the data members are properties) and System.ValueTuple (value, the data members are fields).<br/>

    For the <b>System.tupple:</b><br/>
    <pre>
        <code>
            using System;

            public static class Program &lbrace;   

                &nbsp;public class Test&lbrace;
                &nbsp;&nbsp;public Tuple&lt;Int32&gt; intT = new Tuple&lt;Int32&gt;(100);
                &nbsp;&nbsp;public Tuple&lt;Int32, string&gt; intStringT = new Tuple&lt;Int32, string&gt;(1,"hey");
                &nbsp;&rbrace;;
        
                &nbsp;static void Main(string[] args) 
                &nbsp;&nbsp;Test t = new Test();
                &nbsp;&nbsp;Console.WriteLine(t.intT.Item1);//100
                &nbsp;&nbsp;Console.WriteLine(t.intStringT.Item2);//hey
                &rbrace;
            &rbrace;
        </code>
    </pre>
    You could also create the tuple this way:<br/>
    <code>
        var intT = Tuple.Create&lt;Int32&gt;(101);
    </code>

    <br/><br/>
    For the <b>System.ValueTuple</b><br/>
    <pre>
        <code>
            public (Int32, double) intT = (100, 4.5);//has to have more than 1 item.
            public (Int32, string) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.Item1);//100
            Console.WriteLine(t.intStringT.Item2);//hey
        </code>
    </pre>
    You could also name the items:<br/>
    <pre>
        <code>
            public (Int32 i , double d) intT = (100, 4.5);
            public (Int32 i , string s) intStringT = (1,"hey");
            ...
            Console.WriteLine(t.intT.d);//4.5
            Console.WriteLine(t.intStringT.s);//hey
        </code>
    </pre>
    You can use == and != to compare these tuples, but it will compare the values, meaning, the names given to the fields will not matter.<br/>

    We could also have this code:<br/>
    <pre>
        <code>
            public (int, string) GiveATuple() //return the tuple (int, string)
	        &lbrace;
		       return (1, "one");
	        &rbrace;
            ...
            (int, string) t = GiveATuple();
            Console.WriteLine(t.Item1); //as before, we have Item1, Item2 etc		        
        </code>
    </pre>
    Or we can also name what gets returned.  Notice we name the return, but also the return of the method itself.
    <pre>
        <code>
            public (int <b>num</b>, string <b>str</b>) GiveATuple()	        
            &lbrace;
		        return (<b>num:</b> 1, <b>str:</b> "one");
            &rbrace;
            ...
            var t = GiveATuple();
            Console.WriteLine(t.<b>str</b>);	        
        </code>
    </pre>
    <b>Deconstructing Tuples</b><br/>
    Using the same GiveATuple() as above, we could also do:
    <pre>
        <code>
            (int numero, string <b>cadena</b>)= GiveATuple();
            Console.WriteLine(<b>cadena</b>);		
        </code>
    </pre>

    <br/>    
    <p class="HeadingSubTopic">Generics</p>

    <pre>
        <code>
            public static class Program &lbrace;   

                public class <b>TestGen&lt;T&gt;</b>&lbrace;
            
                  public bool isItNull(<b>T theT</b>)&lbrace;
                    return theT == null;
                  &rbrace;
                &rbrace;
                  
                static void Main(string[] args) &lbrace;    
                  TestGen<b>&lt;string&gt;</b> t = new TestGen<b>&lt;string&gt;</b>();
                  TestGen&lt;Int32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                  Console.WriteLine(t.isItNull("hello"));//false
                  Console.WriteLine(t2.isItNull(3));//false
                  Console.WriteLine(t2.isItNull(null));//true
                &rbrace;            
        </code>
    </pre>
    <pre>
        <code>
            public static class Program &lbrace;   

                public class TestGen&lt;T&gt;&lbrace;
            
                 <b>public T Data &lbrace; get; set; &rbrace;</b>
                &rbrace;
                  
                static void Main(string[] args) &lbrace;     
                  TestGen&lt;string&gt; t = new TestGen&lt;string&gt;();
                  t.Data = "hello";
                  TestGen&lt;nt32?&gt; t2 = new TestGen&lt;Int32?&gt;();
                  t2.Data = 48;
                  Console.WriteLine(t.Data);//false
                  Console.WriteLine(t2.Data);//false      
                &rbrace;
            &rbrace;
        </code>
    </pre>
    Trying this instead would have given an error because an Int32? is expected: <b>t2.Data = "48";</b><br/>
    A generic class can be a base class to other generic or non-generic classes or abstract classes.<br/>
    You can have more than one type for a generic class (T, U ...)<br/>
    You can also indicate what the T can be, with something like this<br/>
    <pre>
        <code>
            public class TestGen&lt;T&gt; where T: WhateverClassOrType&lbrace;
            public class TestGen&lt;T,U&gt; where T: WhateverClassOrType where U:WhateverClassOrType&lbrace;
        </code>
    </pre>
    Above, we could also be using a class and an interface for each where.<br/>
    <br/>
    
    <p class="HeadingSubTopic">InottifyPropertyChanged</p>
    When you need to know that a property changed.<br/>

    <img width="100%" src="assets\images\csharp\INotifyPropertyChanged.png" alt="Notify property changed" /><br/><br/>

    A similar example for copy paste:<br/>
    <pre>
        <code>
            using System;
            <b>using System.ComponentModel;</b>

            public static class Program &lbrace;   

                public class WillChangeProperty:<b>INotifyPropertyChanged</b>&lbrace;
                
                    <b>public event PropertyChangedEventHandler PropertyChanged;</b>
                    private string _theData = "";
                    public string TheData &lbrace;
                        get&lbrace;
                        return this._theData ;
                        &rbrace;
                        set&lbrace;
                        this._theData = value;
                        <b>PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(this._theData));</b>
                        &rbrace;            
                    &rbrace;
                    <b>public void WhatToDoOnChange(object sender, PropertyChangedEventArgs e)&lbrace;</b>
                        Console.WriteLine("It changed!");
                    &rbrace;
                &rbrace;
                
                static void Main(string[] args) &rbrace;     
                    WillChangeProperty w = new WillChangeProperty();
                    <b>w.PropertyChanged += w.WhatToDoOnChange;</b>
                    w.TheData = "Hello";
                &rbrace;
            &rbrace;

        </code>
    </pre>

    <br/>
    <br/>
    
    <p class="HeadingSubTopic">IComparable</p>

    Implement it when you want to provide a method to compare your classes.<br/>
    <img width="100%" src="assets\images\csharp\IComparable.png" alt="IComparable" /><br/><br/>

    <pre>
        <code>
            public static class Program &&lbrace;;  

                public class WillCompare:<b>IComparable</b>&lbrace;
                  
                  public string TheData &lbrace;get;set;&rbrace;
                  <b>public int CompareTo(object o)</b>&lbrace;
                    <b>//same=0, o&gt; ret &gt;0, o&lt; ret &lt;0</b>
                    if (((WillCompare)o).TheData.Length == this.TheData.Length)&lbrace;
                      return 0;
                    &rbrace;else if (((WillCompare)o).TheData.Length > this.TheData.Length)&lbrace;
                    return 1;
                    &rbrace;else return -1;
                  &rbrace;
                &rbrace;
                  
                static void Main(string[] args) &lbrace;     
                     WillCompare w1 = new WillCompare();
                     w1.TheData = "hello";
                     WillCompare w2 = new WillCompare();
                     w2.TheData = "helloooo";
                     Console.WriteLine(<b>w1.CompareTo(w2)</b>);//1
                &rbrace;
            &rbrace;
            
        </code>
    </pre>
    <br/>

    Once you have the above, you can sort a list of objects and it will be sorted based on the CompareTo.<br/>
    With the same code as above:<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;     
                WillCompare w1 = new WillCompare();
                 w1.TheData = "hello";
             WillCompare w2 = new WillCompare();
                 w2.TheData = "helloooo";
             WillCompare w3 = new WillCompare();
                 w3.TheData = "hey";
             List&lt;WillCompare&gt; l = new List&lt;WillCompare&gt;();
             l.Add(w1);
             l.Add(w2);
             l.Add(w3);
             l.Sort();
             Console.WriteLine(l[0].TheData);//
             Console.WriteLine(l[1].TheData);//
             Console.WriteLine(l[2].TheData);//
           &rbrace;
        </code>
    </pre>
    <pre>
        <samp>
            helloooo
            hello
            hey
        </samp>
    </pre>
    Change the way you do the CompareTo if you want the sorting to be this way:<br/>
    <pre>
        <samp>
            hey
            hello
            helloooo
        </samp>
    </pre>

    
    <p class="HeadingSubTopic">IComparer</p>

    
    IComparable will help you in your sorting when you have control over the class you are sorting, 
    so you can have the CompareTo the way you like it. However, it is possible that you have the ObjectForComparing objects, 
    but instead of wanting the CompareTo in that class for your sort, now you want them sorting by some other way<br/>

    You still have this class as before, but I have added TheNumber<br/>
    <pre>
        <code>
            public class WillCompare:IComparable&lbrace;
      
                public string TheData &lbrace;get;set;&rbrace;
                <b>public Int32 TheNumber &lbrace;get;set;&rbrace;</b>
                public int CompareTo(object o)&lbrace;
                  //same=0, o&gt; ret &gt;0, o&lt; ret &lt;0
                  if (((WillCompare)o).TheData.Length == this.TheData.Length)&lbrace;
                    return 0;
                  &rbrace;else if (((WillCompare)o).TheData.Length &lt; this.TheData.Length)&lbrace;
                  return 1;
                  &rbrace;else return -1;
                &rbrace;
              &rbrace;
        </code>
    </pre>
    We add another class, implementing IComparer, which we will use to compare the WillCompare objects, instead of using the objects own CompareTo.
    We have to indicate what type of objects we will be using with this new class.  The Compare method here will just use the CompareTo of the Int32.<br/>
    <pre>
        <code>
            public class WillCompare2:<b>IComparer&lt;WillCompare&gt;</b>&lbrace;
                public int <b>Compare(WillCompare o1, WillCompare o2)</b>&lbrace;
                  return o1.TheNumber.CompareTo(o2.TheNumber)  ;
                &rbrace;
              &rbrace;
        </code>
    </pre>
    Now, to compare 2 WillCompare objects using this new Compare, and use it to sort the list, we would do this (I have changed all the strings 
    to hello so they are all the same):<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;     
                WillCompare w1 = new WillCompare();
                w1.TheData = "hello";
                w1.TheNumber = 100;
                WillCompare w2 = new WillCompare();
                w2.TheData = "hello";
                w2.TheNumber = 50;
                WillCompare w3 = new WillCompare();
                w3.TheData = "hello";
                w3.TheNumber = 200;
                
                List&lt;WillCompare&gt; l = new List&lt;WillCompare&gt;();
                l.Add(w1);
                l.Add(w2);
                l.Add(w3);

                WillCompare2 c2 = new WillCompare2();
                l.Sort(<b>c2</b>);
             
                Console.WriteLine(l[0].TheNumber);//50
                Console.WriteLine(l[1].TheNumber);//100
                Console.WriteLine(l[2].TheNumber);//200
           }
        </code>
    </pre>
    
    <p class="HeadingSubTopic">IEquitable</p>

    You know you can use equals to compare strings, and you want to have something similar for your class, with whatever criteria you want to use.<br/>
    The class that will have the Equals is this one, and notice that we are indicating the object have to be equaled to a string (could have been the object type or 
    anything else). Notice we consider the object equal to the string if the lengths match.<br/>
    <pre>
        <code>
            public class WillEquate:<b>IEquatable&lt;string&gt;&lbrace;</b>
      
                public string TheData &lbrace;get;set;&rbrace; 
                <b>public bool Equals(string s)&lbrace;</b>
                  if (this.TheData.Length == s.Length)&lbrace;
                    return true;
                  &rbrace;
                  return false;
                &rbrace;
              &rbrace;
        </code>
    </pre>
    And this is how we would use it<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;    
                WillEquate w1 = new WillEquate();
                w1.TheData = "five5";
                string s = "hello";
                string s2 = "hey";
                Console.WriteLine(<b>w1.Equals(s)</b>);//true
                Console.WriteLine(<b>w1.Equals(s2)</b>);//false
            &rbrace;
        </code>
    </pre>

    
    <p class="HeadingSubTopic">IEqualityComparer</p>

    Similar to the IEquatable, but you create it in another class and the method will take 2 arguments to compare.<br/>
    You create the class you will use to compare, and implement IEqualityComparer with whatever type you want to compare.  In the Equals, 
    take as arguments the object types and choose how you want to check if they are equal.<br/>
    To use it just create the objects you want to compare and the object for the class that will compare them.<br/>

    <img width="100%" src="assets\images\csharp\IEqualityComparer1.png" alt="IEquialityComparer" /><br/><br/>

    The above code is OK, but if you want the GetHashCode to work in accordance with the Equals, 
    so for instance you don’t get duplicate keys in a Dictionary, it should look more like this (notice the new Equals):<br/>

    <img width="100%" src="assets\images\csharp\IEqualityComparer2.png" alt="IEquialityComparer" /><br/><br/>


    
    <p class="HeadingSubTopic">IEnumerable</p>
    
    You need to add this when you want to be able to iterate through a custom <b>collection</b><br/>
    This is one way to do it:<br/>
    <pre>
        <code>
            using System;
            <b>using System.Collections;//Not Generic</b>
            using System.Collections.Generic;//for List

            public static class Program &lbrace;   

                public class MyObject
                &lbrace;
                    public string TheColor &lbrace; get; set; &rbrace;       
                &lbrace;
                public class MyObjectList: <b>IEnumerable&lbrace;</b>
      
                    List&lt;MyObject&gt; myl = new List&lt;MyObject&gt;();
                    public MyObjectList()&lbrace;
                    myl.Add(new MyObject&lbrace;TheColor="red"&rbrace;);
                    myl.Add(new MyObject&lbrace;TheColor="blue"&rbrace;);
                    myl.Add(new MyObject&lbrace;TheColor="yellow"&rbrace;);
                &rbrace;
                public <b>IEnumerator&lbrace;MyObject&rbrace; GetEnumerator()&lbrace;</b>
                    //could have used:
                    //<b>return myl.GetEnumerator();</b>
                    foreach (MyObject o in myl)&lbrace;
                    <b>yield return o;</b>
                &rbrace;
            &rbrace;
    
            <b>IEnumerator IEnumerable.GetEnumerator()&lbrace;</b>
                <b>return this.GetEnumerator();</b>
            &rbrace;
        &rbrace;
         
        static void Main(string[] args) &lbrace;     
            MyObjectList list = new MyObjectList();
            //foreach will be what GetEnumerator is returning.
            <b>foreach(MyObject mo in list)&lbrace;</b>
                Console.WriteLine(mo.TheColor);
            &rbrace;
            &rbrace;
        &rbrace;

        </code>
    </pre>
    In the code above we are just adding the objects to the list in the constructor, but in real code we will want to add them to the list from the 
    code that will be using the list.  So instead of adding them on the constructor, we would do this in the MyObjectList<br/>
    <pre>
        <code>
            public MyObject this[int index]&lbrace;
                get &lbrace;return myl[index];&rbrace;
                set &lbrace;myl.Insert(index, value);&rbrace;
              &rbrace;
        </code>
    </pre>
    And we will use this to create the list we are going to use<br/>
    <pre>
        <code>
            MyObjectList list = new MyObjectList();
            list[0] = new MyObject&lbrace;TheColor="red"&rbrace;;
            list[1] = new MyObject&lbrace;TheColor="blue"&rbrace;;
            list[2] =new MyObject&lbrace;TheColor="white"&rbrace;;
        </code>
    </pre>
    We could also have done this, or whatever we want for the method and populating the list:<br/>
    <pre>
        <code>
            public void Add (MyObject o)&lbrace;
                myl.Add(o);
              &rbrace;

             //and then to use it
             
             MyObjectList list = new MyObjectList();
            list.Add(new MyObject&lbrace;TheColor="red"&rbrace;);
            //etc
        </code>
    </pre>


    
    <p class="HeadingSubTopic">IEnumerator</p>
    IEnumerable and the use of foreach hide the complexity of the enumerator if you just use the enumerator of the list itself, like 
    in the examples above. But you can use your own Enumerator.<br/>
    Same example above but now using our own enumerator could look something like this.  Change the enumerator to be whatever you need it to be<br/>
    <pre>
        <code>
            using System;
            using System.Collections;//Not Generic
            using System.Collections.Generic;//for List
            
            public static class Program &lbrace;   
            
                public class MyObject
                &lbrace;
                    public string TheColor &lbrace; get; set; &rbrace;       
                &rbrace;
                
                public class MyObjectList: IEnumerable&lbrace;
                            
                    List&lt;MyObject&gt; myl = new List&lt;MyObject&gt;();
            
                    public void Add (MyObject o)&lbrace;
                        myl.Add(o);
                    &rbrace;
            
                    public IEnumerator&lt;MyObject&gt; GetEnumerator()&lbrace;        
                        <b>return new SomeEnumerator(myl);</b>
                    &rbrace;
                            
                    IEnumerator IEnumerable.GetEnumerator()&lbrace;
                        return this.GetEnumerator();
                    &rbrace;
                &rbrace;
            
                <b>public class SomeEnumerator:IEnumerator&lt;MyObject&gt; &lbrace;</b>
                    private int _index = -1;
                    public int current =&gt; this._index;
                    private List&lt;MyObject&gt; _l = null;
                    //MyObject IEnumerator&&lt;MyObject&gt;.Current =&gt; this._l[this._index];
                            
                    public SomeEnumerator(List&lt;MyObject&gt; l)&lbrace;
                        this._l = l;
                    &rbrace;
            
                    public void Dispose()&lbrace;&rbrace;
            
                    public bool MoveNext()&lbrace;       
                        this._index++;
                        if (this._index &lt; this._l.Count)&lbrace;
                            return true;        
                         &rbrace;else return false;
                    &rbrace;
            
                     public void Reset()&lbrace;
                        this._index = -1;
                    &rbrace;

                    MyObject IEnumerator&lt;MyObject&gt;.Current&lbrace;
                
                    <b>get &lbrace;     
                        this._l[this._index].TheColor += " Custom";
                        return this._l[this._index];
                        &rbrace;</b>
                    &rbrace;

                    object IEnumerator.Current
                        &lbrace;
                            get
                            &lbrace;          
                                return this._l[this._index];  //has to be implemented but not really coming here
                            &rbrace;
                        &rbrace;
                    &rbrace;
                &rbrace;
                                
               static void Main(string[] args) &lbrace;     
                    MyObjectList list = new MyObjectList();
                    list.Add(new MyObject &lbrace;TheColor="red"&rbrace;);
                    list.Add(new MyObject &lbrace;TheColor="blue"&rbrace;);
                    list.Add(new MyObject &lbrace;TheColor="white"&rbrace;);
                    foreach(MyObject mo in list)&lbrace;
                        Console.WriteLine(mo.TheColor);
                    &rbrace;
                &rbrace;
            &rbrace;

        </code>
    </pre>
    Will add Custom to the items before returning, to print:
    <pre>
        <samp>
            red Custom
            blue Custom
            white Custom 
        </samp>
    </pre>
    Instead of the code above, we could also have returned the current item with these changes in the IEnumerator:<br/>
    <pre>
        <code>
            public class SomeEnumerator:IEnumerator //without the &lt;MyObject&gt;

            ...

            MyObject Current&lbrace;

                get&lbrace;       
                  this._l[this._index].TheColor += " Custom";
                  return this._l[this._index];
                &rbrace;
             &rbrace;
             object IEnumerator.Current
             &lbrace;
                 get
                 &lbrace;           
                    return this.Current;                 
                  &rbrace;
             &rbrace;
        </code>
    </pre>
    But that means using the Enumerator has to be changed too:
    <pre>
        <code>
            public <b>IEnumerator</b> GetEnumerator()&lbrace;
                return new SomeEnumerator(myl) ;
            &rbrace;
        </code>
    </pre>

    
    <p class="HeadingSubTopic">Enums</p>

    Regular way to use an Enum<br/>
    <pre>
        <code>
            public enum SomeEnum&lbrace;
                first,
                second,
                third
            &rbrace;
        </code>
    </pre>
    Could also do this.  Here not making much sense but just showing you can change the values for the items<br/>
    <pre>
        <code>
            public enum SomeEnum&lbrace;
                first = 11,
                second = 12,
                third = 13
            &rbrace;
        </code>
    </pre>
    With the above code, if we were to use the enum, we could do this<br/>
    <pre>
        <code>
            SomeEnum e = SomeEnum.first;
            Console.WriteLine((int)e); // will print 11.
        </code>
    </pre>

    If we don't specify anything, the first element will start at zero.<br/>
    Usually the values are using int values, but we can also change it to use something else.  Like byte to use less memory.<br/>

    We can combine multiple values by using Flags.<br/>
    <pre>
        <code>
            [System.Flags]
            public enum SomeBinaryEnum:Byte&lbrace;
                one = 0b0001,//1
                two = 0b0010,//2
                three = 0b0011//3
            &rbrace;
        </code>
    </pre>
    With the above enum:<br/>
    <pre>
        <code>
            static void Main(string[] args) &lbrace;
                SomeBinaryEnum e = SomeBinaryEnum.one;
                Console.WriteLine((Byte)e); //prints 1
                Console.WriteLine(e);  //prints One
            &rbrace;
        </code>
    </pre>

    But on the above enum, one and two together will give the same as 3, so if we want to use flags, we should choose values that don't overlap:<br/>
    <pre>
        <code>
            [System.Flags]
            public enum SomeBinaryEnum:Byte&lbrace;
                one = 0b0001,
                two = 0b0010,
                <b>four = 0b0100</b>
            &rbrace;
        </code>
    </pre>
    With the above code, we can now do this:<br/>
    <pre>
        <code>
            SomeBinaryEnum e = SomeBinaryEnum.one |   SomeBinaryEnum.two; //values 0b0001 and 0b0010 , or 0b0011 (3)
            Console.WriteLine((Byte)e); // prints 3
            Console.WriteLine(e); <b>//prints one, two.</b>
        </code>
    </pre>
    Keep in mind that the type you can use for the enum will depend on how many values you are going to need.<br/>


    <p class="HeadingSubTopic">Records</p>
    Beginning with C#9 for a reference type, then with C#10 we can have <b>record class</b> for reference and <b>record struct</b> for value type.  Not 
    indicating class or struct will make it by reference.<br/>
    Records can be mutable (get and set) but they are usually used for immutable models.<br/>
    Positional properties are immutable in a record class and a readonly record struct. They're mutable in a record struct.<br/>
    <pre>
        <code>
            //reference because we are not saying struct (class by default)
            //PersonA gets the values assigned with the contructor, based in the order.
            public record PersonA(string FirstName, string LastName);
            //PersonB, just create and then assign by name
            public record PersonB
            &lbrace;	
                public string FirstName &lbrace; get; set; &rbrace; = default!;
                public string LastName &lbrace; get; set; &rbrace; = default!;
            &rbrace;;

	        public void SomeMethod()
	        &lbrace;
		        PersonA persona = new("Nancy", "Davoli");
		        PersonB personb = new();
		        personb.FirstName = "Nancia";
		        personb.LastName = "Davolia";
		        Console.WriteLine(persona.ToString());
		        Console.WriteLine(personb.ToString());
	        &rbrace;
        </code>
    </pre>
    You can also have it declared with the constructor but change the accessibility like this:
    <pre>
        <code>
            public record PersonC(string FirstName, string LastName, string Id)
            &lbrace;
                internal string Id &lbrace; get; init; &rbrace; = Id
            &rbrace;
            ...
            PersonC personc = new PersonC("Mark", "Knight", "1212");
            Console.WriteLine(personc.ToString()); // prints Mark, Knight
            Console.WriteLine(personc.Id); //prints 1212
        </code>
    </pre>
    Regarding the printing of Mark and Knight above, but not 1212: Record types have a compiler-generated ToString method that displays 
    the names and values of <b>public</b> properties and fields. <br/>
    You could also just have a few properties with its constructor and other properties inside (not positional ones)<br/>
    A positional record and a positional readonly record struct declare init-only properties. A positional record struct declares read-write properties. 
    You can override either of those defaults<br/>
    After initialization, you can't change the value of value-type properties or the reference of reference-type properties. 
    However, the data that a reference-type property refers to can be changed.<br/>
    For class types, two objects are equal if they refer to the same object in memory.<br/>
    For struct types, two objects are equal if they are of the same type and store the same values.<br/>
    For record types, including record struct and readonly record struct, two objects are equal if they are of the same type and store the same values.<br/>
    <br/>
    If you need to copy an instance with some modifications, you can use a with expression to achieve nondestructive mutation. A with expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.
    <pre>
        <code>
            public record PersonA(string FirstName, string LastName);
            ...
            PersonA persona = new("Nancy", "Davoli");
            PersonA persona2 = persona with &lbrace; FirstName = "John" &rbrace;;

            //prints
            //PersonA &lbrace; FirstName = Nancy, LastName = Davoli &rbrace;
            //PersonA &lbrace; FirstName = John, LastName = Davoli &rbrace;
        </code>
    </pre>
    The result of a with expression is a shallow copy, which means that for a reference property, 
    only the reference to an instance is copied. Both the original record and the copy end up with a reference to the same instance.<br/>
    A record can inherit from another record. However, a record can't inherit from a class, and a class can't inherit from a record.<br/>
    <pre>
        <code>
            public record Teacher(string FirstName, string LastName, int Grade): Person(FirstName, LastName);
        </code>
    </pre>
    For two record variables to be equal, the run-time type must be equal (not just the values, also the type).
    
    <p class="HeadingSubTopic">Pattern Matches - Switch</p>
    This is a bit of pattern matches with a focus on switch but not just that.<br/>
    Imagine we have a class Fruit and a class Apple like this:
    <pre>
        <code>
            public class Fruit
            &lbrace;
                public string? Name &lbrace; get; set; &rbrace;
                public string? Color &lbrace; get; set; &rbrace;
            &rbrace;
            public class Apple:Fruit
            &lbrace;
                public string? Type &lbrace; get; set; &rbrace;
            &rbrace;
            ...
            Fruit fruit = new Fruit();	
            Apple apple = new Apple();
            apple.Name = "Apple";
            apple.Color = "Green";
            apple.Type = "Fuji";
            ...
            fruit = apple;
            //to check before we can assume that the fruit is an apple
            <b>if (fruit.GetType() == typeof(Apple) && ((Apple)fruit).Type == "Fuji")</b>
            &lbrace;
                Console.WriteLine("the fruit is an Apple and it's a Fuji Apple");
            &rbrace;

            //We could also have done.
            <b>if (fruit is Apple)</b>            
        </code>
    </pre>
    Something else we can do, starting with C#7.<br/>
    <pre>
        <code>
            Fruit fruit = new Fruit();	
            
            Apple apple = new Apple();
            apple.Name = "Apple";
            apple.Color = "Green";
            apple.Type = "Fuji";

            Apple apple2 = new Apple();
            apple2.Name = "Apple";
            apple2.Color = "Red";
            apple2.Type = "Awesome";

            fruit = apple;

            switch (fruit)
            &lbrace;
                //theapple or whatever you want, just something so we can reference inside de code.
                <b>case Apple theapple:</b>
                    Console.WriteLine(theapple.Name);
                    Console.WriteLine(theapple.Color);
                    Console.WriteLine(theapple.Type);
                    break;
                default:
                    break;
            &rbrace;

            //the above will print Apple, Green, Fuji.
            //if the fruit above was not assigned an Apply type, it would go to the default.
        </code>
    </pre>

    Besides the type above, you can also match on some properties of the object<br/>
    <pre>
        <code>
            Fruit fruit = new Fruit();

            Apple apple = new Apple();
            apple.Name = "Apple";
            apple.Color = "Green";
            apple.Type = "Fuji";

            Apple apple2 = new Apple();
            apple2.Name = "Apple";
            apple2.Color = "Red";
            apple2.Type = "Awesome";

            fruit = apple;

            switch (fruit)
            &lbrace;
                //theapple or wahtever you want, just something so we can reference inside de code.
                //we are getting a warning because Color could be null, but just for what we are doing, we know it won't be.
                //our fruit is set to the Green apple, so this will go to not the apple or not red.
                <b>case Apple theapple when theapple.Color.Equals("Red"):</b>
                    Console.WriteLine(theapple.Name);
                    Console.WriteLine(theapple.Color);
                    Console.WriteLine(theapple.Type);
                    break;
                default:
                    Console.WriteLine("not the apple or not read");
                    break;
            &rbrace;
        </code>
    </pre>
    With C#8 we also have a switch expression instead of the typical switch statement as above.  With the classes and assignments as above:<br/>
    <pre>
        <code>
            var <b>theFruit</b> = fruit switch
            &lbrace;
                Apple <b>_ =></b> "This is an apple",
                <b>_ =></b> "This is not an apple"
            &rbrace;
            Console.WriteLine(<b>theFruit</b>);
        </code>
    </pre>
    We can also do something like this <br/>
    <pre>
        <code>
            public class Fruit
            &lbrace;
                public string? Name &lbrace; get; set; &rbrace;
                public string? Color &lbrace; get; set; &rbrace;
                public FruitType? FruitType &lbrace; get; set; &rbrace;

                //need to have this here to be able to use the switch this way
                public void <b>Deconstruct(out string? name, out string? color, out FruitType? ft)</b>
                &lbrace;
                    name = Name;
                    color = Color;
                    ft = FruitType;
                &rbrace;
            &rbrace;

            public class FruitType
            &lbrace;
                public string? TheType &lbrace; get; set; &rbrace;
            &rbrace;

            Fruit fruit = new Fruit();
            fruit.Name = "Orange";
            fruit.Color = "Orange";
            <b>fruit.FruitType = new FruitType();</b>
            fruit.FruitType.TheType = "Citric";

            //need the Deconstruct method in the class to be able to do this.  Otherwise gets an error.
            <b>var result = fruit switch</b>
            &lbrace;
                <b>Fruit("Orange", "Orange", null) => "Orange with no type",</b>
                Fruit("Orange", "Orange", _) => "Orange",
                _ => "Different"
            &rbrace;
            Console.WriteLine(result);//prints Orange
            //If we don't have a FruitType we will get  "orange with no type"
            //if the color was set to red, we would get Different.
        </code>
    </pre>
    We could also have something like this to check on the FruitType itself (note this doesn't cover all possible cases we can check for)
    <pre>
        <code>
            var result = fruit switch
            &lbrace;
                <b>&lbrace; FruitType: &lbrace; TheType: "Citric" &rbrace;&rbrace; => "Citric",</b>
                &lbrace; FruitType: null &rbrace; => "no type",		
            &rbrace;

            <b>//add this so we won't get an exception for a case that is not covered.
            _ => null,</b>
        </code>
    </pre>
    We can also use this on tuples, this example from the MS docs.
    <pre>
        <code>
            var newState = (state, operation, key.IsValid) switch
            &lbrace;
              (State.Opened, Operation.Close, _)      => State.Closed,
              (State.Opened, Operation.Open, _)       => throw new Exception(
                "Can't open an opened door"),
              (State.Opened, Operation.Lock, true)    => State.Locked,
              (State.Locked, Operation.Open, true)    => State.Opened,
              (State.Closed, Operation.Open, false)   => State.Locked,
              (State.Closed, Operation.Lock, true)    => State.Locked,
              (State.Closed, Operation.Close, _)      => throw new Exception(
                "Can't close a closed door"),
                  _ => state
            &rbrace;;
        </code>
    </pre>
    With C#9, for a when in the switch were you have more than one condition, you could do this:
    <pre>
        <code>
            //from this
            Developer dev when dev.YearOfBirth >= 1980 && dev.YearOfBirth &lt;= 1989 

            //to this
            Developer dev when dev.YearOfBirth <b>is</b> &gt;= 1980 <b>and</b> &lt;= 1989

            //could also do
            Developer &lbrace; YearOfBirth: &gt;= 1980 and &lt;= 1989 &rbrace; dev
        </code>
    </pre>
   
    <br/>
    Another example with c#8<br/>
    <pre>
        <code>
            ...
            Fruit fruit2 = new Fruit();
            fruit2.Name = "Apple";
            fruit2.price = 200;
            
            var result = <b>fruit2</b> switch
            &lbrace;
                <b>Fruit</b> f when f.price &lt;=100	<b>=&gt;</b> "Less than 100",
                Fruit f when f.price &lt;= 200 =&gt; "Less than 200",
                <b>Fruit =&gt;</b> "something else"
            &rbrace;;
            Console.WriteLine(result);// prints Less than 200
        </code>
    </pre>
    The same thing with C#9, in the switch itself<br/>
    <pre>
        <code>
            var result = fruit2 switch
            &lbrace;
                <b>Fruit f => f.price switch</b>
                &lbrace;
                    <b>&lt;= 100 =&gt; "Less than 100",</b>
                    &lt;= 200 =&gt; "Less than 200",
                    <b>_ =&gt;</b> "something else"
                &rbrace;
                //we could also have other types here checking for other things, inside of the same fruit2 switch (provided types are compatible)
            &rbrace;;
        </code>
    </pre>
    There is more than what is mentioned above, so check the documentation for more and for how to do it, or understand something you see.
</div>