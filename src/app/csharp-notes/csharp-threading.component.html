<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">C# notes - Threading</h2>  
    <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
    <h4 class="CenterMe">You can type the C# code  
      <a class="CenterMe" href="https://replit.com/languages/csharp" target="_new">on replit.com</a> 
      to see how it works <br/>
   
    </h4>
  
    <br/>
        
    <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
        <p>
          <a  href="/csharp-threading/#threads">Threads</a>
        <p>
        <p>
            <a  href="/csharp-threading/#tasks">Tasks and Parallel</a>
        <p>
            <p>
                <a  href="/csharp-threading/#await">Await</a>
            <p>
    </div>

    <div class="PaddedContents">
  
        <div id="threads"></div><br/>
        <hr class="hrHeaderClass" />
            <h2 class="CenterMe" >Threads</h2>
        <hr class="hrHeaderClass"/>
                
        
        A Thread is an object that represents a process running in the Operating System.
        <br/>
        Threads run in the foreground by default.  They will be run to completion so an application will not end while it has threads running.  <br/>
        Threads have a priority that can be changes as long as they are active.<br/>
        Threads cannot deliver results to another thread.  They need to pass data with shared variables (can introduce sync issues).
        <br/>
        Exceptions have to be caught inside the thread.<br/>

        <code><strong><u>Basics</u></strong></code><br /><br/>
        <pre>
            <code>
                using System;
                <b>using System.Threading;</b>

                class Program &lbrace;      
    
                    static void Main(string[] args) &lbrace;           
                        <b>Thread th = new Thread(() => &lbrace; Console.WriteLine("hello"); &rbrace;);</b>
                        <b>th.Start();</b>
                    &rbrace;
                &rbrace;
            </code>
        </pre>

        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th = new Thread(() => &lbrace;
                        <b>Thread.Sleep(3000);</b>
                        Console.WriteLine("hello"); 
                    &rbrace;);
                    th.Start();
                    <b>Console.WriteLine("Not In Thread");</b>
                &rbrace;;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                Not In Thread
                hello
            </samp>
        </pre>


        <code><strong><u>Passing Data to Threads</u></strong></code><br /><br/>
        If we need to pass data to a thread<br/>
        Pass data to thread 1 - ParameterizedThreadStart - Would work the same if using calling a method instead of a anonymous one.<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;

                    //can also use a method name instead of the anonymous method in the example.
                    <b>//ParameterizedThreadStart takes type object only.</b>
                    <b>ParameterizedThreadStart p = new ParameterizedThreadStart((object s) => &lbrace;    </b>
                    Console.WriteLine(s.ToString()); 
                    &rbrace;);    
                    Thread th = new Thread(<b>p</b>);
                    th.Start(<b>"Hello"</b>);      
                &rbrace;
            </code>
        </pre>
        Pass data to thread 2<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;  

                    Thread th = new Thread((Data) => &lbrace;       
                    Console.WriteLine(Data); 
                    &rbrace;);    
                    th.Start("This is it");                 
                &rbrace;
            </code>
        </pre>
        You can end a thread right away by calling it's Abort method.  This could leave resources hanging though.

        <br/>
        <code><strong><u>Wait on a thread</u></strong></code><br /><br/>
        <b>We can wait for a thread<br/></b>
        Like we saw before, this:
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th = new Thread(() => &lbrace;
                        <b>Thread.Sleep(3000);</b>
                        Console.WriteLine("hello"); 
                    &rbrace;);
                    th.Start();
                    <b>Console.WriteLine("Not In Thread");</b>
                &rbrace;;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                Not In Thread
                hello
            </samp>
        </pre>

        But this<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th = new Thread(() => &lbrace;
                        Thread.Sleep(3000);
                        Console.WriteLine("hello"); 
                    &rbrace;);
                    th.Start();
                    <b>th.Join();</b>
                    Console.WriteLine("Not In Thread");
            &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <code>
                hello
                Not In Thread
            </code>
        </pre>
        Because the main thread is going to wait on the th thread before it continues<br/>
        We can also have a thread waiting for another thread.<br/>
        This<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th_1 = new Thread(() => &lbrace;
                    <b>Thread.Sleep(3000);</b>
                    Console.WriteLine("th_1"); 
                    &rbrace;);
                    Thread th_2 = new Thread(() => &lbrace;             
                    Console.WriteLine("th_2"); <b>//no wait</b>
                    &rbrace;);
                    th_1.Start();
                    th_2.Start();
            &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                th_2
                th_1
            </samp>
        </pre>
        But, if we wait:<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th_1 = new Thread(() => &lbrace;
                        Thread.Sleep(3000);
                    Console.WriteLine("th_1"); 
                    &rbrace;);
                    Thread th_2 = new Thread(() => &lbrace;             
                    <b>th_1.Join(); </b>
                    Console.WriteLine("th_2"); 
                    &rbrace;);
                    th_1.Start();
                    th_2.Start();
            &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                th_1
                th_2
            </samp>
        </pre>

        <code><strong><u>Data Between Threads</u></strong></code><br /><br/>
        You don't really pass data from one thread to another thread.  But you can have data in a shared variable, and use lock to make sure it doesn't get messed up.
        A very simple example would be something like this.  You can also have one thread wait on the other one, to make sure the data will be there.
        The code is a bit silly but just focus on the highlighted parts<br/>
        <pre>
            <code>
                using System;
                using System.Threading;

                class Program &lbrace;      

                    public static string _something = string.Empty;
                    public static <b>object _lock</b> = new object();
                    
                    static void Main(string[] args) &lbrace; 

                        Thread th2 = new Thread(() => &lbrace; 
                        <b>lock(_lock)&lbrace;
                            _something = DateTime.Now.ToString();  
                        &rbrace;</b>
                        &rbrace;);
                    
                        Thread th1 = new Thread(() => &lbrace;     
                        <b>th2.Join();</b>
                        Console.WriteLine(_something); &rbrace;);
                            
                        th1.Start();
                        th2.Start();
                        
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        Can also do something like this<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;

                    Thread th2 = new Thread(() => &lbrace;  
                      <b>while (!_exit)&lbrace; //only while this is false</b>
                        lock(_lock)&lbrace;  //<b>lock it      </b>  
                          _something = DateTime.Now.ToString();  
                        &rbrace;
                      &rbrace;
                     Console.WriteLine("th2 done with while");
                    &rbrace;);
                  
                    Thread th1 = new Thread(() => &lbrace;
                      Console.WriteLine("here:" + _something);      
                      lock(_lock1)&lbrace;
                        Console.WriteLine("Setting exit");
                        <b>_exit = true; //set to false so th2 can finish</b>
                      &rbrace;
                    &rbrace;);
                
                    th2.Start();
                    th1.Start();   
                    th2.Join();//Have main wait for this to finish
                    Console.WriteLine(_something);
                  &rbrace;
            </code>
        </pre>
        Could print<br/>
        <pre>
            <samp>
                here:
                Setting exit
                th2 done with while
                1/23/2022 9:42:04 PM
            </samp>
        </pre>

        TODO revisit the lock, I thought maybe this would keep waiting:<br/>
        <pre>
            <code>
                using System;
            using System.Threading;

            class Program&lbrace;    

                public static string _something = string.Empty;
                public static object _lock = new object();
                public static object _lock1 = new object();
                public static bool _exit = false;
                
                static void Main(string[] args) &lbrace; 

                    Thread th2 = new Thread(() => &lbrace;  
                    while (!_exit)&lbrace; //only while this is false
                        lock(_lock)&lbrace;  //lock it        
                        _something = DateTime.Now.ToString();  
                        &rbrace;
                    &rbrace;
                    Console.WriteLine("th2 done with while");
                    &rbrace;);
                
                    Thread th1 = new Thread(() => &lbrace;  
                    lock(_lock)&lbrace;  //lock it 
                        _something = "trying";      
                    &rbrace;
                    Thread.Sleep(1000);
                    _exit = true; //set to false so th2 can finish      
                    &rbrace;);

                    th2.Start();
                    th1.Start();   
                    
                    th2.Join();//Have main wait for this to finish
                    th1.Join();
                    Console.WriteLine(_something);
                &rbrace;
            &rbrace;
            </code>
        </pre>
        Prints:<br/>
        <pre>
            <samp>
                th2 done with while
                1/23/2022 9:59:54 PM
            </samp>
        </pre>

        <div id="tasks"></div><br/>
        <hr class="hrHeaderClass" />
            <h2 class="CenterMe" >Tasks</h2>
        <hr class="hrHeaderClass"/>
        
        <code><strong><u>Tasks and Parallel.Invoke</u></strong></code><br /><br/>
        A Task is an object that represents a job (method) that's going to be performed.
        <br/>
        Tasks are created as background processes, so they can be ended even before completion if the foreground processes 
        complete (there is no code waiting for the tasks.)<br/>
        Tasks cannot set a priority.<br/>
        Tasks provide Exception Aggregation<br/><br/>
        We can launch tasks with Action delegates or launching the methods themselves.  This can be anonymous methods or calling a regular method.
        The code looks shorter with anonymous so I'm using that often, but it doesn't mean it's preferred.<br/>
        <pre>
            <code>
                using System;
                using System.Threading;
                <b>using System.Threading.Tasks;</b>

                class Program &lbrace;      

                    static void Main(string[] args) &lbrace;            
                        <b>Action task1</b> = new Action( () => &lbrace;
                            Thread.Sleep(2000);
                            Console.WriteLine("task1");
                        &rbrace;);

                        Action task2 = new Action( () => Console.WriteLine("task2"));

                        <b>Parallel.Invoke (task1, task2);</b>
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                task2
                task1
            </samp>
        </pre>
        We could have also done<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;                 

                    Parallel.Invoke ( 
                      () => &lbrace; Thread.Sleep(2000); Console.WriteLine("task1");&rbrace;, 
                      () => Console.WriteLine("task2"));
                &rbrace;
            </code>
        </pre>
        Invoke waits for all tasks to be done.<br/>


        <code><strong><u>More Parallel</u></strong></code><br /><br/>

        <pre>
            <code>
                using System;
                using System.Collections.Generic;
                using System.Threading.Tasks;

                class Program &lbrace;
                    static void Main(string[] args) &lbrace;
                        List&lt;string&gt; l = new List&lt;string&gt;();

                        l.Add("1");
                        l.Add("2");
                        l.Add("3");
                        l.Add("4");
                        l.Add("5");

                        <b>Parallel.ForEach</b>(l, (item) => Console.WriteLine(item) );
                    &rbrace;
            &rbrace;
            </code>
        </pre>
        The foreach doesn't guarantee the order of the items.  In the case above, I got this<br/>
        <pre>
            <samp>
                1
                5
                4
                2
                3
            </samp>
        </pre>

        Could do the same thing with a for. For the code above, instead of the foreach, this<br/>
        <pre>
            <code>
                <b>//Notice that the 0 is inclusive, but the 2nd argument is EXCLUSIVE, so don't subtract 1.</b>
                Parallel.For(0, <b>l.Count</b>, (i) => Console.WriteLine(i + "-" + l[i]) );
            </code>
        </pre>
        Will print <br/>
        <pre>
            <samp>
                0-1
                4-5
                3-4
                1-2
                2-3
            </samp>
        </pre>

        We can also have a for and a condition to stop it<br/>
        <pre>
            <code>
                ParallelLoopResult res =  Parallel.For(0, l.Count, 
                                            (<b>int i, ParallelLoopState st</b>) => &lbrace;
                                                Console.WriteLine(i + "-" + l[i]) ;
                                                if (i == 2) &lbrace;st.Stop();&rbrace;
                                            &rbrace;);
                Console.WriteLine(res.ToString());                
            </code>
        </pre>
        Prints<br/>
        <pre>
            <samp>
                0-1
                1-2
                2-3
                System.Threading.Tasks.ParallelLoopResult
            </samp>
        </pre>

        Note:On replit where I'm doing this, if I don't get the ParallelLoopResult res = (if I don't check the result), then the loop is not stopping.<br/>
        The ParallelLoopState can also be used with the foreach.<br/>

        Can also use parallel programming with linq<br/>
        <pre>
            <code>
                using System;
                using System.Collections.Generic;
                using System.Threading.Tasks;
                <b>using System.Linq;</b>

                class Program &lbrace;
                    static void Main(string[] args) &lbrace;
                        List&lt;string&gt; l = new List&lt;string&gt;();

                        l.Add("1");
                        l.Add("2");
                        l.Add("3");
                        l.Add("4");
                        l.Add("5");

                        <b>var res = from item in l.AsParallel()
                        where (item == "2" || item == "4")
                        select item;</b>

                        foreach (string s in res)
                            Console.WriteLine(s);
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        prints<br/>
        <pre>
            <samp>
                2
                4
            </samp>
        </pre>

        You can do <b>.AsParallel().AsOrdered()</b> to preserve the order.  That will process however and sort at the end. To process sequentially  use 
        <b>AsSequential()</b><br/>
        We can also start the iteration among the results before it has completed, if we do this:
        res.ForAll(p => &lbrace; Console.WriteLine(p.Age); &rbrace;);<br/>

        If any queries throw exceptions they will be thrown as an AggregateException at the end.<br/>

        Remember to use <b>locks</b> for variables that are going to be used by different processes/threads. It is a good idea to use an object as the lock, don't use a string.<br/>        

        We could also use Monitor.Enter and Monitor.Exit to enclose the code that needs to be thread safe.  If the code can throw an exception, 
        have the code in a catch and the Monitor.Exit in the finally.  Using monitors instead of locks lets the program check whether the variable or whatever is going to be locked if  (Monitor.TryEnter(…)--> the if will have if it is available, the else if it is locked, so we can do something else in that case.

        <br/>

        We can wait for a task to be done :<br/>
        <pre>
            <code>
                Task newTask = new Task(  () => &lbrace; Thread.Sleep(2000);   Console.WriteLine("I am the new task"); &rbrace;);

                newTask.Start();
                newTask.Wait();

                Console.WriteLine("Done");

            </code>
        </pre>
        A task can also return a result.  Use Run in that case.
        <pre>
            <code>
                private void Tasks_Click(object sender, EventArgs e)
                &lbrace;
                    Task&lt;String&gt; newTask = Task.Run(  () => &lt; Thread.Sleep(2000);  return ("I am the new task"); &gt;);                            
                    newTask.Wait();        
                    Console.WriteLine(newTask.Result);                
                &rbrace;
            </code>
        </pre>
        You can also wait for a bunch of tasks: Task.WaitAll(array or list of tasks to wait on).<br/>
        We can also continue one task with another one with ContinueWith<br/>TODO
        
        <img width="100%" src="assets\images\csharp\ContinueWith.png" alt="ContinueWith" /><br/><br/>
        A parent task can create other child tasks, they can be attached or unattached.  If they are attached, the task will not complete until the children are done.
        <br/>

        <img width="100%" src="assets\images\csharp\taskattach.png" alt="attach" /><br/><br/>
        When using Tasks and Threads we cannot update an element on a view because they run on different threads.  


        <div id="await"></div><br/>
        <hr class="hrHeaderClass" />
            <h2 class="CenterMe" >Await</h2>
        <hr class="hrHeaderClass"/>

   </div>
</div>