<div class="PaddedContents">

    <br/>
    <h2 class="CenterMe">C# notes - Threading</h2>  
    <h4 class="CenterMe">Naming is not always according to standard but I thought it was simpler.</h4>      
    <h4 class="CenterMe">You can type the C# code  
      <a class="CenterMe" href="https://replit.com/languages/csharp" target="_new">on replit.com</a> 
      to see how it works <br/>
   
    </h4>
  
    <br/>
        
    <div style="position:fixed; left:12px; top: 10vh; width:8vw; ">
        <p>
          <a  href="/csharp-threading/#threads">Threads</a>
        <p>
        <p>
            <a  href="/csharp-threading/#tasks">Tasks and Parallel</a>
        <p>
       
    </div>

    <div class="PaddedContents">
  
        <div id="threads"></div><br/>
        <hr class="hrHeaderClass" />
            <h2 class="CenterMe" >Threads</h2>
        <hr class="hrHeaderClass"/>
                
        
        A Thread is an object that represents a process running in the Operating System.
        <br/>
        Threads run in the foreground by default.  They will be run to completion so an application will not end while it has threads running.  <br/>
        Threads have a priority that can be changes as long as they are active.<br/>
        Threads cannot deliver results to another thread.  They need to pass data with shared variables (can introduce sync issues).
        <br/>
        Exceptions have to be caught inside the thread.<br/>

        <code><strong><u>Basics</u></strong></code><br /><br/>
        <pre>
            <code>
                using System;
                <b>using System.Threading;</b>

                class Program &lbrace;      
    
                    static void Main(string[] args) &lbrace;           
                        <b>Thread th = new Thread(() => &lbrace; Console.WriteLine("hello"); &rbrace;);</b>
                        <b>th.Start();</b>
                    &rbrace;
                &rbrace;
            </code>
        </pre>

        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th = new Thread(() => &lbrace;
                        <b>Thread.Sleep(3000);</b>
                        Console.WriteLine("hello"); 
                    &rbrace;);
                    th.Start();
                    <b>Console.WriteLine("Not In Thread");</b>
                &rbrace;;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                Not In Thread
                hello
            </samp>
        </pre>


        <code><strong><u>Passing Data to Threads</u></strong></code><br /><br/>
        If we need to pass data to a thread<br/>
        Pass data to thread 1 - ParameterizedThreadStart - Would work the same if using calling a method instead of a anonymous one.<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;

                    //can also use a method name instead of the anonymous method in the example.
                    <b>//ParameterizedThreadStart takes type object only.</b>
                    <b>ParameterizedThreadStart p = new ParameterizedThreadStart((object s) => &lbrace;    </b>
                    Console.WriteLine(s.ToString()); 
                    &rbrace;);    
                    Thread th = new Thread(<b>p</b>);
                    th.Start(<b>"Hello"</b>);      
                &rbrace;
            </code>
        </pre>
        Pass data to thread 2<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;  

                    Thread th = new Thread((Data) => &lbrace;       
                    Console.WriteLine(Data); 
                    &rbrace;);    
                    th.Start("This is it");                 
                &rbrace;
            </code>
        </pre>
        You can end a thread right away by calling it's Abort method.  This could leave resources hanging though.

        <br/>
        <code><strong><u>Wait on a thread</u></strong></code><br /><br/>
        <b>We can wait for a thread<br/></b>
        Like we saw before, this:
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th = new Thread(() => &lbrace;
                        <b>Thread.Sleep(3000);</b>
                        Console.WriteLine("hello"); 
                    &rbrace;);
                    th.Start();
                    <b>Console.WriteLine("Not In Thread");</b>
                &rbrace;;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                Not In Thread
                hello
            </samp>
        </pre>

        But this<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th = new Thread(() => &lbrace;
                        Thread.Sleep(3000);
                        Console.WriteLine("hello"); 
                    &rbrace;);
                    th.Start();
                    <b>th.Join();</b>
                    Console.WriteLine("Not In Thread");
            &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <code>
                hello
                Not In Thread
            </code>
        </pre>
        Because the main thread is going to wait on the th thread before it continues<br/>
        We can also have a thread waiting for another thread.<br/>
        This<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th_1 = new Thread(() => &lbrace;
                    <b>Thread.Sleep(3000);</b>
                    Console.WriteLine("th_1"); 
                    &rbrace;);
                    Thread th_2 = new Thread(() => &lbrace;             
                    Console.WriteLine("th_2"); <b>//no wait</b>
                    &rbrace;);
                    th_1.Start();
                    th_2.Start();
            &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                th_2
                th_1
            </samp>
        </pre>
        But, if we wait:<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;            
                    Thread th_1 = new Thread(() => &lbrace;
                        Thread.Sleep(3000);
                    Console.WriteLine("th_1"); 
                    &rbrace;);
                    Thread th_2 = new Thread(() => &lbrace;             
                    <b>th_1.Join(); </b>
                    Console.WriteLine("th_2"); 
                    &rbrace;);
                    th_1.Start();
                    th_2.Start();
            &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                th_1
                th_2
            </samp>
        </pre>

        <code><strong><u>TODO</u></strong></code><br /><br/>
        TODO thread passing data to another thread.

        <div id="tasks"></div><br/>
        <hr class="hrHeaderClass" />
            <h2 class="CenterMe" >Tasks</h2>
        <hr class="hrHeaderClass"/>
        
        <code><strong><u>Tasks and Parallel.Invoke</u></strong></code><br /><br/>
        A Task is an object that represents a job (method) that's going to be performed.
        <br/>
        Tasks are created as background processes, so they can be ended even before completion if the foreground processes 
        complete (there is no code waiting for the tasks.)<br/>
        Tasks cannot set a priority.<br/>
        Tasks provide Exception Aggregation<br/><br/>
        We can launch tasks with Action delegates or launching the methods themselves.  This can be anonymous methods or calling a regular method.
        The code looks shorter with anonymous so I'm using that often, but it doesn't mean it's preferred.<br/>
        <pre>
            <code>
                using System;
                using System.Threading;
                <b>using System.Threading.Tasks;</b>

                class Program &lbrace;      

                    static void Main(string[] args) &lbrace;            
                        <b>Action task1</b> = new Action( () => &lbrace;
                            Thread.Sleep(2000);
                            Console.WriteLine("task1");
                        &rbrace;);

                        Action task2 = new Action( () => Console.WriteLine("task2"));

                        <b>Parallel.Invoke (task1, task2);</b>
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        Will print<br/>
        <pre>
            <samp>
                task2
                task1
            </samp>
        </pre>
        We could have also done<br/>
        <pre>
            <code>
                static void Main(string[] args) &lbrace;                 

                    Parallel.Invoke ( 
                      () => &lbrace; Thread.Sleep(2000); Console.WriteLine("task1");&rbrace;, 
                      () => Console.WriteLine("task2"));
                &rbrace;
            </code>
        </pre>
        Invoke waits for all tasks to be done.<br/>


        <code><strong><u>More Parallel</u></strong></code><br /><br/>

        <pre>
            <code>
                using System;
                using System.Collections.Generic;
                using System.Threading.Tasks;

                class Program &lbrace;
                    static void Main(string[] args) &lbrace;
                        List&lt;string&gt; l = new List&lt;string&gt;();

                        l.Add("1");
                        l.Add("2");
                        l.Add("3");
                        l.Add("4");
                        l.Add("5");

                        <b>Parallel.ForEach</b>(l, (item) => Console.WriteLine(item) );
                    &rbrace;
            &rbrace;
            </code>
        </pre>
        The foreach doesn't guarantee the order of the items.  In the case above, I got this<br/>
        <pre>
            <samp>
                1
                5
                4
                2
                3
            </samp>
        </pre>

        Could do the same thing with a for. For the code above, instead of the foreach, this<br/>
        <pre>
            <code>
                <b>//Notice that the 0 is inclusive, but the 2nd argument is EXCLUSIVE, so don't subtract 1.</b>
                Parallel.For(0, <b>l.Count</b>, (i) => Console.WriteLine(i + "-" + l[i]) );
            </code>
        </pre>
        Will print <br/>
        <pre>
            <samp>
                0-1
                4-5
                3-4
                1-2
                2-3
            </samp>
        </pre>

        We can also have a for and a condition to stop it<br/>
        <pre>
            <code>
                ParallelLoopResult res =  Parallel.For(0, l.Count, 
                                            (<b>int i, ParallelLoopState st</b>) => &lbrace;
                                                Console.WriteLine(i + "-" + l[i]) ;
                                                if (i == 2) &lbrace;st.Stop();&rbrace;
                                            &rbrace;);
                Console.WriteLine(res.ToString());                
            </code>
        </pre>
        Prints<br/>
        <pre>
            <samp>
                0-1
                1-2
                2-3
                System.Threading.Tasks.ParallelLoopResult
            </samp>
        </pre>

        Note:On replit where I'm doing this, if I don't get the ParallelLoopResult res = (if I don't check the result), then the loop is not stopping.<br/>
        The ParallelLoopState can also be used with the foreach.<br/>

        Can also use parallel programming with linq<br/>
        <pre>
            <code>
                using System;
                using System.Collections.Generic;
                using System.Threading.Tasks;
                <b>using System.Linq;</b>

                class Program &lbrace;
                    static void Main(string[] args) &lbrace;
                        List&lt;string&gt; l = new List&lt;string&gt;();

                        l.Add("1");
                        l.Add("2");
                        l.Add("3");
                        l.Add("4");
                        l.Add("5");

                        <b>var res = from item in l.AsParallel()
                        where (item == "2" || item == "4")
                        select item;</b>

                        foreach (string s in res)
                            Console.WriteLine(s);
                    &rbrace;
                &rbrace;
            </code>
        </pre>
        prints<br/>
        <pre>
            <samp>
                2
                4
            </samp>
        </pre>
        <!--<img width="100%" src="assets\images\csharp\opoverloading1.png" alt="operator overloading" /><br/><br/>-->

   </div>
</div>