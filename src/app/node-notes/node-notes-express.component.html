
<div class="PaddedContents">

  <div class="leftLinks" #HeadingsContainer>      
    <left-links ></left-links>      
  </div>  

  <br/>  
  
  <div class="PaddedContents PaddedContentsTopics">
    
    <p class="HeadingSubTopic" id="general">General</p>
    This is a package you can install to help you with your node project. (npm install express, or npm install --save express<br/>
    Once installed, you have a "express": "^4.17.3", under your dependencies in your packagage.json file.  If your project doesn't have a packagage.json file, 
    you can create one or copy it from somewhere else and clean it up, then run the install again and it will be updated.<br/>
    Then use it with <b>const express = require('express');</b><br/>
    Then you can do <b>const app = express();</b> and then create the server with it <b>const server = http.createServer(app);</b>
    With the above we have a functioning server but we don't have how to respond to requests yet.<br/>
    You would do something like this to add that:<br/>
    <pre>
      <code>
        const app = express();

        app.use( (req, res, next) => &lbrace;
          console.log("hello") ;
          next(); //it will move on to the next instruction below
        &rbrace; );

        app.use( (req, res, next) => &lbrace;
          console.log("AFTER NEXT") ;    
        &rbrace; );

        const server = http.createServer(app);
        server.listen(3000);
      </code>
    </pre>
    Express will not send a default response. Instead of logging in the console (which shows in your server console not the browser), we could 
    have done <code> res.send("&lt;h2&gt;Hello how are you&lt;/h2&gt;");</code> We get the default html/text but we can override it with res.setHeader.<br/>
    Notice in the code above we have <code>const server = http.createServer(app); </code> and <code>server.listen(3000);</code><br/>
    We can also do just this instead of those 2 above: <code>app.listen(3000);</code>
    <b>Remember that if we don't have a next() in the code, the next app.use is not going to happen, but, if we are using paths the code will be checked 
    from top to bottom to see which use to use. </b><br/>
    Bellow, entering localhost:3000/sayhi will return HI, localhost:3000/sayhello will return HELLO, and entering <b>nothing or anything else</b> will return ANYTHING.
    <br/><br/>
    <pre>
      <code>
        const app = express();

        app.use(<b> "/sayhi"</b>, (req, res, next) => &lbrace;    
          res.send("&lt;h2&gt;HI&lt;/h2&gt;");
        &rbrace; );

        app.use(<b>"/sayhello"</b>, (req, res, next) => &lbrace;
          res.send("&lt;h2>HELLO!&lt;&gt;h2>");
        &rbrace; );

        app.use( <b>"/"</b>, (req, res, next) => &lbrace;
          res.send("&lt;h2>ANYTHING!&lt;&gt;h2>");
        &rbrace; );

        app.listen(3000);
      </code>
    </pre>
    Look also at this code which will not work OK.
    <br/> <b>Some of the code here has the / path at the start, that is not the right way, it's just to see the examples</b><br/>
    <pre>
      <code>
        const http = require("http");
        const express = require('express');

        const app = express();

        //For localhost on the browser.  we will end up with "anything" in the console.  
        //And the ANYTHING response in the browser. 
        //if localhost/sayhi, we see "anything" in the console, then we see "sayhi" in the console, 
        //but then we get a <b>"cannot set headers after they are sent to the client" error.</b>
        //<b>Because we have the / path at the beginning it's going to match it even for localhost/sayhi</b>
        app.use( "/", (req, res, next) => &lbrace;
          console.log("anything");
          res.send("&lt;h2&gt;ANYTHING!&lt;/h2&gt;");
          next(); 
        &rbrace; );


        app.use( "/sayhi", (req, res, next) => &lbrace;
          console.log("sayhi");
          res.send("&lt;h2&gt;HI&lt;/h2&gt;");
          next();
        &rbrace; );

        app.use("/sayhello", (req, res, next) => &lbrace;
          console.log("sayhello");
          res.send("&lt;h2&gt;HELLO!&lt;/h2&gt;");
        &rbrace; );

        app.listen(3000);
      </code>
    </pre>    
    With the res.send on the / path commented out, by doing localhost/sayhi we get "anything" and "sayhi" in the console, and the HI in the browser.  So both 
    the / and the sayhi paths will happen, but we don't have a send on the / path so this doesn't break.<br/><br/>

    Now I want to try having 2 /sayhi ones, though only the second one will send a response.<br/>
    <pre>
      <code>
        const http = require("http");
        const express = require('express');

        const app = express();       
        
        app.use( "/", (req, res, next) => &lbrace;
          console.log("anything"); //NO SEND HERE        
          next(); 
        &rbrace; );


        app.use( "/sayhi", (req, res, next) => &lbrace;
          console.log("sayhi");
          //NO SEND
          next();
        &rbrace; );

        app.use( "/sayhi", (req, res, next) => &lbrace;
          console.log("sayhi 2nd");
          res.send("&lt;h2&gt;HI 2ND&lt;/h2&gt;");
          next();
        &rbrace; );

        app.use("/sayhello", (req, res, next) => &lbrace;
          console.log("sayhello");
          res.send("&lt;h2&gt;HELLO!&lt;/h2&gt;");
        &rbrace; );

        app.listen(3000);
      </code>
    </pre>
    In the above code, still doing localhost/sayhi,  the console will show:
    <pre>
      <samp>
        anything
        sayhi
        sayhi 2nd
      </samp>
    </pre>
    And the browser will have HI 2ND.  Doing localhost with the code above will print "anything" in the console and error GET on the browser.<br/>    
  
  
    Similar to the above code but not having the next in the first sayhi:
    <pre>
      <code>
       app.use( "/sayhi", (req, res, next) => &lbrace;
         console.log("sayhi");        
       &rbrace; );
 
       app.use( "/sayhi", (req, res, next) => &lbrace;
         console.log("sayhi2");
         res.send("&lt;h2&gt;HI&lt;/h2&gt;");
         next();
       &rbrace; );
      </code>
    </pre>
    The above code will print only sayhi and will leave the browser hanging because we are not sending anything back after printing sayhi 
    (no next() after the first sayhi either so it's not going to the second sayhi).
    <br/><br/>
    <b>It is best to leave the "/" path for the end.  The above was just to see what happens.  Put it as the last one!!</b>

    <b>Keep in mind when we do next() next() next() it still has to match the url provided to get in the app.use</b>
    <p class="HeadingSubTopic" id="Incoming-Req">Parsing Incoming Requests</p>

    We can send html code in a response.  And with that we can send an action to be taking from that code.
    <pre>
      <code>
        const http = require("http");        
        const express = require('express');

        const app = express();

        app.use( "/", (req, res, next) => &lbrace;            
          res.send("&lt;html&gt;&lt;form <b>action='hello' method='GET'</b>&gt;&lt;button&gt;here&lt;/button&gt;<&lt;form&gt;&lt;/html&gt;")
          next(); 
        &rbrace; );
      </code>
    </pre>
    Then you can have an action for the hello, that redirects somewhere else.  In this case, clicking on the button will go to hello which will redirect to sayhi.
    <pre>
      <code>
        app.use( "/", (req, res, next) => &lbrace;
          next(); 
        &rbrace; );

        app.use( "/hey", (req,res, next) => &lbrace;
          res.send('...form action="/hello" method="GET"... as above')
        &rbrace;)

        app.use( "/hello", (req, res, next) => &lbrace;
          res.<b>redirect("sayhi");</b>
        &rbrace; );

        app.use( "/sayhi", (req, res, next) => &lbrace;
          res.send("whatever");     
        &rbrace; );
      </code>
    </pre>
    req with express comes with a body, but, <b>if we don't do any parsing to it, it's just undefined.</b><br/>
    To parse there is an additional tool that can be installed:  <b>npm install --save body-parser</b>. You may not need to install it if the version 
    of Express you are using already has it included.  Before use, include it with <b>const bodyParser = require("body-parser")</b><br/>
    You may need different parsers depending on the type of body you are getting.  For the above, add this to the top of the file (before the app.use routing statements).
    <b>app.use(bodyParser.urlencoded());</b>  Note that the urlencoded is used with request from forms.  You can also use the bodyParser without that urlencoded part.<br/>
    Once you have that, you can log req.body on your routing app.use and you will see the contents. 
    Note: You may get a "body-parser deprecated bodyParser: use individual json/urlencoded middlewares".  You can also do:
    app.use(bodyParser.urlencoded(&lbrace;extended:false&rbrace;));<br/>
    You can also just use the json parser from express: <b>app.use(express.json())</b>  Also has it for forms (app.use(express.urlencoded(&lbrace; extended: true &rbrace;));)
    

    <p class="HeadingSubTopic" id="Request-Types">Differentiate between types of requests - methods GET POST etc</p>
    If you have a route that is only for GET requests, you can use <b>app.get</b> instead of app.use (the rest is the same). Same thing for POST, use <b>use.post.</b>
    
    <p class="HeadingSubTopic" id="Paths">Express - Paths</p>

    With express we can move our routing to another file (routes or whatever you want to name it). To do that, in those new files import also Express (require('express'))
    and then make use of its router <b>const router.express.Router()</b>.<br/>
    Once you do that, you should have statements similar to the ones you have with app.use (or app.get and app.post) but instead of app.use you will use router.use.<br/>
    <pre>
      <code>
        const express = require('express');

        const router = express.Router();

        router.use ( '/add', (req,res, next) => &lbrace;
          res.send('whatever ');
        &rbrace;);

        //at the end
        module.exports = router;
      </code>
    </pre>
    Now you can import it in your main file <b>const routes = require ('./whateverpath/whateverfilewiththeroutes');</b> and then <b>app.use(routes)</b><br/>
    You can also add something like this at the end (or redirect to a 404 page):
    <pre>
      <code>
        app.use (   (req, res, next) => &lbrace;
          res.send('&lt;h2&gt;oops, I don't know where that is&lt;/h2&gt;');
        &rbrace;);
        ///or could also send the code with res.status(404).send(...)
      </code>
    </pre>

    <p class="HeadingSubTopic2">Express - Filtering Paths</p>
    It's possible to have the same path for 2 different statements, like if we have <b>app.get("/theFolder/thepath")</b> and 
    <b>app.post("/theFolder/thepath")</b>.  If that is the case,
    and we have those in a specific file <b>theFile</b>.  We can do this in the main file:
    <pre>
      <code>
        //in main file (happens first)
        <b>//only routes starting with thefolder will go into the routes in theFile.</b>
        <b>//Also, we don't need to include "theFolder" in the paths in theFile because Express will remove it.</b>
        <b>app.use("/thefolder", theFile); </b>
      </code>
    </pre>



    <p class="HeadingSubTopic" id="HTML">Express - HTML</p>
    


  </div>
  
</div> 
